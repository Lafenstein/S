
build/climate_master_v031.elf:     file format elf32-littlearm


Disassembly of section .text:

080001c0 <Reset_Handler>:
 80001c0:	b672      	cpsid	i
 80001c2:	4821      	ldr	r0, [pc, #132]	; (8000248 <endfiniloop+0x4>)
 80001c4:	f380 8809 	msr	PSP, r0
 80001c8:	2002      	movs	r0, #2
 80001ca:	f380 8814 	msr	CONTROL, r0
 80001ce:	f3bf 8f6f 	isb	sy
 80001d2:	f003 fb9d 	bl	8003910 <__core_init>
 80001d6:	f003 fb13 	bl	8003800 <__early_init>
 80001da:	481c      	ldr	r0, [pc, #112]	; (800024c <endfiniloop+0x8>)
 80001dc:	491c      	ldr	r1, [pc, #112]	; (8000250 <endfiniloop+0xc>)
 80001de:	4a1d      	ldr	r2, [pc, #116]	; (8000254 <endfiniloop+0x10>)

080001e0 <msloop>:
 80001e0:	4291      	cmp	r1, r2
 80001e2:	bf3c      	itt	cc
 80001e4:	f841 0b04 	strcc.w	r0, [r1], #4
 80001e8:	e7fa      	bcc.n	80001e0 <msloop>
 80001ea:	491b      	ldr	r1, [pc, #108]	; (8000258 <endfiniloop+0x14>)
 80001ec:	4a16      	ldr	r2, [pc, #88]	; (8000248 <endfiniloop+0x4>)

080001ee <psloop>:
 80001ee:	4291      	cmp	r1, r2
 80001f0:	bf3c      	itt	cc
 80001f2:	f841 0b04 	strcc.w	r0, [r1], #4
 80001f6:	e7fa      	bcc.n	80001ee <psloop>
 80001f8:	4918      	ldr	r1, [pc, #96]	; (800025c <endfiniloop+0x18>)
 80001fa:	4a19      	ldr	r2, [pc, #100]	; (8000260 <endfiniloop+0x1c>)
 80001fc:	4b19      	ldr	r3, [pc, #100]	; (8000264 <endfiniloop+0x20>)

080001fe <dloop>:
 80001fe:	429a      	cmp	r2, r3
 8000200:	bf3e      	ittt	cc
 8000202:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000206:	f842 0b04 	strcc.w	r0, [r2], #4
 800020a:	e7f8      	bcc.n	80001fe <dloop>
 800020c:	2000      	movs	r0, #0
 800020e:	4916      	ldr	r1, [pc, #88]	; (8000268 <endfiniloop+0x24>)
 8000210:	4a16      	ldr	r2, [pc, #88]	; (800026c <endfiniloop+0x28>)

08000212 <bloop>:
 8000212:	4291      	cmp	r1, r2
 8000214:	bf3c      	itt	cc
 8000216:	f841 0b04 	strcc.w	r0, [r1], #4
 800021a:	e7fa      	bcc.n	8000212 <bloop>
 800021c:	f003 fb70 	bl	8003900 <__late_init>
 8000220:	4c13      	ldr	r4, [pc, #76]	; (8000270 <endfiniloop+0x2c>)
 8000222:	4d14      	ldr	r5, [pc, #80]	; (8000274 <endfiniloop+0x30>)

08000224 <initloop>:
 8000224:	42ac      	cmp	r4, r5
 8000226:	da03      	bge.n	8000230 <endinitloop>
 8000228:	f854 1b04 	ldr.w	r1, [r4], #4
 800022c:	4788      	blx	r1
 800022e:	e7f9      	b.n	8000224 <initloop>

08000230 <endinitloop>:
 8000230:	f002 fe4e 	bl	8002ed0 <main>
 8000234:	4c10      	ldr	r4, [pc, #64]	; (8000278 <endfiniloop+0x34>)
 8000236:	4d11      	ldr	r5, [pc, #68]	; (800027c <endfiniloop+0x38>)

08000238 <finiloop>:
 8000238:	42ac      	cmp	r4, r5
 800023a:	da03      	bge.n	8000244 <endfiniloop>
 800023c:	f854 1b04 	ldr.w	r1, [r4], #4
 8000240:	4788      	blx	r1
 8000242:	e7f9      	b.n	8000238 <finiloop>

08000244 <endfiniloop>:
 8000244:	f003 bb54 	b.w	80038f0 <__default_exit>
 8000248:	20000800 	.word	0x20000800
 800024c:	55555555 	.word	0x55555555
 8000250:	20000000 	.word	0x20000000
 8000254:	20000400 	.word	0x20000400
 8000258:	20000400 	.word	0x20000400
 800025c:	08007808 	.word	0x08007808
 8000260:	20000800 	.word	0x20000800
 8000264:	20000cfc 	.word	0x20000cfc
 8000268:	20000d00 	.word	0x20000d00
 800026c:	200026ac 	.word	0x200026ac
 8000270:	080001c0 	.word	0x080001c0
 8000274:	080001c0 	.word	0x080001c0
 8000278:	080001c0 	.word	0x080001c0
 800027c:	080001c0 	.word	0x080001c0

08000280 <_port_switch>:
 8000280:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000284:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000288:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 800028c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000290 <_port_thread_start>:
 8000290:	2300      	movs	r3, #0
 8000292:	f383 8811 	msr	BASEPRI, r3
 8000296:	4628      	mov	r0, r5
 8000298:	47a0      	blx	r4
 800029a:	2000      	movs	r0, #0
 800029c:	f003 fb18 	bl	80038d0 <chThdExit>

080002a0 <_port_switch_from_isr>:
 80002a0:	f003 fb1e 	bl	80038e0 <chSchDoReschedule>

080002a4 <_port_exit_from_isr>:
 80002a4:	df00      	svc	0
 80002a6:	e7fe      	b.n	80002a6 <_port_exit_from_isr+0x2>
	...

080002b0 <__aeabi_drsub>:
 80002b0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002b4:	e002      	b.n	80002bc <__adddf3>
 80002b6:	bf00      	nop

080002b8 <__aeabi_dsub>:
 80002b8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002bc <__adddf3>:
 80002bc:	b530      	push	{r4, r5, lr}
 80002be:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002c2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002c6:	ea94 0f05 	teq	r4, r5
 80002ca:	bf08      	it	eq
 80002cc:	ea90 0f02 	teqeq	r0, r2
 80002d0:	bf1f      	itttt	ne
 80002d2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002d6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002da:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002de:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002e2:	f000 80e2 	beq.w	80004aa <__adddf3+0x1ee>
 80002e6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002ea:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002ee:	bfb8      	it	lt
 80002f0:	426d      	neglt	r5, r5
 80002f2:	dd0c      	ble.n	800030e <__adddf3+0x52>
 80002f4:	442c      	add	r4, r5
 80002f6:	ea80 0202 	eor.w	r2, r0, r2
 80002fa:	ea81 0303 	eor.w	r3, r1, r3
 80002fe:	ea82 0000 	eor.w	r0, r2, r0
 8000302:	ea83 0101 	eor.w	r1, r3, r1
 8000306:	ea80 0202 	eor.w	r2, r0, r2
 800030a:	ea81 0303 	eor.w	r3, r1, r3
 800030e:	2d36      	cmp	r5, #54	; 0x36
 8000310:	bf88      	it	hi
 8000312:	bd30      	pophi	{r4, r5, pc}
 8000314:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000318:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800031c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000320:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000324:	d002      	beq.n	800032c <__adddf3+0x70>
 8000326:	4240      	negs	r0, r0
 8000328:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800032c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000330:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000334:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000338:	d002      	beq.n	8000340 <__adddf3+0x84>
 800033a:	4252      	negs	r2, r2
 800033c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000340:	ea94 0f05 	teq	r4, r5
 8000344:	f000 80a7 	beq.w	8000496 <__adddf3+0x1da>
 8000348:	f1a4 0401 	sub.w	r4, r4, #1
 800034c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000350:	db0d      	blt.n	800036e <__adddf3+0xb2>
 8000352:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000356:	fa22 f205 	lsr.w	r2, r2, r5
 800035a:	1880      	adds	r0, r0, r2
 800035c:	f141 0100 	adc.w	r1, r1, #0
 8000360:	fa03 f20e 	lsl.w	r2, r3, lr
 8000364:	1880      	adds	r0, r0, r2
 8000366:	fa43 f305 	asr.w	r3, r3, r5
 800036a:	4159      	adcs	r1, r3
 800036c:	e00e      	b.n	800038c <__adddf3+0xd0>
 800036e:	f1a5 0520 	sub.w	r5, r5, #32
 8000372:	f10e 0e20 	add.w	lr, lr, #32
 8000376:	2a01      	cmp	r2, #1
 8000378:	fa03 fc0e 	lsl.w	ip, r3, lr
 800037c:	bf28      	it	cs
 800037e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000382:	fa43 f305 	asr.w	r3, r3, r5
 8000386:	18c0      	adds	r0, r0, r3
 8000388:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800038c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000390:	d507      	bpl.n	80003a2 <__adddf3+0xe6>
 8000392:	f04f 0e00 	mov.w	lr, #0
 8000396:	f1dc 0c00 	rsbs	ip, ip, #0
 800039a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800039e:	eb6e 0101 	sbc.w	r1, lr, r1
 80003a2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003a6:	d31b      	bcc.n	80003e0 <__adddf3+0x124>
 80003a8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003ac:	d30c      	bcc.n	80003c8 <__adddf3+0x10c>
 80003ae:	0849      	lsrs	r1, r1, #1
 80003b0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003b4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003b8:	f104 0401 	add.w	r4, r4, #1
 80003bc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003c0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003c4:	f080 809a 	bcs.w	80004fc <__adddf3+0x240>
 80003c8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003cc:	bf08      	it	eq
 80003ce:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003d2:	f150 0000 	adcs.w	r0, r0, #0
 80003d6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003da:	ea41 0105 	orr.w	r1, r1, r5
 80003de:	bd30      	pop	{r4, r5, pc}
 80003e0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003e4:	4140      	adcs	r0, r0
 80003e6:	eb41 0101 	adc.w	r1, r1, r1
 80003ea:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80003ee:	f1a4 0401 	sub.w	r4, r4, #1
 80003f2:	d1e9      	bne.n	80003c8 <__adddf3+0x10c>
 80003f4:	f091 0f00 	teq	r1, #0
 80003f8:	bf04      	itt	eq
 80003fa:	4601      	moveq	r1, r0
 80003fc:	2000      	moveq	r0, #0
 80003fe:	fab1 f381 	clz	r3, r1
 8000402:	bf08      	it	eq
 8000404:	3320      	addeq	r3, #32
 8000406:	f1a3 030b 	sub.w	r3, r3, #11
 800040a:	f1b3 0220 	subs.w	r2, r3, #32
 800040e:	da0c      	bge.n	800042a <__adddf3+0x16e>
 8000410:	320c      	adds	r2, #12
 8000412:	dd08      	ble.n	8000426 <__adddf3+0x16a>
 8000414:	f102 0c14 	add.w	ip, r2, #20
 8000418:	f1c2 020c 	rsb	r2, r2, #12
 800041c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000420:	fa21 f102 	lsr.w	r1, r1, r2
 8000424:	e00c      	b.n	8000440 <__adddf3+0x184>
 8000426:	f102 0214 	add.w	r2, r2, #20
 800042a:	bfd8      	it	le
 800042c:	f1c2 0c20 	rsble	ip, r2, #32
 8000430:	fa01 f102 	lsl.w	r1, r1, r2
 8000434:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000438:	bfdc      	itt	le
 800043a:	ea41 010c 	orrle.w	r1, r1, ip
 800043e:	4090      	lslle	r0, r2
 8000440:	1ae4      	subs	r4, r4, r3
 8000442:	bfa2      	ittt	ge
 8000444:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000448:	4329      	orrge	r1, r5
 800044a:	bd30      	popge	{r4, r5, pc}
 800044c:	ea6f 0404 	mvn.w	r4, r4
 8000450:	3c1f      	subs	r4, #31
 8000452:	da1c      	bge.n	800048e <__adddf3+0x1d2>
 8000454:	340c      	adds	r4, #12
 8000456:	dc0e      	bgt.n	8000476 <__adddf3+0x1ba>
 8000458:	f104 0414 	add.w	r4, r4, #20
 800045c:	f1c4 0220 	rsb	r2, r4, #32
 8000460:	fa20 f004 	lsr.w	r0, r0, r4
 8000464:	fa01 f302 	lsl.w	r3, r1, r2
 8000468:	ea40 0003 	orr.w	r0, r0, r3
 800046c:	fa21 f304 	lsr.w	r3, r1, r4
 8000470:	ea45 0103 	orr.w	r1, r5, r3
 8000474:	bd30      	pop	{r4, r5, pc}
 8000476:	f1c4 040c 	rsb	r4, r4, #12
 800047a:	f1c4 0220 	rsb	r2, r4, #32
 800047e:	fa20 f002 	lsr.w	r0, r0, r2
 8000482:	fa01 f304 	lsl.w	r3, r1, r4
 8000486:	ea40 0003 	orr.w	r0, r0, r3
 800048a:	4629      	mov	r1, r5
 800048c:	bd30      	pop	{r4, r5, pc}
 800048e:	fa21 f004 	lsr.w	r0, r1, r4
 8000492:	4629      	mov	r1, r5
 8000494:	bd30      	pop	{r4, r5, pc}
 8000496:	f094 0f00 	teq	r4, #0
 800049a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800049e:	bf06      	itte	eq
 80004a0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004a4:	3401      	addeq	r4, #1
 80004a6:	3d01      	subne	r5, #1
 80004a8:	e74e      	b.n	8000348 <__adddf3+0x8c>
 80004aa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ae:	bf18      	it	ne
 80004b0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004b4:	d029      	beq.n	800050a <__adddf3+0x24e>
 80004b6:	ea94 0f05 	teq	r4, r5
 80004ba:	bf08      	it	eq
 80004bc:	ea90 0f02 	teqeq	r0, r2
 80004c0:	d005      	beq.n	80004ce <__adddf3+0x212>
 80004c2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004c6:	bf04      	itt	eq
 80004c8:	4619      	moveq	r1, r3
 80004ca:	4610      	moveq	r0, r2
 80004cc:	bd30      	pop	{r4, r5, pc}
 80004ce:	ea91 0f03 	teq	r1, r3
 80004d2:	bf1e      	ittt	ne
 80004d4:	2100      	movne	r1, #0
 80004d6:	2000      	movne	r0, #0
 80004d8:	bd30      	popne	{r4, r5, pc}
 80004da:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004de:	d105      	bne.n	80004ec <__adddf3+0x230>
 80004e0:	0040      	lsls	r0, r0, #1
 80004e2:	4149      	adcs	r1, r1
 80004e4:	bf28      	it	cs
 80004e6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004ea:	bd30      	pop	{r4, r5, pc}
 80004ec:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004f0:	bf3c      	itt	cc
 80004f2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004f6:	bd30      	popcc	{r4, r5, pc}
 80004f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004fc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000500:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000504:	f04f 0000 	mov.w	r0, #0
 8000508:	bd30      	pop	{r4, r5, pc}
 800050a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800050e:	bf1a      	itte	ne
 8000510:	4619      	movne	r1, r3
 8000512:	4610      	movne	r0, r2
 8000514:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000518:	bf1c      	itt	ne
 800051a:	460b      	movne	r3, r1
 800051c:	4602      	movne	r2, r0
 800051e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000522:	bf06      	itte	eq
 8000524:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000528:	ea91 0f03 	teqeq	r1, r3
 800052c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000530:	bd30      	pop	{r4, r5, pc}
 8000532:	bf00      	nop

08000534 <__aeabi_ui2d>:
 8000534:	f090 0f00 	teq	r0, #0
 8000538:	bf04      	itt	eq
 800053a:	2100      	moveq	r1, #0
 800053c:	4770      	bxeq	lr
 800053e:	b530      	push	{r4, r5, lr}
 8000540:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000544:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000548:	f04f 0500 	mov.w	r5, #0
 800054c:	f04f 0100 	mov.w	r1, #0
 8000550:	e750      	b.n	80003f4 <__adddf3+0x138>
 8000552:	bf00      	nop

08000554 <__aeabi_i2d>:
 8000554:	f090 0f00 	teq	r0, #0
 8000558:	bf04      	itt	eq
 800055a:	2100      	moveq	r1, #0
 800055c:	4770      	bxeq	lr
 800055e:	b530      	push	{r4, r5, lr}
 8000560:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000564:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000568:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800056c:	bf48      	it	mi
 800056e:	4240      	negmi	r0, r0
 8000570:	f04f 0100 	mov.w	r1, #0
 8000574:	e73e      	b.n	80003f4 <__adddf3+0x138>
 8000576:	bf00      	nop

08000578 <__aeabi_f2d>:
 8000578:	0042      	lsls	r2, r0, #1
 800057a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800057e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000582:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000586:	bf1f      	itttt	ne
 8000588:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800058c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000590:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000594:	4770      	bxne	lr
 8000596:	f092 0f00 	teq	r2, #0
 800059a:	bf14      	ite	ne
 800059c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005a0:	4770      	bxeq	lr
 80005a2:	b530      	push	{r4, r5, lr}
 80005a4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005a8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005ac:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005b0:	e720      	b.n	80003f4 <__adddf3+0x138>
 80005b2:	bf00      	nop

080005b4 <__aeabi_ul2d>:
 80005b4:	ea50 0201 	orrs.w	r2, r0, r1
 80005b8:	bf08      	it	eq
 80005ba:	4770      	bxeq	lr
 80005bc:	b530      	push	{r4, r5, lr}
 80005be:	f04f 0500 	mov.w	r5, #0
 80005c2:	e00a      	b.n	80005da <__aeabi_l2d+0x16>

080005c4 <__aeabi_l2d>:
 80005c4:	ea50 0201 	orrs.w	r2, r0, r1
 80005c8:	bf08      	it	eq
 80005ca:	4770      	bxeq	lr
 80005cc:	b530      	push	{r4, r5, lr}
 80005ce:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005d2:	d502      	bpl.n	80005da <__aeabi_l2d+0x16>
 80005d4:	4240      	negs	r0, r0
 80005d6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005da:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005de:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005e2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005e6:	f43f aedc 	beq.w	80003a2 <__adddf3+0xe6>
 80005ea:	f04f 0203 	mov.w	r2, #3
 80005ee:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005f2:	bf18      	it	ne
 80005f4:	3203      	addne	r2, #3
 80005f6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005fa:	bf18      	it	ne
 80005fc:	3203      	addne	r2, #3
 80005fe:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000602:	f1c2 0320 	rsb	r3, r2, #32
 8000606:	fa00 fc03 	lsl.w	ip, r0, r3
 800060a:	fa20 f002 	lsr.w	r0, r0, r2
 800060e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000612:	ea40 000e 	orr.w	r0, r0, lr
 8000616:	fa21 f102 	lsr.w	r1, r1, r2
 800061a:	4414      	add	r4, r2
 800061c:	e6c1      	b.n	80003a2 <__adddf3+0xe6>
 800061e:	bf00      	nop

08000620 <__aeabi_dmul>:
 8000620:	b570      	push	{r4, r5, r6, lr}
 8000622:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000626:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800062a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800062e:	bf1d      	ittte	ne
 8000630:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000634:	ea94 0f0c 	teqne	r4, ip
 8000638:	ea95 0f0c 	teqne	r5, ip
 800063c:	f000 f8de 	bleq	80007fc <__aeabi_dmul+0x1dc>
 8000640:	442c      	add	r4, r5
 8000642:	ea81 0603 	eor.w	r6, r1, r3
 8000646:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800064a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800064e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000652:	bf18      	it	ne
 8000654:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000658:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800065c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000660:	d038      	beq.n	80006d4 <__aeabi_dmul+0xb4>
 8000662:	fba0 ce02 	umull	ip, lr, r0, r2
 8000666:	f04f 0500 	mov.w	r5, #0
 800066a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800066e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000672:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000676:	f04f 0600 	mov.w	r6, #0
 800067a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800067e:	f09c 0f00 	teq	ip, #0
 8000682:	bf18      	it	ne
 8000684:	f04e 0e01 	orrne.w	lr, lr, #1
 8000688:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800068c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000690:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000694:	d204      	bcs.n	80006a0 <__aeabi_dmul+0x80>
 8000696:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800069a:	416d      	adcs	r5, r5
 800069c:	eb46 0606 	adc.w	r6, r6, r6
 80006a0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006a4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006a8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006ac:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006b0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006b4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006b8:	bf88      	it	hi
 80006ba:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006be:	d81e      	bhi.n	80006fe <__aeabi_dmul+0xde>
 80006c0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006c4:	bf08      	it	eq
 80006c6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006ca:	f150 0000 	adcs.w	r0, r0, #0
 80006ce:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006d2:	bd70      	pop	{r4, r5, r6, pc}
 80006d4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006d8:	ea46 0101 	orr.w	r1, r6, r1
 80006dc:	ea40 0002 	orr.w	r0, r0, r2
 80006e0:	ea81 0103 	eor.w	r1, r1, r3
 80006e4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006e8:	bfc2      	ittt	gt
 80006ea:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006ee:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006f2:	bd70      	popgt	{r4, r5, r6, pc}
 80006f4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006f8:	f04f 0e00 	mov.w	lr, #0
 80006fc:	3c01      	subs	r4, #1
 80006fe:	f300 80ab 	bgt.w	8000858 <__aeabi_dmul+0x238>
 8000702:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000706:	bfde      	ittt	le
 8000708:	2000      	movle	r0, #0
 800070a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800070e:	bd70      	pople	{r4, r5, r6, pc}
 8000710:	f1c4 0400 	rsb	r4, r4, #0
 8000714:	3c20      	subs	r4, #32
 8000716:	da35      	bge.n	8000784 <__aeabi_dmul+0x164>
 8000718:	340c      	adds	r4, #12
 800071a:	dc1b      	bgt.n	8000754 <__aeabi_dmul+0x134>
 800071c:	f104 0414 	add.w	r4, r4, #20
 8000720:	f1c4 0520 	rsb	r5, r4, #32
 8000724:	fa00 f305 	lsl.w	r3, r0, r5
 8000728:	fa20 f004 	lsr.w	r0, r0, r4
 800072c:	fa01 f205 	lsl.w	r2, r1, r5
 8000730:	ea40 0002 	orr.w	r0, r0, r2
 8000734:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000738:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800073c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000740:	fa21 f604 	lsr.w	r6, r1, r4
 8000744:	eb42 0106 	adc.w	r1, r2, r6
 8000748:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800074c:	bf08      	it	eq
 800074e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000752:	bd70      	pop	{r4, r5, r6, pc}
 8000754:	f1c4 040c 	rsb	r4, r4, #12
 8000758:	f1c4 0520 	rsb	r5, r4, #32
 800075c:	fa00 f304 	lsl.w	r3, r0, r4
 8000760:	fa20 f005 	lsr.w	r0, r0, r5
 8000764:	fa01 f204 	lsl.w	r2, r1, r4
 8000768:	ea40 0002 	orr.w	r0, r0, r2
 800076c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000770:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000774:	f141 0100 	adc.w	r1, r1, #0
 8000778:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800077c:	bf08      	it	eq
 800077e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000782:	bd70      	pop	{r4, r5, r6, pc}
 8000784:	f1c4 0520 	rsb	r5, r4, #32
 8000788:	fa00 f205 	lsl.w	r2, r0, r5
 800078c:	ea4e 0e02 	orr.w	lr, lr, r2
 8000790:	fa20 f304 	lsr.w	r3, r0, r4
 8000794:	fa01 f205 	lsl.w	r2, r1, r5
 8000798:	ea43 0302 	orr.w	r3, r3, r2
 800079c:	fa21 f004 	lsr.w	r0, r1, r4
 80007a0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007a4:	fa21 f204 	lsr.w	r2, r1, r4
 80007a8:	ea20 0002 	bic.w	r0, r0, r2
 80007ac:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007b0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007b4:	bf08      	it	eq
 80007b6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007ba:	bd70      	pop	{r4, r5, r6, pc}
 80007bc:	f094 0f00 	teq	r4, #0
 80007c0:	d10f      	bne.n	80007e2 <__aeabi_dmul+0x1c2>
 80007c2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007c6:	0040      	lsls	r0, r0, #1
 80007c8:	eb41 0101 	adc.w	r1, r1, r1
 80007cc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007d0:	bf08      	it	eq
 80007d2:	3c01      	subeq	r4, #1
 80007d4:	d0f7      	beq.n	80007c6 <__aeabi_dmul+0x1a6>
 80007d6:	ea41 0106 	orr.w	r1, r1, r6
 80007da:	f095 0f00 	teq	r5, #0
 80007de:	bf18      	it	ne
 80007e0:	4770      	bxne	lr
 80007e2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007e6:	0052      	lsls	r2, r2, #1
 80007e8:	eb43 0303 	adc.w	r3, r3, r3
 80007ec:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007f0:	bf08      	it	eq
 80007f2:	3d01      	subeq	r5, #1
 80007f4:	d0f7      	beq.n	80007e6 <__aeabi_dmul+0x1c6>
 80007f6:	ea43 0306 	orr.w	r3, r3, r6
 80007fa:	4770      	bx	lr
 80007fc:	ea94 0f0c 	teq	r4, ip
 8000800:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000804:	bf18      	it	ne
 8000806:	ea95 0f0c 	teqne	r5, ip
 800080a:	d00c      	beq.n	8000826 <__aeabi_dmul+0x206>
 800080c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000810:	bf18      	it	ne
 8000812:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000816:	d1d1      	bne.n	80007bc <__aeabi_dmul+0x19c>
 8000818:	ea81 0103 	eor.w	r1, r1, r3
 800081c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000820:	f04f 0000 	mov.w	r0, #0
 8000824:	bd70      	pop	{r4, r5, r6, pc}
 8000826:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800082a:	bf06      	itte	eq
 800082c:	4610      	moveq	r0, r2
 800082e:	4619      	moveq	r1, r3
 8000830:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000834:	d019      	beq.n	800086a <__aeabi_dmul+0x24a>
 8000836:	ea94 0f0c 	teq	r4, ip
 800083a:	d102      	bne.n	8000842 <__aeabi_dmul+0x222>
 800083c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000840:	d113      	bne.n	800086a <__aeabi_dmul+0x24a>
 8000842:	ea95 0f0c 	teq	r5, ip
 8000846:	d105      	bne.n	8000854 <__aeabi_dmul+0x234>
 8000848:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800084c:	bf1c      	itt	ne
 800084e:	4610      	movne	r0, r2
 8000850:	4619      	movne	r1, r3
 8000852:	d10a      	bne.n	800086a <__aeabi_dmul+0x24a>
 8000854:	ea81 0103 	eor.w	r1, r1, r3
 8000858:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800085c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000860:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000864:	f04f 0000 	mov.w	r0, #0
 8000868:	bd70      	pop	{r4, r5, r6, pc}
 800086a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800086e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000872:	bd70      	pop	{r4, r5, r6, pc}

08000874 <__aeabi_ddiv>:
 8000874:	b570      	push	{r4, r5, r6, lr}
 8000876:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800087a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800087e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000882:	bf1d      	ittte	ne
 8000884:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000888:	ea94 0f0c 	teqne	r4, ip
 800088c:	ea95 0f0c 	teqne	r5, ip
 8000890:	f000 f8a7 	bleq	80009e2 <__aeabi_ddiv+0x16e>
 8000894:	eba4 0405 	sub.w	r4, r4, r5
 8000898:	ea81 0e03 	eor.w	lr, r1, r3
 800089c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008a0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008a4:	f000 8088 	beq.w	80009b8 <__aeabi_ddiv+0x144>
 80008a8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008ac:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008b0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008b4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008b8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008bc:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008c0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008c4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008c8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008cc:	429d      	cmp	r5, r3
 80008ce:	bf08      	it	eq
 80008d0:	4296      	cmpeq	r6, r2
 80008d2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008d6:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008da:	d202      	bcs.n	80008e2 <__aeabi_ddiv+0x6e>
 80008dc:	085b      	lsrs	r3, r3, #1
 80008de:	ea4f 0232 	mov.w	r2, r2, rrx
 80008e2:	1ab6      	subs	r6, r6, r2
 80008e4:	eb65 0503 	sbc.w	r5, r5, r3
 80008e8:	085b      	lsrs	r3, r3, #1
 80008ea:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ee:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008f2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008f6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008fa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008fe:	bf22      	ittt	cs
 8000900:	1ab6      	subcs	r6, r6, r2
 8000902:	4675      	movcs	r5, lr
 8000904:	ea40 000c 	orrcs.w	r0, r0, ip
 8000908:	085b      	lsrs	r3, r3, #1
 800090a:	ea4f 0232 	mov.w	r2, r2, rrx
 800090e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000912:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000916:	bf22      	ittt	cs
 8000918:	1ab6      	subcs	r6, r6, r2
 800091a:	4675      	movcs	r5, lr
 800091c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000920:	085b      	lsrs	r3, r3, #1
 8000922:	ea4f 0232 	mov.w	r2, r2, rrx
 8000926:	ebb6 0e02 	subs.w	lr, r6, r2
 800092a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800092e:	bf22      	ittt	cs
 8000930:	1ab6      	subcs	r6, r6, r2
 8000932:	4675      	movcs	r5, lr
 8000934:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000938:	085b      	lsrs	r3, r3, #1
 800093a:	ea4f 0232 	mov.w	r2, r2, rrx
 800093e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000942:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000946:	bf22      	ittt	cs
 8000948:	1ab6      	subcs	r6, r6, r2
 800094a:	4675      	movcs	r5, lr
 800094c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000950:	ea55 0e06 	orrs.w	lr, r5, r6
 8000954:	d018      	beq.n	8000988 <__aeabi_ddiv+0x114>
 8000956:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800095a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800095e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000962:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000966:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800096a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800096e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000972:	d1c0      	bne.n	80008f6 <__aeabi_ddiv+0x82>
 8000974:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000978:	d10b      	bne.n	8000992 <__aeabi_ddiv+0x11e>
 800097a:	ea41 0100 	orr.w	r1, r1, r0
 800097e:	f04f 0000 	mov.w	r0, #0
 8000982:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000986:	e7b6      	b.n	80008f6 <__aeabi_ddiv+0x82>
 8000988:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800098c:	bf04      	itt	eq
 800098e:	4301      	orreq	r1, r0
 8000990:	2000      	moveq	r0, #0
 8000992:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000996:	bf88      	it	hi
 8000998:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800099c:	f63f aeaf 	bhi.w	80006fe <__aeabi_dmul+0xde>
 80009a0:	ebb5 0c03 	subs.w	ip, r5, r3
 80009a4:	bf04      	itt	eq
 80009a6:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009aa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009ae:	f150 0000 	adcs.w	r0, r0, #0
 80009b2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009b6:	bd70      	pop	{r4, r5, r6, pc}
 80009b8:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009bc:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009c0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009c4:	bfc2      	ittt	gt
 80009c6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009ca:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009ce:	bd70      	popgt	{r4, r5, r6, pc}
 80009d0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009d4:	f04f 0e00 	mov.w	lr, #0
 80009d8:	3c01      	subs	r4, #1
 80009da:	e690      	b.n	80006fe <__aeabi_dmul+0xde>
 80009dc:	ea45 0e06 	orr.w	lr, r5, r6
 80009e0:	e68d      	b.n	80006fe <__aeabi_dmul+0xde>
 80009e2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009e6:	ea94 0f0c 	teq	r4, ip
 80009ea:	bf08      	it	eq
 80009ec:	ea95 0f0c 	teqeq	r5, ip
 80009f0:	f43f af3b 	beq.w	800086a <__aeabi_dmul+0x24a>
 80009f4:	ea94 0f0c 	teq	r4, ip
 80009f8:	d10a      	bne.n	8000a10 <__aeabi_ddiv+0x19c>
 80009fa:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009fe:	f47f af34 	bne.w	800086a <__aeabi_dmul+0x24a>
 8000a02:	ea95 0f0c 	teq	r5, ip
 8000a06:	f47f af25 	bne.w	8000854 <__aeabi_dmul+0x234>
 8000a0a:	4610      	mov	r0, r2
 8000a0c:	4619      	mov	r1, r3
 8000a0e:	e72c      	b.n	800086a <__aeabi_dmul+0x24a>
 8000a10:	ea95 0f0c 	teq	r5, ip
 8000a14:	d106      	bne.n	8000a24 <__aeabi_ddiv+0x1b0>
 8000a16:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a1a:	f43f aefd 	beq.w	8000818 <__aeabi_dmul+0x1f8>
 8000a1e:	4610      	mov	r0, r2
 8000a20:	4619      	mov	r1, r3
 8000a22:	e722      	b.n	800086a <__aeabi_dmul+0x24a>
 8000a24:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a28:	bf18      	it	ne
 8000a2a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a2e:	f47f aec5 	bne.w	80007bc <__aeabi_dmul+0x19c>
 8000a32:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a36:	f47f af0d 	bne.w	8000854 <__aeabi_dmul+0x234>
 8000a3a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a3e:	f47f aeeb 	bne.w	8000818 <__aeabi_dmul+0x1f8>
 8000a42:	e712      	b.n	800086a <__aeabi_dmul+0x24a>
	...

08000a50 <__aeabi_d2uiz>:
 8000a50:	004a      	lsls	r2, r1, #1
 8000a52:	d211      	bcs.n	8000a78 <__aeabi_d2uiz+0x28>
 8000a54:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000a58:	d211      	bcs.n	8000a7e <__aeabi_d2uiz+0x2e>
 8000a5a:	d50d      	bpl.n	8000a78 <__aeabi_d2uiz+0x28>
 8000a5c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000a60:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000a64:	d40e      	bmi.n	8000a84 <__aeabi_d2uiz+0x34>
 8000a66:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a6a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000a6e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000a72:	fa23 f002 	lsr.w	r0, r3, r2
 8000a76:	4770      	bx	lr
 8000a78:	f04f 0000 	mov.w	r0, #0
 8000a7c:	4770      	bx	lr
 8000a7e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000a82:	d102      	bne.n	8000a8a <__aeabi_d2uiz+0x3a>
 8000a84:	f04f 30ff 	mov.w	r0, #4294967295
 8000a88:	4770      	bx	lr
 8000a8a:	f04f 0000 	mov.w	r0, #0
 8000a8e:	4770      	bx	lr

08000a90 <__aeabi_d2f>:
 8000a90:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a94:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000a98:	bf24      	itt	cs
 8000a9a:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000a9e:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000aa2:	d90d      	bls.n	8000ac0 <__aeabi_d2f+0x30>
 8000aa4:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000aa8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000aac:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000ab0:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000ab4:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000ab8:	bf08      	it	eq
 8000aba:	f020 0001 	biceq.w	r0, r0, #1
 8000abe:	4770      	bx	lr
 8000ac0:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000ac4:	d121      	bne.n	8000b0a <__aeabi_d2f+0x7a>
 8000ac6:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000aca:	bfbc      	itt	lt
 8000acc:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000ad0:	4770      	bxlt	lr
 8000ad2:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000ad6:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000ada:	f1c2 0218 	rsb	r2, r2, #24
 8000ade:	f1c2 0c20 	rsb	ip, r2, #32
 8000ae2:	fa10 f30c 	lsls.w	r3, r0, ip
 8000ae6:	fa20 f002 	lsr.w	r0, r0, r2
 8000aea:	bf18      	it	ne
 8000aec:	f040 0001 	orrne.w	r0, r0, #1
 8000af0:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000af4:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000af8:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000afc:	ea40 000c 	orr.w	r0, r0, ip
 8000b00:	fa23 f302 	lsr.w	r3, r3, r2
 8000b04:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000b08:	e7cc      	b.n	8000aa4 <__aeabi_d2f+0x14>
 8000b0a:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000b0e:	d107      	bne.n	8000b20 <__aeabi_d2f+0x90>
 8000b10:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000b14:	bf1e      	ittt	ne
 8000b16:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000b1a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000b1e:	4770      	bxne	lr
 8000b20:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000b24:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000b28:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000b2c:	4770      	bx	lr
 8000b2e:	bf00      	nop

08000b30 <__aeabi_frsub>:
 8000b30:	f080 4000 	eor.w	r0, r0, #2147483648	; 0x80000000
 8000b34:	e002      	b.n	8000b3c <__addsf3>
 8000b36:	bf00      	nop

08000b38 <__aeabi_fsub>:
 8000b38:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000

08000b3c <__addsf3>:
 8000b3c:	0042      	lsls	r2, r0, #1
 8000b3e:	bf1f      	itttt	ne
 8000b40:	ea5f 0341 	movsne.w	r3, r1, lsl #1
 8000b44:	ea92 0f03 	teqne	r2, r3
 8000b48:	ea7f 6c22 	mvnsne.w	ip, r2, asr #24
 8000b4c:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000b50:	d06a      	beq.n	8000c28 <__addsf3+0xec>
 8000b52:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000b56:	ebd2 6313 	rsbs	r3, r2, r3, lsr #24
 8000b5a:	bfc1      	itttt	gt
 8000b5c:	18d2      	addgt	r2, r2, r3
 8000b5e:	4041      	eorgt	r1, r0
 8000b60:	4048      	eorgt	r0, r1
 8000b62:	4041      	eorgt	r1, r0
 8000b64:	bfb8      	it	lt
 8000b66:	425b      	neglt	r3, r3
 8000b68:	2b19      	cmp	r3, #25
 8000b6a:	bf88      	it	hi
 8000b6c:	4770      	bxhi	lr
 8000b6e:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000b72:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000b76:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8000b7a:	bf18      	it	ne
 8000b7c:	4240      	negne	r0, r0
 8000b7e:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000b82:	f441 0100 	orr.w	r1, r1, #8388608	; 0x800000
 8000b86:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 8000b8a:	bf18      	it	ne
 8000b8c:	4249      	negne	r1, r1
 8000b8e:	ea92 0f03 	teq	r2, r3
 8000b92:	d03f      	beq.n	8000c14 <__addsf3+0xd8>
 8000b94:	f1a2 0201 	sub.w	r2, r2, #1
 8000b98:	fa41 fc03 	asr.w	ip, r1, r3
 8000b9c:	eb10 000c 	adds.w	r0, r0, ip
 8000ba0:	f1c3 0320 	rsb	r3, r3, #32
 8000ba4:	fa01 f103 	lsl.w	r1, r1, r3
 8000ba8:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000bac:	d502      	bpl.n	8000bb4 <__addsf3+0x78>
 8000bae:	4249      	negs	r1, r1
 8000bb0:	eb60 0040 	sbc.w	r0, r0, r0, lsl #1
 8000bb4:	f5b0 0f00 	cmp.w	r0, #8388608	; 0x800000
 8000bb8:	d313      	bcc.n	8000be2 <__addsf3+0xa6>
 8000bba:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000bbe:	d306      	bcc.n	8000bce <__addsf3+0x92>
 8000bc0:	0840      	lsrs	r0, r0, #1
 8000bc2:	ea4f 0131 	mov.w	r1, r1, rrx
 8000bc6:	f102 0201 	add.w	r2, r2, #1
 8000bca:	2afe      	cmp	r2, #254	; 0xfe
 8000bcc:	d251      	bcs.n	8000c72 <__addsf3+0x136>
 8000bce:	f1b1 4f00 	cmp.w	r1, #2147483648	; 0x80000000
 8000bd2:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000bd6:	bf08      	it	eq
 8000bd8:	f020 0001 	biceq.w	r0, r0, #1
 8000bdc:	ea40 0003 	orr.w	r0, r0, r3
 8000be0:	4770      	bx	lr
 8000be2:	0049      	lsls	r1, r1, #1
 8000be4:	eb40 0000 	adc.w	r0, r0, r0
 8000be8:	f410 0f00 	tst.w	r0, #8388608	; 0x800000
 8000bec:	f1a2 0201 	sub.w	r2, r2, #1
 8000bf0:	d1ed      	bne.n	8000bce <__addsf3+0x92>
 8000bf2:	fab0 fc80 	clz	ip, r0
 8000bf6:	f1ac 0c08 	sub.w	ip, ip, #8
 8000bfa:	ebb2 020c 	subs.w	r2, r2, ip
 8000bfe:	fa00 f00c 	lsl.w	r0, r0, ip
 8000c02:	bfaa      	itet	ge
 8000c04:	eb00 50c2 	addge.w	r0, r0, r2, lsl #23
 8000c08:	4252      	neglt	r2, r2
 8000c0a:	4318      	orrge	r0, r3
 8000c0c:	bfbc      	itt	lt
 8000c0e:	40d0      	lsrlt	r0, r2
 8000c10:	4318      	orrlt	r0, r3
 8000c12:	4770      	bx	lr
 8000c14:	f092 0f00 	teq	r2, #0
 8000c18:	f481 0100 	eor.w	r1, r1, #8388608	; 0x800000
 8000c1c:	bf06      	itte	eq
 8000c1e:	f480 0000 	eoreq.w	r0, r0, #8388608	; 0x800000
 8000c22:	3201      	addeq	r2, #1
 8000c24:	3b01      	subne	r3, #1
 8000c26:	e7b5      	b.n	8000b94 <__addsf3+0x58>
 8000c28:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000c2c:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000c30:	bf18      	it	ne
 8000c32:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000c36:	d021      	beq.n	8000c7c <__addsf3+0x140>
 8000c38:	ea92 0f03 	teq	r2, r3
 8000c3c:	d004      	beq.n	8000c48 <__addsf3+0x10c>
 8000c3e:	f092 0f00 	teq	r2, #0
 8000c42:	bf08      	it	eq
 8000c44:	4608      	moveq	r0, r1
 8000c46:	4770      	bx	lr
 8000c48:	ea90 0f01 	teq	r0, r1
 8000c4c:	bf1c      	itt	ne
 8000c4e:	2000      	movne	r0, #0
 8000c50:	4770      	bxne	lr
 8000c52:	f012 4f7f 	tst.w	r2, #4278190080	; 0xff000000
 8000c56:	d104      	bne.n	8000c62 <__addsf3+0x126>
 8000c58:	0040      	lsls	r0, r0, #1
 8000c5a:	bf28      	it	cs
 8000c5c:	f040 4000 	orrcs.w	r0, r0, #2147483648	; 0x80000000
 8000c60:	4770      	bx	lr
 8000c62:	f112 7200 	adds.w	r2, r2, #33554432	; 0x2000000
 8000c66:	bf3c      	itt	cc
 8000c68:	f500 0000 	addcc.w	r0, r0, #8388608	; 0x800000
 8000c6c:	4770      	bxcc	lr
 8000c6e:	f000 4300 	and.w	r3, r0, #2147483648	; 0x80000000
 8000c72:	f043 40fe 	orr.w	r0, r3, #2130706432	; 0x7f000000
 8000c76:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000c7a:	4770      	bx	lr
 8000c7c:	ea7f 6222 	mvns.w	r2, r2, asr #24
 8000c80:	bf16      	itet	ne
 8000c82:	4608      	movne	r0, r1
 8000c84:	ea7f 6323 	mvnseq.w	r3, r3, asr #24
 8000c88:	4601      	movne	r1, r0
 8000c8a:	0242      	lsls	r2, r0, #9
 8000c8c:	bf06      	itte	eq
 8000c8e:	ea5f 2341 	movseq.w	r3, r1, lsl #9
 8000c92:	ea90 0f01 	teqeq	r0, r1
 8000c96:	f440 0080 	orrne.w	r0, r0, #4194304	; 0x400000
 8000c9a:	4770      	bx	lr

08000c9c <__aeabi_ui2f>:
 8000c9c:	f04f 0300 	mov.w	r3, #0
 8000ca0:	e004      	b.n	8000cac <__aeabi_i2f+0x8>
 8000ca2:	bf00      	nop

08000ca4 <__aeabi_i2f>:
 8000ca4:	f010 4300 	ands.w	r3, r0, #2147483648	; 0x80000000
 8000ca8:	bf48      	it	mi
 8000caa:	4240      	negmi	r0, r0
 8000cac:	ea5f 0c00 	movs.w	ip, r0
 8000cb0:	bf08      	it	eq
 8000cb2:	4770      	bxeq	lr
 8000cb4:	f043 4396 	orr.w	r3, r3, #1258291200	; 0x4b000000
 8000cb8:	4601      	mov	r1, r0
 8000cba:	f04f 0000 	mov.w	r0, #0
 8000cbe:	e01c      	b.n	8000cfa <__aeabi_l2f+0x2a>

08000cc0 <__aeabi_ul2f>:
 8000cc0:	ea50 0201 	orrs.w	r2, r0, r1
 8000cc4:	bf08      	it	eq
 8000cc6:	4770      	bxeq	lr
 8000cc8:	f04f 0300 	mov.w	r3, #0
 8000ccc:	e00a      	b.n	8000ce4 <__aeabi_l2f+0x14>
 8000cce:	bf00      	nop

08000cd0 <__aeabi_l2f>:
 8000cd0:	ea50 0201 	orrs.w	r2, r0, r1
 8000cd4:	bf08      	it	eq
 8000cd6:	4770      	bxeq	lr
 8000cd8:	f011 4300 	ands.w	r3, r1, #2147483648	; 0x80000000
 8000cdc:	d502      	bpl.n	8000ce4 <__aeabi_l2f+0x14>
 8000cde:	4240      	negs	r0, r0
 8000ce0:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000ce4:	ea5f 0c01 	movs.w	ip, r1
 8000ce8:	bf02      	ittt	eq
 8000cea:	4684      	moveq	ip, r0
 8000cec:	4601      	moveq	r1, r0
 8000cee:	2000      	moveq	r0, #0
 8000cf0:	f043 43b6 	orr.w	r3, r3, #1526726656	; 0x5b000000
 8000cf4:	bf08      	it	eq
 8000cf6:	f1a3 5380 	subeq.w	r3, r3, #268435456	; 0x10000000
 8000cfa:	f5a3 0300 	sub.w	r3, r3, #8388608	; 0x800000
 8000cfe:	fabc f28c 	clz	r2, ip
 8000d02:	3a08      	subs	r2, #8
 8000d04:	eba3 53c2 	sub.w	r3, r3, r2, lsl #23
 8000d08:	db10      	blt.n	8000d2c <__aeabi_l2f+0x5c>
 8000d0a:	fa01 fc02 	lsl.w	ip, r1, r2
 8000d0e:	4463      	add	r3, ip
 8000d10:	fa00 fc02 	lsl.w	ip, r0, r2
 8000d14:	f1c2 0220 	rsb	r2, r2, #32
 8000d18:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000d1c:	fa20 f202 	lsr.w	r2, r0, r2
 8000d20:	eb43 0002 	adc.w	r0, r3, r2
 8000d24:	bf08      	it	eq
 8000d26:	f020 0001 	biceq.w	r0, r0, #1
 8000d2a:	4770      	bx	lr
 8000d2c:	f102 0220 	add.w	r2, r2, #32
 8000d30:	fa01 fc02 	lsl.w	ip, r1, r2
 8000d34:	f1c2 0220 	rsb	r2, r2, #32
 8000d38:	ea50 004c 	orrs.w	r0, r0, ip, lsl #1
 8000d3c:	fa21 f202 	lsr.w	r2, r1, r2
 8000d40:	eb43 0002 	adc.w	r0, r3, r2
 8000d44:	bf08      	it	eq
 8000d46:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000d4a:	4770      	bx	lr
 8000d4c:	0000      	movs	r0, r0
	...

08000d50 <__aeabi_fmul>:
 8000d50:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000d54:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000d58:	bf1e      	ittt	ne
 8000d5a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000d5e:	ea92 0f0c 	teqne	r2, ip
 8000d62:	ea93 0f0c 	teqne	r3, ip
 8000d66:	d06f      	beq.n	8000e48 <__aeabi_fmul+0xf8>
 8000d68:	441a      	add	r2, r3
 8000d6a:	ea80 0c01 	eor.w	ip, r0, r1
 8000d6e:	0240      	lsls	r0, r0, #9
 8000d70:	bf18      	it	ne
 8000d72:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 8000d76:	d01e      	beq.n	8000db6 <__aeabi_fmul+0x66>
 8000d78:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000d7c:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 8000d80:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 8000d84:	fba0 3101 	umull	r3, r1, r0, r1
 8000d88:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000d8c:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 8000d90:	bf3e      	ittt	cc
 8000d92:	0049      	lslcc	r1, r1, #1
 8000d94:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 8000d98:	005b      	lslcc	r3, r3, #1
 8000d9a:	ea40 0001 	orr.w	r0, r0, r1
 8000d9e:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 8000da2:	2afd      	cmp	r2, #253	; 0xfd
 8000da4:	d81d      	bhi.n	8000de2 <__aeabi_fmul+0x92>
 8000da6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 8000daa:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000dae:	bf08      	it	eq
 8000db0:	f020 0001 	biceq.w	r0, r0, #1
 8000db4:	4770      	bx	lr
 8000db6:	f090 0f00 	teq	r0, #0
 8000dba:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000dbe:	bf08      	it	eq
 8000dc0:	0249      	lsleq	r1, r1, #9
 8000dc2:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000dc6:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 8000dca:	3a7f      	subs	r2, #127	; 0x7f
 8000dcc:	bfc2      	ittt	gt
 8000dce:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000dd2:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000dd6:	4770      	bxgt	lr
 8000dd8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000ddc:	f04f 0300 	mov.w	r3, #0
 8000de0:	3a01      	subs	r2, #1
 8000de2:	dc5d      	bgt.n	8000ea0 <__aeabi_fmul+0x150>
 8000de4:	f112 0f19 	cmn.w	r2, #25
 8000de8:	bfdc      	itt	le
 8000dea:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 8000dee:	4770      	bxle	lr
 8000df0:	f1c2 0200 	rsb	r2, r2, #0
 8000df4:	0041      	lsls	r1, r0, #1
 8000df6:	fa21 f102 	lsr.w	r1, r1, r2
 8000dfa:	f1c2 0220 	rsb	r2, r2, #32
 8000dfe:	fa00 fc02 	lsl.w	ip, r0, r2
 8000e02:	ea5f 0031 	movs.w	r0, r1, rrx
 8000e06:	f140 0000 	adc.w	r0, r0, #0
 8000e0a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 8000e0e:	bf08      	it	eq
 8000e10:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 8000e14:	4770      	bx	lr
 8000e16:	f092 0f00 	teq	r2, #0
 8000e1a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000e1e:	bf02      	ittt	eq
 8000e20:	0040      	lsleq	r0, r0, #1
 8000e22:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000e26:	3a01      	subeq	r2, #1
 8000e28:	d0f9      	beq.n	8000e1e <__aeabi_fmul+0xce>
 8000e2a:	ea40 000c 	orr.w	r0, r0, ip
 8000e2e:	f093 0f00 	teq	r3, #0
 8000e32:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000e36:	bf02      	ittt	eq
 8000e38:	0049      	lsleq	r1, r1, #1
 8000e3a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000e3e:	3b01      	subeq	r3, #1
 8000e40:	d0f9      	beq.n	8000e36 <__aeabi_fmul+0xe6>
 8000e42:	ea41 010c 	orr.w	r1, r1, ip
 8000e46:	e78f      	b.n	8000d68 <__aeabi_fmul+0x18>
 8000e48:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000e4c:	ea92 0f0c 	teq	r2, ip
 8000e50:	bf18      	it	ne
 8000e52:	ea93 0f0c 	teqne	r3, ip
 8000e56:	d00a      	beq.n	8000e6e <__aeabi_fmul+0x11e>
 8000e58:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000e5c:	bf18      	it	ne
 8000e5e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000e62:	d1d8      	bne.n	8000e16 <__aeabi_fmul+0xc6>
 8000e64:	ea80 0001 	eor.w	r0, r0, r1
 8000e68:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000e6c:	4770      	bx	lr
 8000e6e:	f090 0f00 	teq	r0, #0
 8000e72:	bf17      	itett	ne
 8000e74:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 8000e78:	4608      	moveq	r0, r1
 8000e7a:	f091 0f00 	teqne	r1, #0
 8000e7e:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 8000e82:	d014      	beq.n	8000eae <__aeabi_fmul+0x15e>
 8000e84:	ea92 0f0c 	teq	r2, ip
 8000e88:	d101      	bne.n	8000e8e <__aeabi_fmul+0x13e>
 8000e8a:	0242      	lsls	r2, r0, #9
 8000e8c:	d10f      	bne.n	8000eae <__aeabi_fmul+0x15e>
 8000e8e:	ea93 0f0c 	teq	r3, ip
 8000e92:	d103      	bne.n	8000e9c <__aeabi_fmul+0x14c>
 8000e94:	024b      	lsls	r3, r1, #9
 8000e96:	bf18      	it	ne
 8000e98:	4608      	movne	r0, r1
 8000e9a:	d108      	bne.n	8000eae <__aeabi_fmul+0x15e>
 8000e9c:	ea80 0001 	eor.w	r0, r0, r1
 8000ea0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 8000ea4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000ea8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000eac:	4770      	bx	lr
 8000eae:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000eb2:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 8000eb6:	4770      	bx	lr

08000eb8 <__aeabi_fdiv>:
 8000eb8:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000ebc:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 8000ec0:	bf1e      	ittt	ne
 8000ec2:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 8000ec6:	ea92 0f0c 	teqne	r2, ip
 8000eca:	ea93 0f0c 	teqne	r3, ip
 8000ece:	d069      	beq.n	8000fa4 <__aeabi_fdiv+0xec>
 8000ed0:	eba2 0203 	sub.w	r2, r2, r3
 8000ed4:	ea80 0c01 	eor.w	ip, r0, r1
 8000ed8:	0249      	lsls	r1, r1, #9
 8000eda:	ea4f 2040 	mov.w	r0, r0, lsl #9
 8000ede:	d037      	beq.n	8000f50 <__aeabi_fdiv+0x98>
 8000ee0:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000ee4:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 8000ee8:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 8000eec:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 8000ef0:	428b      	cmp	r3, r1
 8000ef2:	bf38      	it	cc
 8000ef4:	005b      	lslcc	r3, r3, #1
 8000ef6:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 8000efa:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 8000efe:	428b      	cmp	r3, r1
 8000f00:	bf24      	itt	cs
 8000f02:	1a5b      	subcs	r3, r3, r1
 8000f04:	ea40 000c 	orrcs.w	r0, r0, ip
 8000f08:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 8000f0c:	bf24      	itt	cs
 8000f0e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 8000f12:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000f16:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 8000f1a:	bf24      	itt	cs
 8000f1c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 8000f20:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000f24:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 8000f28:	bf24      	itt	cs
 8000f2a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 8000f2e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000f32:	011b      	lsls	r3, r3, #4
 8000f34:	bf18      	it	ne
 8000f36:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 8000f3a:	d1e0      	bne.n	8000efe <__aeabi_fdiv+0x46>
 8000f3c:	2afd      	cmp	r2, #253	; 0xfd
 8000f3e:	f63f af50 	bhi.w	8000de2 <__aeabi_fmul+0x92>
 8000f42:	428b      	cmp	r3, r1
 8000f44:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 8000f48:	bf08      	it	eq
 8000f4a:	f020 0001 	biceq.w	r0, r0, #1
 8000f4e:	4770      	bx	lr
 8000f50:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 8000f54:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 8000f58:	327f      	adds	r2, #127	; 0x7f
 8000f5a:	bfc2      	ittt	gt
 8000f5c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 8000f60:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 8000f64:	4770      	bxgt	lr
 8000f66:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000f6a:	f04f 0300 	mov.w	r3, #0
 8000f6e:	3a01      	subs	r2, #1
 8000f70:	e737      	b.n	8000de2 <__aeabi_fmul+0x92>
 8000f72:	f092 0f00 	teq	r2, #0
 8000f76:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 8000f7a:	bf02      	ittt	eq
 8000f7c:	0040      	lsleq	r0, r0, #1
 8000f7e:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 8000f82:	3a01      	subeq	r2, #1
 8000f84:	d0f9      	beq.n	8000f7a <__aeabi_fdiv+0xc2>
 8000f86:	ea40 000c 	orr.w	r0, r0, ip
 8000f8a:	f093 0f00 	teq	r3, #0
 8000f8e:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000f92:	bf02      	ittt	eq
 8000f94:	0049      	lsleq	r1, r1, #1
 8000f96:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 8000f9a:	3b01      	subeq	r3, #1
 8000f9c:	d0f9      	beq.n	8000f92 <__aeabi_fdiv+0xda>
 8000f9e:	ea41 010c 	orr.w	r1, r1, ip
 8000fa2:	e795      	b.n	8000ed0 <__aeabi_fdiv+0x18>
 8000fa4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 8000fa8:	ea92 0f0c 	teq	r2, ip
 8000fac:	d108      	bne.n	8000fc0 <__aeabi_fdiv+0x108>
 8000fae:	0242      	lsls	r2, r0, #9
 8000fb0:	f47f af7d 	bne.w	8000eae <__aeabi_fmul+0x15e>
 8000fb4:	ea93 0f0c 	teq	r3, ip
 8000fb8:	f47f af70 	bne.w	8000e9c <__aeabi_fmul+0x14c>
 8000fbc:	4608      	mov	r0, r1
 8000fbe:	e776      	b.n	8000eae <__aeabi_fmul+0x15e>
 8000fc0:	ea93 0f0c 	teq	r3, ip
 8000fc4:	d104      	bne.n	8000fd0 <__aeabi_fdiv+0x118>
 8000fc6:	024b      	lsls	r3, r1, #9
 8000fc8:	f43f af4c 	beq.w	8000e64 <__aeabi_fmul+0x114>
 8000fcc:	4608      	mov	r0, r1
 8000fce:	e76e      	b.n	8000eae <__aeabi_fmul+0x15e>
 8000fd0:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 8000fd4:	bf18      	it	ne
 8000fd6:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 8000fda:	d1ca      	bne.n	8000f72 <__aeabi_fdiv+0xba>
 8000fdc:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 8000fe0:	f47f af5c 	bne.w	8000e9c <__aeabi_fmul+0x14c>
 8000fe4:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 8000fe8:	f47f af3c 	bne.w	8000e64 <__aeabi_fmul+0x114>
 8000fec:	e75f      	b.n	8000eae <__aeabi_fmul+0x15e>
 8000fee:	bf00      	nop

08000ff0 <__gesf2>:
 8000ff0:	f04f 3cff 	mov.w	ip, #4294967295
 8000ff4:	e006      	b.n	8001004 <__cmpsf2+0x4>
 8000ff6:	bf00      	nop

08000ff8 <__lesf2>:
 8000ff8:	f04f 0c01 	mov.w	ip, #1
 8000ffc:	e002      	b.n	8001004 <__cmpsf2+0x4>
 8000ffe:	bf00      	nop

08001000 <__cmpsf2>:
 8001000:	f04f 0c01 	mov.w	ip, #1
 8001004:	f84d cd04 	str.w	ip, [sp, #-4]!
 8001008:	ea4f 0240 	mov.w	r2, r0, lsl #1
 800100c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8001010:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8001014:	bf18      	it	ne
 8001016:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 800101a:	d011      	beq.n	8001040 <__cmpsf2+0x40>
 800101c:	b001      	add	sp, #4
 800101e:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 8001022:	bf18      	it	ne
 8001024:	ea90 0f01 	teqne	r0, r1
 8001028:	bf58      	it	pl
 800102a:	ebb2 0003 	subspl.w	r0, r2, r3
 800102e:	bf88      	it	hi
 8001030:	17c8      	asrhi	r0, r1, #31
 8001032:	bf38      	it	cc
 8001034:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 8001038:	bf18      	it	ne
 800103a:	f040 0001 	orrne.w	r0, r0, #1
 800103e:	4770      	bx	lr
 8001040:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8001044:	d102      	bne.n	800104c <__cmpsf2+0x4c>
 8001046:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 800104a:	d105      	bne.n	8001058 <__cmpsf2+0x58>
 800104c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8001050:	d1e4      	bne.n	800101c <__cmpsf2+0x1c>
 8001052:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 8001056:	d0e1      	beq.n	800101c <__cmpsf2+0x1c>
 8001058:	f85d 0b04 	ldr.w	r0, [sp], #4
 800105c:	4770      	bx	lr
 800105e:	bf00      	nop

08001060 <__aeabi_cfrcmple>:
 8001060:	4684      	mov	ip, r0
 8001062:	4608      	mov	r0, r1
 8001064:	4661      	mov	r1, ip
 8001066:	e7ff      	b.n	8001068 <__aeabi_cfcmpeq>

08001068 <__aeabi_cfcmpeq>:
 8001068:	b50f      	push	{r0, r1, r2, r3, lr}
 800106a:	f7ff ffc9 	bl	8001000 <__cmpsf2>
 800106e:	2800      	cmp	r0, #0
 8001070:	bf48      	it	mi
 8001072:	f110 0f00 	cmnmi.w	r0, #0
 8001076:	bd0f      	pop	{r0, r1, r2, r3, pc}

08001078 <__aeabi_fcmpeq>:
 8001078:	f84d ed08 	str.w	lr, [sp, #-8]!
 800107c:	f7ff fff4 	bl	8001068 <__aeabi_cfcmpeq>
 8001080:	bf0c      	ite	eq
 8001082:	2001      	moveq	r0, #1
 8001084:	2000      	movne	r0, #0
 8001086:	f85d fb08 	ldr.w	pc, [sp], #8
 800108a:	bf00      	nop

0800108c <__aeabi_fcmplt>:
 800108c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8001090:	f7ff ffea 	bl	8001068 <__aeabi_cfcmpeq>
 8001094:	bf34      	ite	cc
 8001096:	2001      	movcc	r0, #1
 8001098:	2000      	movcs	r0, #0
 800109a:	f85d fb08 	ldr.w	pc, [sp], #8
 800109e:	bf00      	nop

080010a0 <__aeabi_fcmple>:
 80010a0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80010a4:	f7ff ffe0 	bl	8001068 <__aeabi_cfcmpeq>
 80010a8:	bf94      	ite	ls
 80010aa:	2001      	movls	r0, #1
 80010ac:	2000      	movhi	r0, #0
 80010ae:	f85d fb08 	ldr.w	pc, [sp], #8
 80010b2:	bf00      	nop

080010b4 <__aeabi_fcmpge>:
 80010b4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80010b8:	f7ff ffd2 	bl	8001060 <__aeabi_cfrcmple>
 80010bc:	bf94      	ite	ls
 80010be:	2001      	movls	r0, #1
 80010c0:	2000      	movhi	r0, #0
 80010c2:	f85d fb08 	ldr.w	pc, [sp], #8
 80010c6:	bf00      	nop

080010c8 <__aeabi_fcmpgt>:
 80010c8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80010cc:	f7ff ffc8 	bl	8001060 <__aeabi_cfrcmple>
 80010d0:	bf34      	ite	cc
 80010d2:	2001      	movcc	r0, #1
 80010d4:	2000      	movcs	r0, #0
 80010d6:	f85d fb08 	ldr.w	pc, [sp], #8
 80010da:	bf00      	nop
 80010dc:	0000      	movs	r0, r0
	...

080010e0 <__aeabi_f2iz>:
 80010e0:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80010e4:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80010e8:	d30f      	bcc.n	800110a <__aeabi_f2iz+0x2a>
 80010ea:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80010ee:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80010f2:	d90d      	bls.n	8001110 <__aeabi_f2iz+0x30>
 80010f4:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80010f8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80010fc:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8001100:	fa23 f002 	lsr.w	r0, r3, r2
 8001104:	bf18      	it	ne
 8001106:	4240      	negne	r0, r0
 8001108:	4770      	bx	lr
 800110a:	f04f 0000 	mov.w	r0, #0
 800110e:	4770      	bx	lr
 8001110:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8001114:	d101      	bne.n	800111a <__aeabi_f2iz+0x3a>
 8001116:	0242      	lsls	r2, r0, #9
 8001118:	d105      	bne.n	8001126 <__aeabi_f2iz+0x46>
 800111a:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 800111e:	bf08      	it	eq
 8001120:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8001124:	4770      	bx	lr
 8001126:	f04f 0000 	mov.w	r0, #0
 800112a:	4770      	bx	lr
 800112c:	0000      	movs	r0, r0
	...

08001130 <sduInterruptTransmitted>:
 *          interrupt endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduInterruptTransmitted(USBDriver *usbp, usbep_t ep) {
 8001130:	4770      	bx	lr
 8001132:	bf00      	nop
	...

08001140 <sduRequestsHook>:
 * @retval true         Message handled internally.
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
 8001140:	f890 3044 	ldrb.w	r3, [r0, #68]	; 0x44
 8001144:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8001148:	2b20      	cmp	r3, #32
 800114a:	d001      	beq.n	8001150 <sduRequestsHook+0x10>
      return true;
    default:
      return false;
    }
  }
  return false;
 800114c:	2000      	movs	r0, #0
}
 800114e:	4770      	bx	lr
 * @retval false        Message not handled.
 */
bool sduRequestsHook(USBDriver *usbp) {

  if ((usbp->setup[0] & USB_RTYPE_TYPE_MASK) == USB_RTYPE_TYPE_CLASS) {
    switch (usbp->setup[1]) {
 8001150:	f890 3045 	ldrb.w	r3, [r0, #69]	; 0x45
 8001154:	2b21      	cmp	r3, #33	; 0x21
 8001156:	d003      	beq.n	8001160 <sduRequestsHook+0x20>
 8001158:	2b22      	cmp	r3, #34	; 0x22
 800115a:	d009      	beq.n	8001170 <sduRequestsHook+0x30>
 800115c:	2b20      	cmp	r3, #32
 800115e:	d1f5      	bne.n	800114c <sduRequestsHook+0xc>
    case CDC_GET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
      return true;
    case CDC_SET_LINE_CODING:
      usbSetupTransfer(usbp, (uint8_t *)&linecoding, sizeof(linecoding), NULL);
 8001160:	4b06      	ldr	r3, [pc, #24]	; (800117c <sduRequestsHook+0x3c>)
 8001162:	6383      	str	r3, [r0, #56]	; 0x38
 8001164:	2207      	movs	r2, #7
 8001166:	2300      	movs	r3, #0
 8001168:	63c2      	str	r2, [r0, #60]	; 0x3c
 800116a:	6403      	str	r3, [r0, #64]	; 0x40
      return true;
 800116c:	2001      	movs	r0, #1
 800116e:	4770      	bx	lr
    case CDC_SET_CONTROL_LINE_STATE:
      /* Nothing to do, there are no control lines.*/
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8001170:	2300      	movs	r3, #0
 8001172:	6383      	str	r3, [r0, #56]	; 0x38
 8001174:	63c3      	str	r3, [r0, #60]	; 0x3c
 8001176:	6403      	str	r3, [r0, #64]	; 0x40
      return true;
 8001178:	2001      	movs	r0, #1
 800117a:	4770      	bx	lr
 800117c:	20000800 	.word	0x20000800

08001180 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001180:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8001184:	3320      	adds	r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001186:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800118a:	2300      	movs	r3, #0
 800118c:	f383 8811 	msr	BASEPRI, r3
 8001190:	4770      	bx	lr
 8001192:	bf00      	nop
	...

080011a0 <chCoreAlloc>:
 80011a0:	2320      	movs	r3, #32
 80011a2:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 80011a6:	4a09      	ldr	r2, [pc, #36]	; (80011cc <chCoreAlloc+0x2c>)
 80011a8:	4909      	ldr	r1, [pc, #36]	; (80011d0 <chCoreAlloc+0x30>)
 80011aa:	6813      	ldr	r3, [r2, #0]
 80011ac:	6809      	ldr	r1, [r1, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 80011ae:	3007      	adds	r0, #7
 80011b0:	f020 0007 	bic.w	r0, r0, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 80011b4:	1ac9      	subs	r1, r1, r3
 80011b6:	4288      	cmp	r0, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 80011b8:	bf9b      	ittet	ls
 80011ba:	18c0      	addls	r0, r0, r3
 80011bc:	6010      	strls	r0, [r2, #0]

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 80011be:	2000      	movhi	r0, #0
  }
  p = nextmem;
  nextmem += size;

  return p;
 80011c0:	4618      	movls	r0, r3
 80011c2:	2300      	movs	r3, #0
 80011c4:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 80011c8:	4770      	bx	lr
 80011ca:	bf00      	nop
 80011cc:	20001d78 	.word	0x20001d78
 80011d0:	20001f68 	.word	0x20001f68
	...

080011e0 <wakeup.4662>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80011e0:	b410      	push	{r4}
 80011e2:	2320      	movs	r3, #32
 80011e4:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 80011e8:	7f03      	ldrb	r3, [r0, #28]
 80011ea:	2b07      	cmp	r3, #7
 80011ec:	d80e      	bhi.n	800120c <wakeup.4662+0x2c>
 80011ee:	e8df f003 	tbb	[pc, r3]
 80011f2:	0d27      	.short	0x0d27
 80011f4:	0408230d 	.word	0x0408230d
 80011f8:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 80011fa:	6a03      	ldr	r3, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 80011fc:	689a      	ldr	r2, [r3, #8]
 80011fe:	3201      	adds	r2, #1
 8001200:	609a      	str	r2, [r3, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001202:	e890 000c 	ldmia.w	r0, {r2, r3}
 8001206:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001208:	6802      	ldr	r2, [r0, #0]
 800120a:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800120c:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001210:	2200      	movs	r2, #0
 8001212:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001214:	4b0d      	ldr	r3, [pc, #52]	; (800124c <wakeup.4662+0x6c>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8001216:	6204      	str	r4, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001218:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800121a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800121c:	689a      	ldr	r2, [r3, #8]
 800121e:	428a      	cmp	r2, r1
 8001220:	d2fb      	bcs.n	800121a <wakeup.4662+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001222:	685a      	ldr	r2, [r3, #4]
 8001224:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001226:	6003      	str	r3, [r0, #0]
 8001228:	2100      	movs	r1, #0
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 800122a:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 800122c:	6058      	str	r0, [r3, #4]
 800122e:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001232:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001236:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8001238:	6a03      	ldr	r3, [r0, #32]
 800123a:	2200      	movs	r2, #0
 800123c:	601a      	str	r2, [r3, #0]
 800123e:	e7e5      	b.n	800120c <wakeup.4662+0x2c>
 8001240:	2300      	movs	r3, #0
 8001242:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8001246:	f85d 4b04 	ldr.w	r4, [sp], #4
 800124a:	4770      	bx	lr
 800124c:	200016a8 	.word	0x200016a8

08001250 <_idle_thread.4273>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8001250:	e7fe      	b.n	8001250 <_idle_thread.4273>
 8001252:	bf00      	nop
	...

08001260 <_pal_lld_setgroupmode>:
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001260:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8001264:	2300      	movs	r3, #0
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001266:	f002 0703 	and.w	r7, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 800126a:	f3c2 0680 	ubfx	r6, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800126e:	f3c2 05c1 	ubfx	r5, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
 8001272:	f3c2 1441 	ubfx	r4, r2, #5, #2
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
 8001276:	f04f 090f 	mov.w	r9, #15

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800127a:	f3c2 12c3 	ubfx	r2, r2, #7, #4
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 800127e:	f04f 0a01 	mov.w	sl, #1
 8001282:	e038      	b.n	80012f6 <_pal_lld_setgroupmode+0x96>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001284:	f8d0 b020 	ldr.w	fp, [r0, #32]
 8001288:	ea2b 0c0c 	bic.w	ip, fp, ip
 800128c:	ea4c 0808 	orr.w	r8, ip, r8
 8001290:	f8c0 8020 	str.w	r8, [r0, #32]
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001294:	f8d0 c004 	ldr.w	ip, [r0, #4]
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 8001298:	fa0a f803 	lsl.w	r8, sl, r3
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800129c:	ea2c 0c08 	bic.w	ip, ip, r8
 80012a0:	ea4c 0c06 	orr.w	ip, ip, r6
 80012a4:	f8c0 c004 	str.w	ip, [r0, #4]
      m2 = 3 << (bit * 2);
 80012a8:	f04f 0b03 	mov.w	fp, #3
 80012ac:	ea4f 0c43 	mov.w	ip, r3, lsl #1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80012b0:	f8d0 8008 	ldr.w	r8, [r0, #8]
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 80012b4:	fa0b fc0c 	lsl.w	ip, fp, ip
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80012b8:	ea6f 0c0c 	mvn.w	ip, ip
 80012bc:	ea0c 0808 	and.w	r8, ip, r8
 80012c0:	ea48 0805 	orr.w	r8, r8, r5
 80012c4:	f8c0 8008 	str.w	r8, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 80012c8:	f8d0 800c 	ldr.w	r8, [r0, #12]
 80012cc:	ea0c 0808 	and.w	r8, ip, r8
 80012d0:	ea48 0804 	orr.w	r8, r8, r4
 80012d4:	f8c0 800c 	str.w	r8, [r0, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 80012d8:	f8d0 8000 	ldr.w	r8, [r0]
 80012dc:	ea0c 0c08 	and.w	ip, ip, r8
 80012e0:	ea4c 0c07 	orr.w	ip, ip, r7
 80012e4:	f8c0 c000 	str.w	ip, [r0]
    }
    mask >>= 1;
    if (!mask)
 80012e8:	0849      	lsrs	r1, r1, #1
 80012ea:	d01a      	beq.n	8001322 <_pal_lld_setgroupmode+0xc2>
      return;
    otyper <<= 1;
 80012ec:	0076      	lsls	r6, r6, #1
    ospeedr <<= 2;
 80012ee:	00ad      	lsls	r5, r5, #2
    pupdr <<= 2;
 80012f0:	00a4      	lsls	r4, r4, #2
    moder <<= 2;
 80012f2:	00bf      	lsls	r7, r7, #2
    bit++;
 80012f4:	3301      	adds	r3, #1
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80012f6:	f003 0c07 	and.w	ip, r3, #7
 80012fa:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 80012fe:	f011 0f01 	tst.w	r1, #1
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001302:	fa02 f80c 	lsl.w	r8, r2, ip
      m4 = 15 << ((bit & 7) * 4);
 8001306:	fa09 fc0c 	lsl.w	ip, r9, ip
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 800130a:	d0ed      	beq.n	80012e8 <_pal_lld_setgroupmode+0x88>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
 800130c:	2b07      	cmp	r3, #7
 800130e:	d9b9      	bls.n	8001284 <_pal_lld_setgroupmode+0x24>
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001310:	f8d0 b024 	ldr.w	fp, [r0, #36]	; 0x24
 8001314:	ea2b 0c0c 	bic.w	ip, fp, ip
 8001318:	ea4c 0808 	orr.w	r8, ip, r8
 800131c:	f8c0 8024 	str.w	r8, [r0, #36]	; 0x24
 8001320:	e7b8      	b.n	8001294 <_pal_lld_setgroupmode+0x34>
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
    bit++;
  }
}
 8001322:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8001326:	4770      	bx	lr
	...

08001330 <_port_irq_epilogue>:
 8001330:	2320      	movs	r3, #32
 8001332:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8001336:	4b0f      	ldr	r3, [pc, #60]	; (8001374 <_port_irq_epilogue+0x44>)
 8001338:	685b      	ldr	r3, [r3, #4]
 800133a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800133e:	d102      	bne.n	8001346 <_port_irq_epilogue+0x16>
 8001340:	f383 8811 	msr	BASEPRI, r3
 8001344:	4770      	bx	lr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8001346:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800134a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800134e:	f843 2c04 	str.w	r2, [r3, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8001352:	f1a3 0220 	sub.w	r2, r3, #32

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8001356:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 800135a:	4a07      	ldr	r2, [pc, #28]	; (8001378 <_port_irq_epilogue+0x48>)
 800135c:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 800135e:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8001360:	6889      	ldr	r1, [r1, #8]
 8001362:	6892      	ldr	r2, [r2, #8]
 8001364:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8001366:	bf8c      	ite	hi
 8001368:	4a04      	ldrhi	r2, [pc, #16]	; (800137c <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800136a:	4a05      	ldrls	r2, [pc, #20]	; (8001380 <_port_irq_epilogue+0x50>)
 800136c:	f843 2c08 	str.w	r2, [r3, #-8]
 8001370:	4770      	bx	lr
 8001372:	bf00      	nop
 8001374:	e000ed00 	.word	0xe000ed00
 8001378:	200016a8 	.word	0x200016a8
 800137c:	080002a1 	.word	0x080002a1
 8001380:	080002a4 	.word	0x080002a4
	...

08001390 <Vector4C>:
/**
 * @brief   EXTI[22] interrupt handler (RTC_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector4C) {
 8001390:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
  EXTD1.config->channels[22].cb(&EXTD1, 22);
 8001392:	4807      	ldr	r0, [pc, #28]	; (80013b0 <Vector4C+0x20>)
 */
OSAL_IRQ_HANDLER(Vector4C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
 8001394:	4a07      	ldr	r2, [pc, #28]	; (80013b4 <Vector4C+0x24>)
  EXTD1.config->channels[22].cb(&EXTD1, 22);
 8001396:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector4C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
 8001398:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  EXTD1.config->channels[22].cb(&EXTD1, 22);
 800139c:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 */
OSAL_IRQ_HANDLER(Vector4C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
 80013a0:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[22].cb(&EXTD1, 22);
 80013a2:	2116      	movs	r1, #22
 80013a4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80013a6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 22);
  EXTD1.config->channels[22].cb(&EXTD1, 22);

  OSAL_IRQ_EPILOGUE();
 80013aa:	f7ff bfc1 	b.w	8001330 <_port_irq_epilogue>
 80013ae:	bf00      	nop
 80013b0:	2000169c 	.word	0x2000169c
 80013b4:	40013c00 	.word	0x40013c00
	...

080013c0 <Vector48>:
/**
 * @brief   EXTI[21] interrupt handler (TAMPER_STAMP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector48) {
 80013c0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
  EXTD1.config->channels[21].cb(&EXTD1, 21);
 80013c2:	4807      	ldr	r0, [pc, #28]	; (80013e0 <Vector48+0x20>)
 */
OSAL_IRQ_HANDLER(Vector48) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
 80013c4:	4a07      	ldr	r2, [pc, #28]	; (80013e4 <Vector48+0x24>)
  EXTD1.config->channels[21].cb(&EXTD1, 21);
 80013c6:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector48) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
 80013c8:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
  EXTD1.config->channels[21].cb(&EXTD1, 21);
 80013cc:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 */
OSAL_IRQ_HANDLER(Vector48) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
 80013d0:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[21].cb(&EXTD1, 21);
 80013d2:	2115      	movs	r1, #21
 80013d4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80013d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 21);
  EXTD1.config->channels[21].cb(&EXTD1, 21);

  OSAL_IRQ_EPILOGUE();
 80013da:	f7ff bfa9 	b.w	8001330 <_port_irq_epilogue>
 80013de:	bf00      	nop
 80013e0:	2000169c 	.word	0x2000169c
 80013e4:	40013c00 	.word	0x40013c00
	...

080013f0 <Vector170>:
/**
 * @brief   EXTI[20] interrupt handler (OTG_HS_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector170) {
 80013f0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 80013f2:	4807      	ldr	r0, [pc, #28]	; (8001410 <Vector170+0x20>)
 */
OSAL_IRQ_HANDLER(Vector170) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
 80013f4:	4a07      	ldr	r2, [pc, #28]	; (8001414 <Vector170+0x24>)
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 80013f6:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector170) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
 80013f8:	f44f 1180 	mov.w	r1, #1048576	; 0x100000
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 80013fc:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 */
OSAL_IRQ_HANDLER(Vector170) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
 8001400:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 8001402:	2114      	movs	r1, #20
 8001404:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001406:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
  EXTD1.config->channels[20].cb(&EXTD1, 20);

  OSAL_IRQ_EPILOGUE();
 800140a:	f7ff bf91 	b.w	8001330 <_port_irq_epilogue>
 800140e:	bf00      	nop
 8001410:	2000169c 	.word	0x2000169c
 8001414:	40013c00 	.word	0x40013c00
	...

08001420 <Vector138>:
/**
 * @brief   EXTI[19] interrupt handler (ETH_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector138) {
 8001420:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 8001422:	4807      	ldr	r0, [pc, #28]	; (8001440 <Vector138+0x20>)
 */
OSAL_IRQ_HANDLER(Vector138) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
 8001424:	4a07      	ldr	r2, [pc, #28]	; (8001444 <Vector138+0x24>)
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 8001426:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector138) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
 8001428:	f44f 2100 	mov.w	r1, #524288	; 0x80000
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 800142c:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 */
OSAL_IRQ_HANDLER(Vector138) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
 8001430:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 8001432:	2113      	movs	r1, #19
 8001434:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001436:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
  EXTD1.config->channels[19].cb(&EXTD1, 19);

  OSAL_IRQ_EPILOGUE();
 800143a:	f7ff bf79 	b.w	8001330 <_port_irq_epilogue>
 800143e:	bf00      	nop
 8001440:	2000169c 	.word	0x2000169c
 8001444:	40013c00 	.word	0x40013c00
	...

08001450 <VectorE8>:
/**
 * @brief   EXTI[18] interrupt handler (OTG_FS_WKUP).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE8) {
 8001450:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 8001452:	4807      	ldr	r0, [pc, #28]	; (8001470 <VectorE8+0x20>)
 */
OSAL_IRQ_HANDLER(VectorE8) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
 8001454:	4a07      	ldr	r2, [pc, #28]	; (8001474 <VectorE8+0x24>)
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 8001456:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(VectorE8) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
 8001458:	f44f 2180 	mov.w	r1, #262144	; 0x40000
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 800145c:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 */
OSAL_IRQ_HANDLER(VectorE8) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
 8001460:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 8001462:	2112      	movs	r1, #18
 8001464:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001466:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
  EXTD1.config->channels[18].cb(&EXTD1, 18);

  OSAL_IRQ_EPILOGUE();
 800146a:	f7ff bf61 	b.w	8001330 <_port_irq_epilogue>
 800146e:	bf00      	nop
 8001470:	2000169c 	.word	0x2000169c
 8001474:	40013c00 	.word	0x40013c00
	...

08001480 <VectorE4>:
/**
 * @brief   EXTI[17] interrupt handler (RTC_ALARM).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE4) {
 8001480:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 8001482:	4807      	ldr	r0, [pc, #28]	; (80014a0 <VectorE4+0x20>)
 */
OSAL_IRQ_HANDLER(VectorE4) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
 8001484:	4a07      	ldr	r2, [pc, #28]	; (80014a4 <VectorE4+0x24>)
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 8001486:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(VectorE4) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
 8001488:	f44f 3100 	mov.w	r1, #131072	; 0x20000
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 800148c:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 */
OSAL_IRQ_HANDLER(VectorE4) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
 8001490:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 8001492:	2111      	movs	r1, #17
 8001494:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001496:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
  EXTD1.config->channels[17].cb(&EXTD1, 17);

  OSAL_IRQ_EPILOGUE();
 800149a:	f7ff bf49 	b.w	8001330 <_port_irq_epilogue>
 800149e:	bf00      	nop
 80014a0:	2000169c 	.word	0x2000169c
 80014a4:	40013c00 	.word	0x40013c00
	...

080014b0 <Vector44>:
/**
 * @brief   EXTI[16] interrupt handler (PVD).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector44) {
 80014b0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 80014b2:	4807      	ldr	r0, [pc, #28]	; (80014d0 <Vector44+0x20>)
 */
OSAL_IRQ_HANDLER(Vector44) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
 80014b4:	4a07      	ldr	r2, [pc, #28]	; (80014d4 <Vector44+0x24>)
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 80014b6:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector44) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
 80014b8:	f44f 3180 	mov.w	r1, #65536	; 0x10000
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 80014bc:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 */
OSAL_IRQ_HANDLER(Vector44) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
 80014c0:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 80014c2:	2110      	movs	r1, #16
 80014c4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80014c6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
  EXTD1.config->channels[16].cb(&EXTD1, 16);

  OSAL_IRQ_EPILOGUE();
 80014ca:	f7ff bf31 	b.w	8001330 <_port_irq_epilogue>
 80014ce:	bf00      	nop
 80014d0:	2000169c 	.word	0x2000169c
 80014d4:	40013c00 	.word	0x40013c00
	...

080014e0 <VectorE0>:
OSAL_IRQ_HANDLER(VectorE0) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) | (1 << 14) |
 80014e0:	4b1c      	ldr	r3, [pc, #112]	; (8001554 <VectorE0+0x74>)
/**
 * @brief   EXTI[10]...EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE0) {
 80014e2:	b510      	push	{r4, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) | (1 << 14) |
 80014e4:	695c      	ldr	r4, [r3, #20]
 80014e6:	f404 427c 	and.w	r2, r4, #64512	; 0xfc00
                   (1 << 15));
  EXTI->PR = pr;
 80014ea:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 10))
 80014ec:	0562      	lsls	r2, r4, #21
 80014ee:	d42a      	bmi.n	8001546 <VectorE0+0x66>
    EXTD1.config->channels[10].cb(&EXTD1, 10);
  if (pr & (1 << 11))
 80014f0:	0523      	lsls	r3, r4, #20
 80014f2:	d422      	bmi.n	800153a <VectorE0+0x5a>
    EXTD1.config->channels[11].cb(&EXTD1, 11);
  if (pr & (1 << 12))
 80014f4:	04e0      	lsls	r0, r4, #19
 80014f6:	d41a      	bmi.n	800152e <VectorE0+0x4e>
    EXTD1.config->channels[12].cb(&EXTD1, 12);
  if (pr & (1 << 13))
 80014f8:	04a1      	lsls	r1, r4, #18
 80014fa:	d412      	bmi.n	8001522 <VectorE0+0x42>
    EXTD1.config->channels[13].cb(&EXTD1, 13);
  if (pr & (1 << 14))
 80014fc:	0462      	lsls	r2, r4, #17
 80014fe:	d40a      	bmi.n	8001516 <VectorE0+0x36>
    EXTD1.config->channels[14].cb(&EXTD1, 14);
  if (pr & (1 << 15))
 8001500:	0423      	lsls	r3, r4, #16
 8001502:	d504      	bpl.n	800150e <VectorE0+0x2e>
    EXTD1.config->channels[15].cb(&EXTD1, 15);
 8001504:	4814      	ldr	r0, [pc, #80]	; (8001558 <VectorE0+0x78>)
 8001506:	6843      	ldr	r3, [r0, #4]
 8001508:	210f      	movs	r1, #15
 800150a:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800150c:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800150e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (pr & (1 << 14))
    EXTD1.config->channels[14].cb(&EXTD1, 14);
  if (pr & (1 << 15))
    EXTD1.config->channels[15].cb(&EXTD1, 15);

  OSAL_IRQ_EPILOGUE();
 8001512:	f7ff bf0d 	b.w	8001330 <_port_irq_epilogue>
  if (pr & (1 << 12))
    EXTD1.config->channels[12].cb(&EXTD1, 12);
  if (pr & (1 << 13))
    EXTD1.config->channels[13].cb(&EXTD1, 13);
  if (pr & (1 << 14))
    EXTD1.config->channels[14].cb(&EXTD1, 14);
 8001516:	4810      	ldr	r0, [pc, #64]	; (8001558 <VectorE0+0x78>)
 8001518:	6843      	ldr	r3, [r0, #4]
 800151a:	210e      	movs	r1, #14
 800151c:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800151e:	4798      	blx	r3
 8001520:	e7ee      	b.n	8001500 <VectorE0+0x20>
  if (pr & (1 << 11))
    EXTD1.config->channels[11].cb(&EXTD1, 11);
  if (pr & (1 << 12))
    EXTD1.config->channels[12].cb(&EXTD1, 12);
  if (pr & (1 << 13))
    EXTD1.config->channels[13].cb(&EXTD1, 13);
 8001522:	480d      	ldr	r0, [pc, #52]	; (8001558 <VectorE0+0x78>)
 8001524:	6843      	ldr	r3, [r0, #4]
 8001526:	210d      	movs	r1, #13
 8001528:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800152a:	4798      	blx	r3
 800152c:	e7e6      	b.n	80014fc <VectorE0+0x1c>
  if (pr & (1 << 10))
    EXTD1.config->channels[10].cb(&EXTD1, 10);
  if (pr & (1 << 11))
    EXTD1.config->channels[11].cb(&EXTD1, 11);
  if (pr & (1 << 12))
    EXTD1.config->channels[12].cb(&EXTD1, 12);
 800152e:	480a      	ldr	r0, [pc, #40]	; (8001558 <VectorE0+0x78>)
 8001530:	6843      	ldr	r3, [r0, #4]
 8001532:	210c      	movs	r1, #12
 8001534:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001536:	4798      	blx	r3
 8001538:	e7de      	b.n	80014f8 <VectorE0+0x18>
                   (1 << 15));
  EXTI->PR = pr;
  if (pr & (1 << 10))
    EXTD1.config->channels[10].cb(&EXTD1, 10);
  if (pr & (1 << 11))
    EXTD1.config->channels[11].cb(&EXTD1, 11);
 800153a:	4807      	ldr	r0, [pc, #28]	; (8001558 <VectorE0+0x78>)
 800153c:	6843      	ldr	r3, [r0, #4]
 800153e:	210b      	movs	r1, #11
 8001540:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001542:	4798      	blx	r3
 8001544:	e7d6      	b.n	80014f4 <VectorE0+0x14>

  pr = EXTI->PR & ((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) | (1 << 14) |
                   (1 << 15));
  EXTI->PR = pr;
  if (pr & (1 << 10))
    EXTD1.config->channels[10].cb(&EXTD1, 10);
 8001546:	4804      	ldr	r0, [pc, #16]	; (8001558 <VectorE0+0x78>)
 8001548:	6843      	ldr	r3, [r0, #4]
 800154a:	210a      	movs	r1, #10
 800154c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800154e:	4798      	blx	r3
 8001550:	e7ce      	b.n	80014f0 <VectorE0+0x10>
 8001552:	bf00      	nop
 8001554:	40013c00 	.word	0x40013c00
 8001558:	2000169c 	.word	0x2000169c
 800155c:	00000000 	.word	0x00000000

08001560 <Vector9C>:
OSAL_IRQ_HANDLER(Vector9C) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
 8001560:	4b18      	ldr	r3, [pc, #96]	; (80015c4 <Vector9C+0x64>)
/**
 * @brief   EXTI[5]...EXTI[9] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector9C) {
 8001562:	b510      	push	{r4, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
 8001564:	695c      	ldr	r4, [r3, #20]
 8001566:	f404 7278 	and.w	r2, r4, #992	; 0x3e0
  EXTI->PR = pr;
 800156a:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 5))
 800156c:	06a3      	lsls	r3, r4, #26
 800156e:	d422      	bmi.n	80015b6 <Vector9C+0x56>
    EXTD1.config->channels[5].cb(&EXTD1, 5);
  if (pr & (1 << 6))
 8001570:	0660      	lsls	r0, r4, #25
 8001572:	d41a      	bmi.n	80015aa <Vector9C+0x4a>
    EXTD1.config->channels[6].cb(&EXTD1, 6);
  if (pr & (1 << 7))
 8001574:	0621      	lsls	r1, r4, #24
 8001576:	d412      	bmi.n	800159e <Vector9C+0x3e>
    EXTD1.config->channels[7].cb(&EXTD1, 7);
  if (pr & (1 << 8))
 8001578:	05e2      	lsls	r2, r4, #23
 800157a:	d40a      	bmi.n	8001592 <Vector9C+0x32>
    EXTD1.config->channels[8].cb(&EXTD1, 8);
  if (pr & (1 << 9))
 800157c:	05a3      	lsls	r3, r4, #22
 800157e:	d504      	bpl.n	800158a <Vector9C+0x2a>
    EXTD1.config->channels[9].cb(&EXTD1, 9);
 8001580:	4811      	ldr	r0, [pc, #68]	; (80015c8 <Vector9C+0x68>)
 8001582:	6843      	ldr	r3, [r0, #4]
 8001584:	2109      	movs	r1, #9
 8001586:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001588:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800158a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (pr & (1 << 8))
    EXTD1.config->channels[8].cb(&EXTD1, 8);
  if (pr & (1 << 9))
    EXTD1.config->channels[9].cb(&EXTD1, 9);

  OSAL_IRQ_EPILOGUE();
 800158e:	f7ff becf 	b.w	8001330 <_port_irq_epilogue>
  if (pr & (1 << 6))
    EXTD1.config->channels[6].cb(&EXTD1, 6);
  if (pr & (1 << 7))
    EXTD1.config->channels[7].cb(&EXTD1, 7);
  if (pr & (1 << 8))
    EXTD1.config->channels[8].cb(&EXTD1, 8);
 8001592:	480d      	ldr	r0, [pc, #52]	; (80015c8 <Vector9C+0x68>)
 8001594:	6843      	ldr	r3, [r0, #4]
 8001596:	2108      	movs	r1, #8
 8001598:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800159a:	4798      	blx	r3
 800159c:	e7ee      	b.n	800157c <Vector9C+0x1c>
  if (pr & (1 << 5))
    EXTD1.config->channels[5].cb(&EXTD1, 5);
  if (pr & (1 << 6))
    EXTD1.config->channels[6].cb(&EXTD1, 6);
  if (pr & (1 << 7))
    EXTD1.config->channels[7].cb(&EXTD1, 7);
 800159e:	480a      	ldr	r0, [pc, #40]	; (80015c8 <Vector9C+0x68>)
 80015a0:	6843      	ldr	r3, [r0, #4]
 80015a2:	2107      	movs	r1, #7
 80015a4:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80015a6:	4798      	blx	r3
 80015a8:	e7e6      	b.n	8001578 <Vector9C+0x18>
  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
  EXTI->PR = pr;
  if (pr & (1 << 5))
    EXTD1.config->channels[5].cb(&EXTD1, 5);
  if (pr & (1 << 6))
    EXTD1.config->channels[6].cb(&EXTD1, 6);
 80015aa:	4807      	ldr	r0, [pc, #28]	; (80015c8 <Vector9C+0x68>)
 80015ac:	6843      	ldr	r3, [r0, #4]
 80015ae:	2106      	movs	r1, #6
 80015b0:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80015b2:	4798      	blx	r3
 80015b4:	e7de      	b.n	8001574 <Vector9C+0x14>
  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
  EXTI->PR = pr;
  if (pr & (1 << 5))
    EXTD1.config->channels[5].cb(&EXTD1, 5);
 80015b6:	4804      	ldr	r0, [pc, #16]	; (80015c8 <Vector9C+0x68>)
 80015b8:	6843      	ldr	r3, [r0, #4]
 80015ba:	2105      	movs	r1, #5
 80015bc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80015be:	4798      	blx	r3
 80015c0:	e7d6      	b.n	8001570 <Vector9C+0x10>
 80015c2:	bf00      	nop
 80015c4:	40013c00 	.word	0x40013c00
 80015c8:	2000169c 	.word	0x2000169c
 80015cc:	00000000 	.word	0x00000000

080015d0 <Vector68>:
/**
 * @brief   EXTI[4] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector68) {
 80015d0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 80015d2:	4806      	ldr	r0, [pc, #24]	; (80015ec <Vector68+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector68) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
 80015d4:	4a06      	ldr	r2, [pc, #24]	; (80015f0 <Vector68+0x20>)
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 80015d6:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector68) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
 80015d8:	2110      	movs	r1, #16
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 80015da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 */
OSAL_IRQ_HANDLER(Vector68) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
 80015dc:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 80015de:	2104      	movs	r1, #4
 80015e0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80015e2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
  EXTD1.config->channels[4].cb(&EXTD1, 4);

  OSAL_IRQ_EPILOGUE();
 80015e6:	f7ff bea3 	b.w	8001330 <_port_irq_epilogue>
 80015ea:	bf00      	nop
 80015ec:	2000169c 	.word	0x2000169c
 80015f0:	40013c00 	.word	0x40013c00
	...

08001600 <Vector64>:
/**
 * @brief   EXTI[3] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector64) {
 8001600:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 8001602:	4806      	ldr	r0, [pc, #24]	; (800161c <Vector64+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector64) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
 8001604:	4a06      	ldr	r2, [pc, #24]	; (8001620 <Vector64+0x20>)
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 8001606:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector64) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
 8001608:	2108      	movs	r1, #8
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 800160a:	69db      	ldr	r3, [r3, #28]
 */
OSAL_IRQ_HANDLER(Vector64) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
 800160c:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 800160e:	2103      	movs	r1, #3
 8001610:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001612:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
  EXTD1.config->channels[3].cb(&EXTD1, 3);

  OSAL_IRQ_EPILOGUE();
 8001616:	f7ff be8b 	b.w	8001330 <_port_irq_epilogue>
 800161a:	bf00      	nop
 800161c:	2000169c 	.word	0x2000169c
 8001620:	40013c00 	.word	0x40013c00
	...

08001630 <Vector60>:
/**
 * @brief   EXTI[2] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector60) {
 8001630:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 8001632:	4806      	ldr	r0, [pc, #24]	; (800164c <Vector60+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector60) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
 8001634:	4a06      	ldr	r2, [pc, #24]	; (8001650 <Vector60+0x20>)
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 8001636:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector60) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
 8001638:	2104      	movs	r1, #4
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 800163a:	695b      	ldr	r3, [r3, #20]
 */
OSAL_IRQ_HANDLER(Vector60) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
 800163c:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 800163e:	2102      	movs	r1, #2
 8001640:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001642:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
  EXTD1.config->channels[2].cb(&EXTD1, 2);

  OSAL_IRQ_EPILOGUE();
 8001646:	f7ff be73 	b.w	8001330 <_port_irq_epilogue>
 800164a:	bf00      	nop
 800164c:	2000169c 	.word	0x2000169c
 8001650:	40013c00 	.word	0x40013c00
	...

08001660 <Vector5C>:
/**
 * @brief   EXTI[1] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector5C) {
 8001660:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 8001662:	4806      	ldr	r0, [pc, #24]	; (800167c <Vector5C+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector5C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
 8001664:	4a06      	ldr	r2, [pc, #24]	; (8001680 <Vector5C+0x20>)
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 8001666:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector5C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
 8001668:	2102      	movs	r1, #2
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 800166a:	68db      	ldr	r3, [r3, #12]
 */
OSAL_IRQ_HANDLER(Vector5C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
 800166c:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 800166e:	2101      	movs	r1, #1
 8001670:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001672:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
  EXTD1.config->channels[1].cb(&EXTD1, 1);

  OSAL_IRQ_EPILOGUE();
 8001676:	f7ff be5b 	b.w	8001330 <_port_irq_epilogue>
 800167a:	bf00      	nop
 800167c:	2000169c 	.word	0x2000169c
 8001680:	40013c00 	.word	0x40013c00
	...

08001690 <Vector58>:
/**
 * @brief   EXTI[0] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector58) {
 8001690:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 8001692:	4806      	ldr	r0, [pc, #24]	; (80016ac <Vector58+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector58) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
 8001694:	4a06      	ldr	r2, [pc, #24]	; (80016b0 <Vector58+0x20>)
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 8001696:	6843      	ldr	r3, [r0, #4]
 */
OSAL_IRQ_HANDLER(Vector58) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
 8001698:	2101      	movs	r1, #1
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 800169a:	685b      	ldr	r3, [r3, #4]
 */
OSAL_IRQ_HANDLER(Vector58) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
 800169c:	6151      	str	r1, [r2, #20]
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 800169e:	2100      	movs	r1, #0
 80016a0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80016a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
  EXTD1.config->channels[0].cb(&EXTD1, 0);

  OSAL_IRQ_EPILOGUE();
 80016a6:	f7ff be43 	b.w	8001330 <_port_irq_epilogue>
 80016aa:	bf00      	nop
 80016ac:	2000169c 	.word	0x2000169c
 80016b0:	40013c00 	.word	0x40013c00
	...

080016c0 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80016c0:	4a0e      	ldr	r2, [pc, #56]	; (80016fc <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80016c2:	4b0f      	ldr	r3, [pc, #60]	; (8001700 <chTMStopMeasurementX+0x40>)
 80016c4:	6851      	ldr	r1, [r2, #4]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80016c6:	b4f0      	push	{r4, r5, r6, r7}
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 80016c8:	6886      	ldr	r6, [r0, #8]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80016ca:	6f5f      	ldr	r7, [r3, #116]	; 0x74

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80016cc:	68c5      	ldr	r5, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 80016ce:	6844      	ldr	r4, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 80016d0:	e9d0 2304 	ldrd	r2, r3, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 80016d4:	1b89      	subs	r1, r1, r6
 80016d6:	1bc9      	subs	r1, r1, r7
  tmp->cumulative += (rttime_t)tmp->last;
 80016d8:	1852      	adds	r2, r2, r1
 80016da:	f143 0300 	adc.w	r3, r3, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80016de:	3501      	adds	r5, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 80016e0:	42a1      	cmp	r1, r4

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80016e2:	60c5      	str	r5, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 80016e4:	6081      	str	r1, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80016e6:	e9c0 2304 	strd	r2, r3, [r0, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 80016ea:	d805      	bhi.n	80016f8 <chTMStopMeasurementX+0x38>
    tmp->worst = tmp->last;
  }
  else if (tmp->last < tmp->best) {
 80016ec:	6803      	ldr	r3, [r0, #0]
 80016ee:	4299      	cmp	r1, r3
    tmp->best = tmp->last;
 80016f0:	bf38      	it	cc
 80016f2:	6001      	strcc	r1, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 80016f4:	bcf0      	pop	{r4, r5, r6, r7}
 80016f6:	4770      	bx	lr
  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 80016f8:	6041      	str	r1, [r0, #4]
 80016fa:	e7fb      	b.n	80016f4 <chTMStopMeasurementX+0x34>
 80016fc:	e0001000 	.word	0xe0001000
 8001700:	200016a8 	.word	0x200016a8
	...

08001710 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8001710:	4a0d      	ldr	r2, [pc, #52]	; (8001748 <chSchDoRescheduleAhead+0x38>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001712:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8001714:	b470      	push	{r4, r5, r6}

  tqp->p_next = tp->p_next;
 8001716:	6803      	ldr	r3, [r0, #0]
  thread_t *otp, *cp;

  otp = currp;
 8001718:	6995      	ldr	r5, [r2, #24]
 800171a:	6013      	str	r3, [r2, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800171c:	2601      	movs	r6, #1

  otp->p_state = CH_STATE_READY;
 800171e:	2100      	movs	r1, #0
 8001720:	68ac      	ldr	r4, [r5, #8]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001722:	605a      	str	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001724:	7706      	strb	r6, [r0, #28]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001726:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8001728:	7729      	strb	r1, [r5, #28]
 800172a:	e000      	b.n	800172e <chSchDoRescheduleAhead+0x1e>
 800172c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 800172e:	689a      	ldr	r2, [r3, #8]
 8001730:	42a2      	cmp	r2, r4
 8001732:	d8fb      	bhi.n	800172c <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8001734:	685a      	ldr	r2, [r3, #4]
 8001736:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8001738:	602b      	str	r3, [r5, #0]
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 800173a:	4629      	mov	r1, r5
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
 800173c:	6015      	str	r5, [r2, #0]
  cp->p_prev = otp;
 800173e:	605d      	str	r5, [r3, #4]

  chSysSwitch(currp, otp);
}
 8001740:	bc70      	pop	{r4, r5, r6}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8001742:	f7fe bd9d 	b.w	8000280 <_port_switch>
 8001746:	bf00      	nop
 8001748:	200016a8 	.word	0x200016a8
 800174c:	00000000 	.word	0x00000000

08001750 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8001750:	4b04      	ldr	r3, [pc, #16]	; (8001764 <chSchRescheduleS+0x14>)
 8001752:	681a      	ldr	r2, [r3, #0]
 8001754:	699b      	ldr	r3, [r3, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8001756:	6892      	ldr	r2, [r2, #8]
 8001758:	689b      	ldr	r3, [r3, #8]
 800175a:	429a      	cmp	r2, r3
 800175c:	d800      	bhi.n	8001760 <chSchRescheduleS+0x10>
 800175e:	4770      	bx	lr
    chSchDoRescheduleAhead();
 8001760:	f7ff bfd6 	b.w	8001710 <chSchDoRescheduleAhead>
 8001764:	200016a8 	.word	0x200016a8
	...

08001770 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8001770:	4b07      	ldr	r3, [pc, #28]	; (8001790 <chSchGoSleepS+0x20>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8001772:	b430      	push	{r4, r5}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001774:	681a      	ldr	r2, [r3, #0]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8001776:	6999      	ldr	r1, [r3, #24]

  tqp->p_next = tp->p_next;
 8001778:	6814      	ldr	r4, [r2, #0]
  otp->p_state = newstate;
 800177a:	7708      	strb	r0, [r1, #28]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800177c:	2501      	movs	r5, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 800177e:	6063      	str	r3, [r4, #4]
 8001780:	7715      	strb	r5, [r2, #28]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001782:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 8001784:	4610      	mov	r0, r2
}
 8001786:	bc30      	pop	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001788:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 800178a:	f7fe bd79 	b.w	8000280 <_port_switch>
 800178e:	bf00      	nop
 8001790:	200016a8 	.word	0x200016a8
	...

080017a0 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80017a0:	2200      	movs	r2, #0
 80017a2:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 80017a4:	4b08      	ldr	r3, [pc, #32]	; (80017c8 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 80017a6:	b410      	push	{r4}
 80017a8:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80017aa:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 80017ac:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80017ae:	689a      	ldr	r2, [r3, #8]
 80017b0:	428a      	cmp	r2, r1
 80017b2:	d2fb      	bcs.n	80017ac <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80017b4:	685a      	ldr	r2, [r3, #4]
 80017b6:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80017b8:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
 80017ba:	4620      	mov	r0, r4
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80017bc:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 80017be:	605c      	str	r4, [r3, #4]

  return tp;
}
 80017c0:	f85d 4b04 	ldr.w	r4, [sp], #4
 80017c4:	4770      	bx	lr
 80017c6:	bf00      	nop
 80017c8:	200016a8 	.word	0x200016a8
 80017cc:	00000000 	.word	0x00000000

080017d0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80017d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 80017d2:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80017d4:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80017d6:	4607      	mov	r7, r0
 80017d8:	460d      	mov	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80017da:	d01f      	beq.n	800181c <chEvtBroadcastFlagsI+0x4c>
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 80017dc:	2600      	movs	r6, #0
 80017de:	e002      	b.n	80017e6 <chEvtBroadcastFlagsI+0x16>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 80017e0:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80017e2:	42a7      	cmp	r7, r4
 80017e4:	d01a      	beq.n	800181c <chEvtBroadcastFlagsI+0x4c>
  /*lint -restore*/
    elp->el_flags |= flags;
 80017e6:	68e3      	ldr	r3, [r4, #12]
 80017e8:	432b      	orrs	r3, r5
 80017ea:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80017ec:	b115      	cbz	r5, 80017f4 <chEvtBroadcastFlagsI+0x24>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 80017ee:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80017f0:	4213      	tst	r3, r2
 80017f2:	d0f5      	beq.n	80017e0 <chEvtBroadcastFlagsI+0x10>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 80017f4:	6860      	ldr	r0, [r4, #4]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 80017f6:	68a2      	ldr	r2, [r4, #8]
 80017f8:	6b41      	ldr	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 80017fa:	7f03      	ldrb	r3, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 80017fc:	430a      	orrs	r2, r1
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 80017fe:	2b0a      	cmp	r3, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001800:	6342      	str	r2, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001802:	d00c      	beq.n	800181e <chEvtBroadcastFlagsI+0x4e>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8001804:	2b0b      	cmp	r3, #11
 8001806:	d1eb      	bne.n	80017e0 <chEvtBroadcastFlagsI+0x10>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8001808:	6a03      	ldr	r3, [r0, #32]
 800180a:	401a      	ands	r2, r3

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800180c:	4293      	cmp	r3, r2
 800180e:	d1e7      	bne.n	80017e0 <chEvtBroadcastFlagsI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8001810:	6206      	str	r6, [r0, #32]
    (void) chSchReadyI(tp);
 8001812:	f7ff ffc5 	bl	80017a0 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8001816:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001818:	42a7      	cmp	r7, r4
 800181a:	d1e4      	bne.n	80017e6 <chEvtBroadcastFlagsI+0x16>
 800181c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800181e:	6a03      	ldr	r3, [r0, #32]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001820:	421a      	tst	r2, r3
 8001822:	d0dd      	beq.n	80017e0 <chEvtBroadcastFlagsI+0x10>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8001824:	6206      	str	r6, [r0, #32]
    (void) chSchReadyI(tp);
 8001826:	f7ff ffbb 	bl	80017a0 <chSchReadyI>
 800182a:	e7f4      	b.n	8001816 <chEvtBroadcastFlagsI+0x46>
 800182c:	0000      	movs	r0, r0
	...

08001830 <can_lld_sce_handler.9430.4444>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_sce_handler(CANDriver *canp) {
 8001830:	b508      	push	{r3, lr}
  uint32_t msr;

  msr = canp->can->MSR;
 8001832:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001834:	685a      	ldr	r2, [r3, #4]
  canp->can->MSR = CAN_MSR_ERRI | CAN_MSR_WKUI | CAN_MSR_SLAKI;
 8001836:	211c      	movs	r1, #28
    osalEventBroadcastFlagsI(&canp->wakeup_event, 0);
    osalSysUnlockFromISR();
  }
#endif /* CAN_USE_SLEEP_MODE */
  /* Error event.*/
  if (msr & CAN_MSR_ERRI) {
 8001838:	0752      	lsls	r2, r2, #29
 */
static void can_lld_sce_handler(CANDriver *canp) {
  uint32_t msr;

  msr = canp->can->MSR;
  canp->can->MSR = CAN_MSR_ERRI | CAN_MSR_WKUI | CAN_MSR_SLAKI;
 800183a:	6059      	str	r1, [r3, #4]
    osalEventBroadcastFlagsI(&canp->wakeup_event, 0);
    osalSysUnlockFromISR();
  }
#endif /* CAN_USE_SLEEP_MODE */
  /* Error event.*/
  if (msr & CAN_MSR_ERRI) {
 800183c:	d516      	bpl.n	800186c <can_lld_sce_handler.9430.4444+0x3c>
    eventflags_t flags;
    uint32_t esr = canp->can->ESR;
 800183e:	699a      	ldr	r2, [r3, #24]

    canp->can->ESR &= ~CAN_ESR_LEC;
 8001840:	6999      	ldr	r1, [r3, #24]
 8001842:	f021 0170 	bic.w	r1, r1, #112	; 0x70
 8001846:	6199      	str	r1, [r3, #24]
    flags = (eventflags_t)(esr & 7);
    if ((esr & CAN_ESR_LEC) > 0)
 8001848:	f012 0f70 	tst.w	r2, #112	; 0x70
  if (msr & CAN_MSR_ERRI) {
    eventflags_t flags;
    uint32_t esr = canp->can->ESR;

    canp->can->ESR &= ~CAN_ESR_LEC;
    flags = (eventflags_t)(esr & 7);
 800184c:	f002 0107 	and.w	r1, r2, #7
    if ((esr & CAN_ESR_LEC) > 0)
      flags |= CAN_FRAMING_ERROR;
 8001850:	bf18      	it	ne
 8001852:	f041 0108 	orrne.w	r1, r1, #8

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001856:	2320      	movs	r3, #32
 8001858:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800185c:	4418      	add	r0, r3
 800185e:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 8001862:	f7ff ffb5 	bl	80017d0 <chEvtBroadcastFlagsI>
 8001866:	2300      	movs	r3, #0
 8001868:	f383 8811 	msr	BASEPRI, r3
 800186c:	bd08      	pop	{r3, pc}
 800186e:	bf00      	nop

08001870 <Vector148>:
/**
 * @brief   CAN2 SCE interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN2_SCE_HANDLER) {
 8001870:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_sce_handler(&CAND2);
 8001872:	4803      	ldr	r0, [pc, #12]	; (8001880 <Vector148+0x10>)
 8001874:	f7ff ffdc 	bl	8001830 <can_lld_sce_handler.9430.4444>

  OSAL_IRQ_EPILOGUE();
}
 8001878:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_sce_handler(&CAND2);

  OSAL_IRQ_EPILOGUE();
 800187c:	f7ff bd58 	b.w	8001330 <_port_irq_epilogue>
 8001880:	20000d80 	.word	0x20000d80
	...

08001890 <Vector98>:
/**
 * @brief   CAN1 SCE interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_SCE_HANDLER) {
 8001890:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_sce_handler(&CAND1);
 8001892:	4803      	ldr	r0, [pc, #12]	; (80018a0 <Vector98+0x10>)
 8001894:	f7ff ffcc 	bl	8001830 <can_lld_sce_handler.9430.4444>

  OSAL_IRQ_EPILOGUE();
}
 8001898:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_sce_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 800189c:	f7ff bd48 	b.w	8001330 <_port_irq_epilogue>
 80018a0:	20000d58 	.word	0x20000d58
	...

080018b0 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 80018b0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 80018b2:	4b17      	ldr	r3, [pc, #92]	; (8001910 <chMtxUnlock+0x60>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 80018b4:	4604      	mov	r4, r0
  thread_t *ctp = currp;
 80018b6:	6998      	ldr	r0, [r3, #24]
 80018b8:	2320      	movs	r3, #32
 80018ba:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80018be:	6825      	ldr	r5, [r4, #0]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 80018c0:	68e3      	ldr	r3, [r4, #12]
 80018c2:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80018c4:	42ac      	cmp	r4, r5
 80018c6:	d01c      	beq.n	8001902 <chMtxUnlock+0x52>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 80018c8:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80018ca:	b14b      	cbz	r3, 80018e0 <chMtxUnlock+0x30>
 80018cc:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80018ce:	4293      	cmp	r3, r2
 80018d0:	d003      	beq.n	80018da <chMtxUnlock+0x2a>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 80018d2:	6892      	ldr	r2, [r2, #8]
 80018d4:	4291      	cmp	r1, r2
 80018d6:	bf38      	it	cc
 80018d8:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 80018da:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80018dc:	2b00      	cmp	r3, #0
 80018de:	d1f5      	bne.n	80018cc <chMtxUnlock+0x1c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80018e0:	682b      	ldr	r3, [r5, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 80018e2:	6baa      	ldr	r2, [r5, #56]	; 0x38
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 80018e4:	6081      	str	r1, [r0, #8]
 80018e6:	6023      	str	r3, [r4, #0]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80018e8:	4628      	mov	r0, r5
  tqp->p_next->p_prev = (thread_t *)tqp;
 80018ea:	605c      	str	r4, [r3, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 80018ec:	60e2      	str	r2, [r4, #12]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 80018ee:	60a5      	str	r5, [r4, #8]
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
 80018f0:	63ac      	str	r4, [r5, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80018f2:	f7ff ff55 	bl	80017a0 <chSchReadyI>
      chSchRescheduleS();
 80018f6:	f7ff ff2b 	bl	8001750 <chSchRescheduleS>
 80018fa:	2300      	movs	r3, #0
 80018fc:	f383 8811 	msr	BASEPRI, r3
 8001900:	bd38      	pop	{r3, r4, r5, pc}
    }
    else {
      mp->m_owner = NULL;
 8001902:	2300      	movs	r3, #0
 8001904:	60a3      	str	r3, [r4, #8]
 8001906:	2300      	movs	r3, #0
 8001908:	f383 8811 	msr	BASEPRI, r3
 800190c:	bd38      	pop	{r3, r4, r5, pc}
 800190e:	bf00      	nop
 8001910:	200016a8 	.word	0x200016a8
	...

08001920 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001920:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8001922:	4b30      	ldr	r3, [pc, #192]	; (80019e4 <chMtxLockS+0xc4>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001924:	4605      	mov	r5, r0

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8001926:	6880      	ldr	r0, [r0, #8]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8001928:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 800192a:	2800      	cmp	r0, #0
 800192c:	d055      	beq.n	80019da <chMtxLockS+0xba>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 800192e:	68a2      	ldr	r2, [r4, #8]
 8001930:	6883      	ldr	r3, [r0, #8]
 8001932:	4293      	cmp	r3, r2
 8001934:	d210      	bcs.n	8001958 <chMtxLockS+0x38>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8001936:	7f03      	ldrb	r3, [r0, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8001938:	6082      	str	r2, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 800193a:	2b07      	cmp	r3, #7
 800193c:	d80c      	bhi.n	8001958 <chMtxLockS+0x38>
 800193e:	e8df f003 	tbb	[pc, r3]
 8001942:	0b04      	.short	0x0b04
 8001944:	380b0b0b 	.word	0x380b0b0b
 8001948:	381f      	.short	0x381f
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800194a:	e890 000c 	ldmia.w	r0, {r2, r3}
 800194e:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001950:	6802      	ldr	r2, [r0, #0]
 8001952:	6053      	str	r3, [r2, #4]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8001954:	f7ff ff24 	bl	80017a0 <chSchReadyI>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001958:	462b      	mov	r3, r5
 800195a:	e003      	b.n	8001964 <chMtxLockS+0x44>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800195c:	6899      	ldr	r1, [r3, #8]
 800195e:	68a2      	ldr	r2, [r4, #8]
 8001960:	4291      	cmp	r1, r2
 8001962:	d302      	bcc.n	800196a <chMtxLockS+0x4a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001964:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001966:	429d      	cmp	r5, r3
 8001968:	d1f8      	bne.n	800195c <chMtxLockS+0x3c>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800196a:	685a      	ldr	r2, [r3, #4]
 800196c:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800196e:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8001970:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8001972:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 8001974:	6225      	str	r5, [r4, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8001976:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
  }
}
 8001978:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 800197c:	f7ff bef8 	b.w	8001770 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001980:	e890 000a 	ldmia.w	r0, {r1, r3}
 8001984:	6019      	str	r1, [r3, #0]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001986:	6a06      	ldr	r6, [r0, #32]
  tp->p_next->p_prev = tp->p_prev;
 8001988:	6801      	ldr	r1, [r0, #0]
 800198a:	604b      	str	r3, [r1, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800198c:	4633      	mov	r3, r6
 800198e:	e002      	b.n	8001996 <chMtxLockS+0x76>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001990:	6899      	ldr	r1, [r3, #8]
 8001992:	4291      	cmp	r1, r2
 8001994:	d302      	bcc.n	800199c <chMtxLockS+0x7c>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001996:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001998:	429e      	cmp	r6, r3
 800199a:	d1f9      	bne.n	8001990 <chMtxLockS+0x70>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800199c:	685a      	ldr	r2, [r3, #4]
 800199e:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 80019a0:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80019a2:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 80019a4:	6058      	str	r0, [r3, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 80019a6:	68b0      	ldr	r0, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 80019a8:	68a2      	ldr	r2, [r4, #8]
 80019aa:	6883      	ldr	r3, [r0, #8]
 80019ac:	4293      	cmp	r3, r2
 80019ae:	d3c2      	bcc.n	8001936 <chMtxLockS+0x16>
 80019b0:	e7d2      	b.n	8001958 <chMtxLockS+0x38>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80019b2:	e890 000a 	ldmia.w	r0, {r1, r3}
 80019b6:	6019      	str	r1, [r3, #0]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 80019b8:	6a06      	ldr	r6, [r0, #32]
  tp->p_next->p_prev = tp->p_prev;
 80019ba:	6801      	ldr	r1, [r0, #0]
 80019bc:	604b      	str	r3, [r1, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80019be:	4633      	mov	r3, r6
 80019c0:	e002      	b.n	80019c8 <chMtxLockS+0xa8>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80019c2:	6899      	ldr	r1, [r3, #8]
 80019c4:	4291      	cmp	r1, r2
 80019c6:	d302      	bcc.n	80019ce <chMtxLockS+0xae>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 80019c8:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80019ca:	429e      	cmp	r6, r3
 80019cc:	d1f9      	bne.n	80019c2 <chMtxLockS+0xa2>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80019ce:	685a      	ldr	r2, [r3, #4]
 80019d0:	6042      	str	r2, [r0, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 80019d2:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80019d4:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 80019d6:	6058      	str	r0, [r3, #4]
 80019d8:	e7be      	b.n	8001958 <chMtxLockS+0x38>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 80019da:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80019dc:	60eb      	str	r3, [r5, #12]
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 80019de:	60ac      	str	r4, [r5, #8]
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
 80019e0:	63a5      	str	r5, [r4, #56]	; 0x38
 80019e2:	bd70      	pop	{r4, r5, r6, pc}
 80019e4:	200016a8 	.word	0x200016a8
	...

080019f0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 80019f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80019f4:	2320      	movs	r3, #32
 80019f6:	4604      	mov	r4, r0
 80019f8:	f383 8811 	msr	BASEPRI, r3
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
  tp->p_refs--;
 80019fc:	7f85      	ldrb	r5, [r0, #30]
 80019fe:	3d01      	subs	r5, #1
 8001a00:	b2ed      	uxtb	r5, r5
 8001a02:	7785      	strb	r5, [r0, #30]
 8001a04:	2200      	movs	r2, #0
 8001a06:	f382 8811 	msr	BASEPRI, r2
  chSysUnlock();

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 8001a0a:	b915      	cbnz	r5, 8001a12 <chThdRelease+0x22>
 8001a0c:	7f02      	ldrb	r2, [r0, #28]
 8001a0e:	2a0f      	cmp	r2, #15
 8001a10:	d001      	beq.n	8001a16 <chThdRelease+0x26>
 8001a12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 8001a16:	7f42      	ldrb	r2, [r0, #29]
 8001a18:	f002 0203 	and.w	r2, r2, #3
 8001a1c:	2a01      	cmp	r2, #1
 8001a1e:	d003      	beq.n	8001a28 <chThdRelease+0x38>
 8001a20:	2a02      	cmp	r2, #2
 8001a22:	d023      	beq.n	8001a6c <chThdRelease+0x7c>
 8001a24:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001a28:	6942      	ldr	r2, [r0, #20]
 8001a2a:	6901      	ldr	r1, [r0, #16]
 8001a2c:	6111      	str	r1, [r2, #16]
 8001a2e:	6901      	ldr	r1, [r0, #16]
 8001a30:	614a      	str	r2, [r1, #20]
  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
 8001a32:	f850 2c08 	ldr.w	r2, [r0, #-8]
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8001a36:	f1a0 0608 	sub.w	r6, r0, #8
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8001a3a:	f102 0708 	add.w	r7, r2, #8

  H_LOCK(heapp);
 8001a3e:	f102 0810 	add.w	r8, r2, #16
 8001a42:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 8001a46:	4640      	mov	r0, r8
 8001a48:	f7ff ff6a 	bl	8001920 <chMtxLockS>
 8001a4c:	f385 8811 	msr	BASEPRI, r5

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 8001a50:	463b      	mov	r3, r7

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8001a52:	429f      	cmp	r7, r3
 8001a54:	d004      	beq.n	8001a60 <chThdRelease+0x70>
 8001a56:	429e      	cmp	r6, r3
 8001a58:	d802      	bhi.n	8001a60 <chThdRelease+0x70>
 8001a5a:	681b      	ldr	r3, [r3, #0]
 8001a5c:	429f      	cmp	r7, r3
 8001a5e:	d1fa      	bne.n	8001a56 <chThdRelease+0x66>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8001a60:	681a      	ldr	r2, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8001a62:	b18a      	cbz	r2, 8001a88 <chThdRelease+0x98>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8001a64:	4296      	cmp	r6, r2
 8001a66:	d30f      	bcc.n	8001a88 <chThdRelease+0x98>
 8001a68:	4613      	mov	r3, r2
 8001a6a:	e7f2      	b.n	8001a52 <chThdRelease+0x62>
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001a6c:	6941      	ldr	r1, [r0, #20]
 8001a6e:	6902      	ldr	r2, [r0, #16]
 8001a70:	610a      	str	r2, [r1, #16]
 8001a72:	6900      	ldr	r0, [r0, #16]
#endif
      chPoolFree(tp->p_mpool, tp);
 8001a74:	6c22      	ldr	r2, [r4, #64]	; 0x40
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001a76:	6141      	str	r1, [r0, #20]
 8001a78:	f383 8811 	msr	BASEPRI, r3
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8001a7c:	6813      	ldr	r3, [r2, #0]
 8001a7e:	6023      	str	r3, [r4, #0]
  mp->mp_next = php;
 8001a80:	6014      	str	r4, [r2, #0]
 8001a82:	f385 8811 	msr	BASEPRI, r5
 8001a86:	e7c4      	b.n	8001a12 <chThdRelease+0x22>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8001a88:	f854 1c04 	ldr.w	r1, [r4, #-4]
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8001a8c:	f844 2c08 	str.w	r2, [r4, #-8]
      qp->h.u.next = hp;
 8001a90:	601e      	str	r6, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 8001a92:	f101 0208 	add.w	r2, r1, #8
 8001a96:	f854 5c08 	ldr.w	r5, [r4, #-8]
 8001a9a:	18b0      	adds	r0, r6, r2
 8001a9c:	42a8      	cmp	r0, r5
 8001a9e:	d00a      	beq.n	8001ab6 <chThdRelease+0xc6>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 8001aa0:	685a      	ldr	r2, [r3, #4]
 8001aa2:	f102 0108 	add.w	r1, r2, #8
 8001aa6:	4419      	add	r1, r3
 8001aa8:	428e      	cmp	r6, r1
 8001aaa:	d00d      	beq.n	8001ac8 <chThdRelease+0xd8>
      }
      break;
    }
    qp = qp->h.u.next;
  }
  H_UNLOCK(heapp);
 8001aac:	4640      	mov	r0, r8
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
}
 8001aae:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 8001ab2:	f7ff befd 	b.w	80018b0 <chMtxUnlock>
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8001ab6:	6840      	ldr	r0, [r0, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 8001ab8:	58b2      	ldr	r2, [r6, r2]
 8001aba:	f844 2c08 	str.w	r2, [r4, #-8]
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 8001abe:	180a      	adds	r2, r1, r0
 8001ac0:	3208      	adds	r2, #8
 8001ac2:	f844 2c04 	str.w	r2, [r4, #-4]
 8001ac6:	e7eb      	b.n	8001aa0 <chThdRelease+0xb0>
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8001ac8:	f854 0c04 	ldr.w	r0, [r4, #-4]
        qp->h.u.next = hp->h.u.next;
 8001acc:	f854 1c08 	ldr.w	r1, [r4, #-8]
 8001ad0:	6019      	str	r1, [r3, #0]
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8001ad2:	4402      	add	r2, r0
 8001ad4:	3208      	adds	r2, #8
 8001ad6:	605a      	str	r2, [r3, #4]
 8001ad8:	e7e8      	b.n	8001aac <chThdRelease+0xbc>
 8001ada:	bf00      	nop
 8001adc:	0000      	movs	r0, r0
	...

08001ae0 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 8001ae0:	6883      	ldr	r3, [r0, #8]
 8001ae2:	3301      	adds	r3, #1
 8001ae4:	2b00      	cmp	r3, #0
 8001ae6:	6083      	str	r3, [r0, #8]
 8001ae8:	dd00      	ble.n	8001aec <chSemSignalI+0xc>
 8001aea:	4770      	bx	lr
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8001aec:	6803      	ldr	r3, [r0, #0]

  tqp->p_next = tp->p_next;
 8001aee:	681a      	ldr	r2, [r3, #0]
 8001af0:	6002      	str	r2, [r0, #0]
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 8001af2:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001af4:	6050      	str	r0, [r2, #4]
    (void) chSchReadyI(tp);
 8001af6:	4618      	mov	r0, r3

  if (++sp->s_cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
    tp->p_u.rdymsg = MSG_OK;
 8001af8:	6219      	str	r1, [r3, #32]
    (void) chSchReadyI(tp);
 8001afa:	f7ff be51 	b.w	80017a0 <chSchReadyI>
 8001afe:	bf00      	nop

08001b00 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001b00:	b538      	push	{r3, r4, r5, lr}
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001b02:	6803      	ldr	r3, [r0, #0]

  while (queue_notempty(tqp)) {
 8001b04:	4298      	cmp	r0, r3
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8001b06:	4604      	mov	r4, r0
 8001b08:	460d      	mov	r5, r1

  while (queue_notempty(tqp)) {
 8001b0a:	d009      	beq.n	8001b20 <chThdDequeueAllI+0x20>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001b0c:	681a      	ldr	r2, [r3, #0]
 8001b0e:	6022      	str	r2, [r4, #0]
  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
  (void) chSchReadyI(tp);
 8001b10:	4618      	mov	r0, r3
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001b12:	6054      	str	r4, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001b14:	621d      	str	r5, [r3, #32]
  (void) chSchReadyI(tp);
 8001b16:	f7ff fe43 	bl	80017a0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001b1a:	6823      	ldr	r3, [r4, #0]
 8001b1c:	429c      	cmp	r4, r3
 8001b1e:	d1f5      	bne.n	8001b0c <chThdDequeueAllI+0xc>
 8001b20:	bd38      	pop	{r3, r4, r5, pc}
 8001b22:	bf00      	nop
	...

08001b30 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 8001b30:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8001b34:	49a9      	ldr	r1, [pc, #676]	; (8001ddc <usb_lld_pump+0x2ac>)
 8001b36:	4aaa      	ldr	r2, [pc, #680]	; (8001de0 <usb_lld_pump+0x2b0>)
 8001b38:	698b      	ldr	r3, [r1, #24]
  USBDriver *usbp = (USBDriver *)p;
  stm32_otg_t *otgp = usbp->otg;
 8001b3a:	6d07      	ldr	r7, [r0, #80]	; 0x50
 8001b3c:	619a      	str	r2, [r3, #24]
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 8001b3e:	b085      	sub	sp, #20
 8001b40:	2120      	movs	r1, #32
 8001b42:	f381 8811 	msr	BASEPRI, r1
 8001b46:	f100 0260 	add.w	r2, r0, #96	; 0x60
 8001b4a:	46ba      	mov	sl, r7
 8001b4c:	9203      	str	r2, [sp, #12]
 8001b4e:	4607      	mov	r7, r0
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 8001b50:	783b      	ldrb	r3, [r7, #0]
 8001b52:	2b01      	cmp	r3, #1
 8001b54:	d005      	beq.n	8001b62 <usb_lld_pump+0x32>
 8001b56:	6dfb      	ldr	r3, [r7, #92]	; 0x5c
 8001b58:	b98b      	cbnz	r3, 8001b7e <usb_lld_pump+0x4e>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 8001b5a:	f8da 3014 	ldr.w	r3, [sl, #20]
 8001b5e:	06db      	lsls	r3, r3, #27
 8001b60:	d40d      	bmi.n	8001b7e <usb_lld_pump+0x4e>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 8001b62:	f8da 2018 	ldr.w	r2, [sl, #24]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001b66:	4c9d      	ldr	r4, [pc, #628]	; (8001ddc <usb_lld_pump+0x2ac>)
 8001b68:	f042 0210 	orr.w	r2, r2, #16
 8001b6c:	69a3      	ldr	r3, [r4, #24]
 8001b6e:	f8ca 2018 	str.w	r2, [sl, #24]
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
  tp->p_u.wttrp = trp;
 8001b72:	9a03      	ldr	r2, [sp, #12]
msg_t chThdSuspendS(thread_reference_t *trp) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 8001b74:	663b      	str	r3, [r7, #96]	; 0x60
  tp->p_u.wttrp = trp;
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8001b76:	2003      	movs	r0, #3
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
  tp->p_u.wttrp = trp;
 8001b78:	621a      	str	r2, [r3, #32]
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8001b7a:	f7ff fdf9 	bl	8001770 <chSchGoSleepS>
 8001b7e:	2300      	movs	r3, #0
 8001b80:	f383 8811 	msr	BASEPRI, r3
 8001b84:	4698      	mov	r8, r3
 8001b86:	f04f 0b20 	mov.w	fp, #32

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 8001b8a:	f8da 3014 	ldr.w	r3, [sl, #20]
 8001b8e:	f013 0310 	ands.w	r3, r3, #16
 8001b92:	d023      	beq.n	8001bdc <usb_lld_pump+0xac>
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
 8001b94:	6d3e      	ldr	r6, [r7, #80]	; 0x50
 8001b96:	6a34      	ldr	r4, [r6, #32]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 8001b98:	f404 13f0 	and.w	r3, r4, #1966080	; 0x1e0000
 8001b9c:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8001ba0:	d02f      	beq.n	8001c02 <usb_lld_pump+0xd2>
 8001ba2:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 8001ba6:	d1f0      	bne.n	8001b8a <usb_lld_pump+0x5a>
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8001ba8:	f004 030f 	and.w	r3, r4, #15
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8001bac:	eb07 0383 	add.w	r3, r7, r3, lsl #2
  sts = usbp->otg->GRXSTSP;
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8001bb0:	f3c4 140a 	ubfx	r4, r4, #4, #11
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8001bb4:	68da      	ldr	r2, [r3, #12]
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
 8001bb6:	1ce3      	adds	r3, r4, #3
  max = (max + 3) / 4;
  while (n) {
 8001bb8:	089b      	lsrs	r3, r3, #2
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 8001bba:	6a10      	ldr	r0, [r2, #32]
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
  while (n) {
 8001bbc:	d0e5      	beq.n	8001b8a <usb_lld_pump+0x5a>
 8001bbe:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
 8001bc2:	2202      	movs	r2, #2
  while (n) {
    uint32_t w = *fifop;
 8001bc4:	6831      	ldr	r1, [r6, #0]
    if (max) {
 8001bc6:	b112      	cbz	r2, 8001bce <usb_lld_pump+0x9e>
      /* Note, this line relies on the Cortex-M3/M4 ability to perform
         unaligned word accesses and on the LSB-first memory organization.*/
      *((PACKED_VAR uint32_t *)buf) = w;
 8001bc8:	f840 1b04 	str.w	r1, [r0], #4
      buf += 4;
      max--;
 8001bcc:	3a01      	subs	r2, #1
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
  while (n) {
 8001bce:	3b01      	subs	r3, #1
 8001bd0:	d1f8      	bne.n	8001bc4 <usb_lld_pump+0x94>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 8001bd2:	f8da 3014 	ldr.w	r3, [sl, #20]
 8001bd6:	f013 0310 	ands.w	r3, r3, #16
 8001bda:	d1db      	bne.n	8001b94 <usb_lld_pump+0x64>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 8001bdc:	2101      	movs	r1, #1
      if (usbp->txpending & epmask) {
 8001bde:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 8001be0:	fa01 f108 	lsl.w	r1, r1, r8
      if (usbp->txpending & epmask) {
 8001be4:	4211      	tst	r1, r2
      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 8001be6:	9102      	str	r1, [sp, #8]
      if (usbp->txpending & epmask) {
 8001be8:	d16b      	bne.n	8001cc2 <usb_lld_pump+0x192>
 8001bea:	f108 0801 	add.w	r8, r8, #1
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8001bee:	6d7b      	ldr	r3, [r7, #84]	; 0x54
 8001bf0:	689b      	ldr	r3, [r3, #8]
 8001bf2:	fa5f f888 	uxtb.w	r8, r8
 8001bf6:	4598      	cmp	r8, r3
 8001bf8:	d9c5      	bls.n	8001b86 <usb_lld_pump+0x56>
 8001bfa:	2320      	movs	r3, #32
 8001bfc:	f383 8811 	msr	BASEPRI, r3
 8001c00:	e7a6      	b.n	8001b50 <usb_lld_pump+0x20>
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8001c02:	f004 050f 	and.w	r5, r4, #15
 8001c06:	eb07 0585 	add.w	r5, r7, r5, lsl #2
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8001c0a:	f3c4 140a 	ubfx	r4, r4, #4, #11
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    if (usbp->epc[ep]->out_state->rxqueued) {
 8001c0e:	68eb      	ldr	r3, [r5, #12]
 8001c10:	6999      	ldr	r1, [r3, #24]
 8001c12:	780b      	ldrb	r3, [r1, #0]
 8001c14:	b9e3      	cbnz	r3, 8001c50 <usb_lld_pump+0x120>
      otg_fifo_read_to_queue(usbp->otg->FIFO[0],
                             usbp->epc[ep]->out_state->mode.queue.rxqueue,
                             cnt);
    }
    else {
      otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8001c16:	1d0a      	adds	r2, r1, #4
 8001c18:	e892 400c 	ldmia.w	r2, {r2, r3, lr}
 8001c1c:	3203      	adds	r2, #3
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
 8001c1e:	1ad2      	subs	r2, r2, r3
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
 8001c20:	1ce3      	adds	r3, r4, #3
  max = (max + 3) / 4;
  while (n) {
 8001c22:	089b      	lsrs	r3, r3, #2
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
 8001c24:	ea4f 0292 	mov.w	r2, r2, lsr #2
  while (n) {
 8001c28:	d009      	beq.n	8001c3e <usb_lld_pump+0x10e>
 8001c2a:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
 8001c2e:	46f4      	mov	ip, lr
    uint32_t w = *fifop;
 8001c30:	6830      	ldr	r0, [r6, #0]
    if (max) {
 8001c32:	b112      	cbz	r2, 8001c3a <usb_lld_pump+0x10a>
      /* Note, this line relies on the Cortex-M3/M4 ability to perform
         unaligned word accesses and on the LSB-first memory organization.*/
      *((PACKED_VAR uint32_t *)buf) = w;
 8001c34:	f84c 0b04 	str.w	r0, [ip], #4
      buf += 4;
      max--;
 8001c38:	3a01      	subs	r2, #1
                                    size_t n,
                                    size_t max) {

  n = (n + 3) / 4;
  max = (max + 3) / 4;
  while (n) {
 8001c3a:	3b01      	subs	r3, #1
 8001c3c:	d1f8      	bne.n	8001c30 <usb_lld_pump+0x100>
      otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
                              usbp->epc[ep]->out_state->mode.linear.rxbuf,
                              cnt,
                              usbp->epc[ep]->out_state->rxsize -
                              usbp->epc[ep]->out_state->rxcnt);
      usbp->epc[ep]->out_state->mode.linear.rxbuf += cnt;
 8001c3e:	eb0e 0004 	add.w	r0, lr, r4
 8001c42:	60c8      	str	r0, [r1, #12]
    }
    usbp->epc[ep]->out_state->rxcnt += cnt;
 8001c44:	68eb      	ldr	r3, [r5, #12]
 8001c46:	699b      	ldr	r3, [r3, #24]
 8001c48:	689a      	ldr	r2, [r3, #8]
 8001c4a:	4414      	add	r4, r2
 8001c4c:	609c      	str	r4, [r3, #8]
 8001c4e:	e79c      	b.n	8001b8a <usb_lld_pump+0x5a>
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    if (usbp->epc[ep]->out_state->rxqueued) {
      /* Queue associated.*/
      otg_fifo_read_to_queue(usbp->otg->FIFO[0],
 8001c50:	68c8      	ldr	r0, [r1, #12]
                                   input_queue_t *iqp,
                                   size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 8001c52:	b344      	cbz	r4, 8001ca6 <usb_lld_pump+0x176>
 8001c54:	6942      	ldr	r2, [r0, #20]
 8001c56:	f506 5680 	add.w	r6, r6, #4096	; 0x1000
 8001c5a:	46a6      	mov	lr, r4
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 8001c5c:	f1be 0f03 	cmp.w	lr, #3
 8001c60:	d907      	bls.n	8001c72 <usb_lld_pump+0x142>
      size_t streak;
      uint32_t nw2end = (iqp->q_wrptr - iqp->q_wrptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      iqp->q_wrptr = otg_do_pop(fifop, iqp->q_wrptr, streak);
      if (iqp->q_wrptr >= iqp->q_top) {
 8001c62:	6903      	ldr	r3, [r0, #16]
 8001c64:	429a      	cmp	r2, r3
 8001c66:	d304      	bcc.n	8001c72 <usb_lld_pump+0x142>
        iqp->q_wrptr = iqp->q_buffer;
 8001c68:	68c2      	ldr	r2, [r0, #12]
 8001c6a:	6142      	str	r2, [r0, #20]
  ntogo = n;
  while (ntogo > 0) {
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 8001c6c:	f1be 0f03 	cmp.w	lr, #3
 8001c70:	d8f7      	bhi.n	8001c62 <usb_lld_pump+0x132>
       queue circular buffer boundary or there are some remaining bytes.*/
    if (ntogo <= 0)
      break;

    /* One byte at time.*/
    w = *fifop;
 8001c72:	f8d6 c000 	ldr.w	ip, [r6]
 8001c76:	2300      	movs	r3, #0
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
      *iqp->q_wrptr++ = (uint8_t)(w >> (i * 8));
 8001c78:	f102 0901 	add.w	r9, r2, #1
 8001c7c:	fa2c f103 	lsr.w	r1, ip, r3
 8001c80:	f8c0 9014 	str.w	r9, [r0, #20]
 8001c84:	7011      	strb	r1, [r2, #0]
      if (iqp->q_wrptr >= iqp->q_top)
 8001c86:	6902      	ldr	r2, [r0, #16]
 8001c88:	6941      	ldr	r1, [r0, #20]
 8001c8a:	4291      	cmp	r1, r2
        iqp->q_wrptr = iqp->q_buffer;
 8001c8c:	bf24      	itt	cs
 8001c8e:	68c2      	ldrcs	r2, [r0, #12]
 8001c90:	6142      	strcs	r2, [r0, #20]
      break;

    /* One byte at time.*/
    w = *fifop;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
 8001c92:	f1be 0e01 	subs.w	lr, lr, #1
 8001c96:	d006      	beq.n	8001ca6 <usb_lld_pump+0x176>
 8001c98:	2b18      	cmp	r3, #24
 8001c9a:	d002      	beq.n	8001ca2 <usb_lld_pump+0x172>
 8001c9c:	3308      	adds	r3, #8
 8001c9e:	6942      	ldr	r2, [r0, #20]
 8001ca0:	e7ea      	b.n	8001c78 <usb_lld_pump+0x148>
 8001ca2:	6942      	ldr	r2, [r0, #20]
 8001ca4:	e7da      	b.n	8001c5c <usb_lld_pump+0x12c>
 8001ca6:	f38b 8811 	msr	BASEPRI, fp
    }
  }

  /* Updating queue.*/
  osalSysLock();
  iqp->q_counter += n;
 8001caa:	6883      	ldr	r3, [r0, #8]
 8001cac:	4423      	add	r3, r4
 8001cae:	6083      	str	r3, [r0, #8]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8001cb0:	2100      	movs	r1, #0
 8001cb2:	f7ff ff25 	bl	8001b00 <chThdDequeueAllI>
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {

  chSchRescheduleS();
 8001cb6:	f7ff fd4b 	bl	8001750 <chSchRescheduleS>
 8001cba:	2000      	movs	r0, #0
 8001cbc:	f380 8811 	msr	BASEPRI, r0
 8001cc0:	e7c0      	b.n	8001c44 <usb_lld_pump+0x114>
 8001cc2:	2220      	movs	r2, #32
 8001cc4:	f382 8811 	msr	BASEPRI, r2
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8001cc8:	f8da 1008 	ldr.w	r1, [sl, #8]
        usbp->txpending &= ~epmask;
 8001ccc:	6dfa      	ldr	r2, [r7, #92]	; 0x5c
 8001cce:	9c02      	ldr	r4, [sp, #8]
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8001cd0:	f021 0101 	bic.w	r1, r1, #1
        usbp->txpending &= ~epmask;
 8001cd4:	ea22 0204 	bic.w	r2, r2, r4
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8001cd8:	f8ca 1008 	str.w	r1, [sl, #8]
        usbp->txpending &= ~epmask;
 8001cdc:	65fa      	str	r2, [r7, #92]	; 0x5c
 8001cde:	f383 8811 	msr	BASEPRI, r3
 8001ce2:	eb07 0b88 	add.w	fp, r7, r8, lsl #2
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8001ce6:	f8db 100c 	ldr.w	r1, [fp, #12]
 8001cea:	6948      	ldr	r0, [r1, #20]
 8001cec:	6883      	ldr	r3, [r0, #8]
 8001cee:	6842      	ldr	r2, [r0, #4]
 8001cf0:	4293      	cmp	r3, r2
 8001cf2:	f080 80ad 	bcs.w	8001e50 <usb_lld_pump+0x320>
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8001cf6:	6d3d      	ldr	r5, [r7, #80]	; 0x50
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
    if (n > usbp->epc[ep]->in_maxsize)
 8001cf8:	8a09      	ldrh	r1, [r1, #16]
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8001cfa:	ea4f 1948 	mov.w	r9, r8, lsl #5
 8001cfe:	eb05 0409 	add.w	r4, r5, r9
    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8001d02:	1ad2      	subs	r2, r2, r3
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8001d04:	f8d4 3918 	ldr.w	r3, [r4, #2328]	; 0x918
 8001d08:	428a      	cmp	r2, r1
 8001d0a:	bf34      	ite	cc
 8001d0c:	4616      	movcc	r6, r2
 8001d0e:	460e      	movcs	r6, r1
 8001d10:	b29b      	uxth	r3, r3
 8001d12:	ebb6 0f83 	cmp.w	r6, r3, lsl #2
 8001d16:	f108 0801 	add.w	r8, r8, #1
 8001d1a:	bf98      	it	ls
 8001d1c:	9701      	strls	r7, [sp, #4]
 8001d1e:	d82a      	bhi.n	8001d76 <usb_lld_pump+0x246>

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    /* Handles the two cases: linear buffer or queue.*/
    if (usbp->epc[ep]->in_state->txqueued) {
 8001d20:	7803      	ldrb	r3, [r0, #0]
 8001d22:	2b00      	cmp	r3, #0
 8001d24:	d13c      	bne.n	8001da0 <usb_lld_pump+0x270>
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {

  otg_do_push(fifop, (uint8_t *)buf, (n + 3) / 4);
 8001d26:	1cf3      	adds	r3, r6, #3
                                usbp->epc[ep]->in_state->mode.queue.txqueue,
                                n);
    }
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8001d28:	68c4      	ldr	r4, [r0, #12]
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 8001d2a:	089b      	lsrs	r3, r3, #2
                                usbp->epc[ep]->in_state->mode.queue.txqueue,
                                n);
    }
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 8001d2c:	eb05 3508 	add.w	r5, r5, r8, lsl #12
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 8001d30:	bf18      	it	ne
 8001d32:	4622      	movne	r2, r4
 8001d34:	d004      	beq.n	8001d40 <usb_lld_pump+0x210>
    /* Note, this line relies on the Cortex-M3/M4 ability to perform
       unaligned word accesses and on the LSB-first memory organization.*/
    *fifop = *((PACKED_VAR uint32_t *)buf);
 8001d36:	f852 1b04 	ldr.w	r1, [r2], #4
 8001d3a:	6029      	str	r1, [r5, #0]
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 8001d3c:	3b01      	subs	r3, #1
 8001d3e:	d1fa      	bne.n	8001d36 <usb_lld_pump+0x206>
    else {
      /* Linear buffer associated.*/
      otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
                                 usbp->epc[ep]->in_state->mode.linear.txbuf,
                                 n);
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
 8001d40:	4434      	add	r4, r6
 8001d42:	60c4      	str	r4, [r0, #12]
    }
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 8001d44:	f8db 100c 	ldr.w	r1, [fp, #12]
 8001d48:	6948      	ldr	r0, [r1, #20]
 8001d4a:	6883      	ldr	r3, [r0, #8]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8001d4c:	6842      	ldr	r2, [r0, #4]
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
    }
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 8001d4e:	4433      	add	r3, r6
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8001d50:	429a      	cmp	r2, r3
      usbp->epc[ep]->in_state->mode.linear.txbuf += n;
    }
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 8001d52:	6083      	str	r3, [r0, #8]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 8001d54:	d979      	bls.n	8001e4a <usb_lld_pump+0x31a>
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8001d56:	9c01      	ldr	r4, [sp, #4]
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
    if (n > usbp->epc[ep]->in_maxsize)
 8001d58:	8a09      	ldrh	r1, [r1, #16]
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8001d5a:	6d25      	ldr	r5, [r4, #80]	; 0x50
 8001d5c:	eb05 0409 	add.w	r4, r5, r9
    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8001d60:	1ad6      	subs	r6, r2, r3
    if (n > usbp->epc[ep]->in_maxsize)
      n = usbp->epc[ep]->in_maxsize;

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 8001d62:	f8d4 3918 	ldr.w	r3, [r4, #2328]	; 0x918
 8001d66:	428e      	cmp	r6, r1
 8001d68:	bf28      	it	cs
 8001d6a:	460e      	movcs	r6, r1
 8001d6c:	b29b      	uxth	r3, r3
 8001d6e:	ebb6 0f83 	cmp.w	r6, r3, lsl #2
 8001d72:	d9d5      	bls.n	8001d20 <usb_lld_pump+0x1f0>
 8001d74:	9f01      	ldr	r7, [sp, #4]
      return FALSE;
 8001d76:	2200      	movs	r2, #0
 8001d78:	2320      	movs	r3, #32
 8001d7a:	f383 8811 	msr	BASEPRI, r3
        osalSysUnlock();

        done = otg_txfifo_handler(usbp, ep);

        osalSysLock();
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8001d7e:	f8da 3008 	ldr.w	r3, [sl, #8]
 8001d82:	f043 0301 	orr.w	r3, r3, #1
 8001d86:	f8ca 3008 	str.w	r3, [sl, #8]
        if (!done)
 8001d8a:	b92a      	cbnz	r2, 8001d98 <usb_lld_pump+0x268>
          otgp->DIEPEMPMSK |= epmask;
 8001d8c:	f8da 3834 	ldr.w	r3, [sl, #2100]	; 0x834
 8001d90:	9a02      	ldr	r2, [sp, #8]
 8001d92:	4313      	orrs	r3, r2
 8001d94:	f8ca 3834 	str.w	r3, [sl, #2100]	; 0x834
 8001d98:	2300      	movs	r3, #0
 8001d9a:	f383 8811 	msr	BASEPRI, r3
 8001d9e:	e726      	b.n	8001bee <usb_lld_pump+0xbe>
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    /* Handles the two cases: linear buffer or queue.*/
    if (usbp->epc[ep]->in_state->txqueued) {
      /* Queue associated.*/
      otg_fifo_write_from_queue(usbp->otg->FIFO[ep],
 8001da0:	eb05 3508 	add.w	r5, r5, r8, lsl #12
 8001da4:	68c0      	ldr	r0, [r0, #12]
                                      output_queue_t *oqp,
                                      size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 8001da6:	b306      	cbz	r6, 8001dea <usb_lld_pump+0x2ba>
 8001da8:	f8d0 c010 	ldr.w	ip, [r0, #16]
 8001dac:	4632      	mov	r2, r6
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
 8001dae:	0891      	lsrs	r1, r2, #2
 8001db0:	d12a      	bne.n	8001e08 <usb_lld_pump+0x2d8>
 8001db2:	6981      	ldr	r1, [r0, #24]
      }
    }

    /* If this condition is not satisfied then there is a word lying across
       queue circular buffer boundary or there are some remaining bytes.*/
    if (ntogo <= 0)
 8001db4:	2300      	movs	r3, #0
 8001db6:	461f      	mov	r7, r3

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
      w |= (uint32_t)*oqp->q_rdptr++ << (i * 8);
 8001db8:	1c4c      	adds	r4, r1, #1
 8001dba:	6184      	str	r4, [r0, #24]
 8001dbc:	7809      	ldrb	r1, [r1, #0]
      if (oqp->q_rdptr >= oqp->q_top)
 8001dbe:	45a4      	cmp	ip, r4

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
      w |= (uint32_t)*oqp->q_rdptr++ << (i * 8);
 8001dc0:	fa01 f103 	lsl.w	r1, r1, r3
 8001dc4:	ea47 0701 	orr.w	r7, r7, r1
      if (oqp->q_rdptr >= oqp->q_top)
        oqp->q_rdptr = oqp->q_buffer;
 8001dc8:	bf9c      	itt	ls
 8001dca:	68c1      	ldrls	r1, [r0, #12]
 8001dcc:	6181      	strls	r1, [r0, #24]
      break;

    /* One byte at time.*/
    w = 0;
    i = 0;
    while ((ntogo > 0) && (i < 4)) {
 8001dce:	3a01      	subs	r2, #1
 8001dd0:	d008      	beq.n	8001de4 <usb_lld_pump+0x2b4>
 8001dd2:	2b18      	cmp	r3, #24
 8001dd4:	d006      	beq.n	8001de4 <usb_lld_pump+0x2b4>
 8001dd6:	3308      	adds	r3, #8
 8001dd8:	6981      	ldr	r1, [r0, #24]
 8001dda:	e7ed      	b.n	8001db8 <usb_lld_pump+0x288>
 8001ddc:	200016a8 	.word	0x200016a8
 8001de0:	08006c70 	.word	0x08006c70
      if (oqp->q_rdptr >= oqp->q_top)
        oqp->q_rdptr = oqp->q_buffer;
      ntogo--;
      i++;
    }
    *fifop = w;
 8001de4:	602f      	str	r7, [r5, #0]
                                      output_queue_t *oqp,
                                      size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 8001de6:	2a00      	cmp	r2, #0
 8001de8:	d1e1      	bne.n	8001dae <usb_lld_pump+0x27e>
 8001dea:	2320      	movs	r3, #32
 8001dec:	f383 8811 	msr	BASEPRI, r3
    *fifop = w;
  }

  /* Updating queue.*/
  osalSysLock();
  oqp->q_counter += n;
 8001df0:	6883      	ldr	r3, [r0, #8]
 8001df2:	4433      	add	r3, r6
 8001df4:	6083      	str	r3, [r0, #8]
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8001df6:	2100      	movs	r1, #0
 8001df8:	f7ff fe82 	bl	8001b00 <chThdDequeueAllI>
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {

  chSchRescheduleS();
 8001dfc:	f7ff fca8 	bl	8001750 <chSchRescheduleS>
 8001e00:	2000      	movs	r0, #0
 8001e02:	f380 8811 	msr	BASEPRI, r0
 8001e06:	e79d      	b.n	8001d44 <usb_lld_pump+0x214>
    uint32_t w, i;
    size_t nw = ntogo / 4;

    if (nw > 0) {
      size_t streak;
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;
 8001e08:	6987      	ldr	r7, [r0, #24]
 8001e0a:	ebbc 0307 	subs.w	r3, ip, r7
 8001e0e:	bf48      	it	mi
 8001e10:	3303      	addmi	r3, #3
 8001e12:	109b      	asrs	r3, r3, #2

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
 8001e14:	4299      	cmp	r1, r3
 8001e16:	bf38      	it	cc
 8001e18:	460b      	movcc	r3, r1
 8001e1a:	ea4f 0e83 	mov.w	lr, r3, lsl #2
 8001e1e:	ebce 0202 	rsb	r2, lr, r2
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 8001e22:	b133      	cbz	r3, 8001e32 <usb_lld_pump+0x302>
 8001e24:	4639      	mov	r1, r7
    /* Note, this line relies on the Cortex-M3/M4 ability to perform
       unaligned word accesses and on the LSB-first memory organization.*/
    *fifop = *((PACKED_VAR uint32_t *)buf);
 8001e26:	f851 4b04 	ldr.w	r4, [r1], #4
 8001e2a:	602c      	str	r4, [r5, #0]
 *
 * @notapi
 */
static uint8_t *otg_do_push(volatile uint32_t *fifop, uint8_t *buf, size_t n) {

  while (n > 0) {
 8001e2c:	3b01      	subs	r3, #1
 8001e2e:	d1fa      	bne.n	8001e26 <usb_lld_pump+0x2f6>
 8001e30:	4477      	add	r7, lr
      size_t streak;
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      oqp->q_rdptr = otg_do_push(fifop, oqp->q_rdptr, streak);
      if (oqp->q_rdptr >= oqp->q_top) {
 8001e32:	4567      	cmp	r7, ip
    if (nw > 0) {
      size_t streak;
      uint32_t nw2end = (oqp->q_top - oqp->q_rdptr) / 4;

      ntogo -= (streak = nw <= nw2end ? nw : nw2end) * 4;
      oqp->q_rdptr = otg_do_push(fifop, oqp->q_rdptr, streak);
 8001e34:	6187      	str	r7, [r0, #24]
      if (oqp->q_rdptr >= oqp->q_top) {
 8001e36:	d304      	bcc.n	8001e42 <usb_lld_pump+0x312>
        oqp->q_rdptr = oqp->q_buffer;
 8001e38:	68c3      	ldr	r3, [r0, #12]
 8001e3a:	6183      	str	r3, [r0, #24]
                                      output_queue_t *oqp,
                                      size_t n) {
  size_t ntogo;

  ntogo = n;
  while (ntogo > 0) {
 8001e3c:	2a00      	cmp	r2, #0
 8001e3e:	d1b6      	bne.n	8001dae <usb_lld_pump+0x27e>
 8001e40:	e7d3      	b.n	8001dea <usb_lld_pump+0x2ba>
      }
    }

    /* If this condition is not satisfied then there is a word lying across
       queue circular buffer boundary or there are some remaining bytes.*/
    if (ntogo <= 0)
 8001e42:	2a00      	cmp	r2, #0
 8001e44:	d0d1      	beq.n	8001dea <usb_lld_pump+0x2ba>
 8001e46:	4639      	mov	r1, r7
 8001e48:	e7b4      	b.n	8001db4 <usb_lld_pump+0x284>
 8001e4a:	9f01      	ldr	r7, [sp, #4]
  while (TRUE) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
      return TRUE;
 8001e4c:	2201      	movs	r2, #1
 8001e4e:	e793      	b.n	8001d78 <usb_lld_pump+0x248>
 8001e50:	f108 0801 	add.w	r8, r8, #1
 8001e54:	e7fa      	b.n	8001e4c <usb_lld_pump+0x31c>
 8001e56:	bf00      	nop
	...

08001e60 <can_lld_rx1_handler.9442.4363>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx1_handler(CANDriver *canp) {
 8001e60:	b538      	push	{r3, r4, r5, lr}
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
 8001e62:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001e64:	691d      	ldr	r5, [r3, #16]
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
 8001e66:	07aa      	lsls	r2, r5, #30
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx1_handler(CANDriver *canp) {
 8001e68:	4604      	mov	r4, r0
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
 8001e6a:	d10e      	bne.n	8001e8a <can_lld_rx1_handler.9442.4363+0x2a>
    osalSysLockFromISR();
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(2));
    osalSysUnlockFromISR();
  }
  if ((rf1r & CAN_RF1R_FOVR1) > 0) {
 8001e6c:	06eb      	lsls	r3, r5, #27
 8001e6e:	d50b      	bpl.n	8001e88 <can_lld_rx1_handler.9442.4363+0x28>
    /* Overflow events handling.*/
    canp->can->RF1R = CAN_RF1R_FOVR1;
 8001e70:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001e72:	2110      	movs	r1, #16
 8001e74:	6119      	str	r1, [r3, #16]
 8001e76:	2320      	movs	r3, #32
 8001e78:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001e7c:	18e0      	adds	r0, r4, r3
 8001e7e:	f7ff fca7 	bl	80017d0 <chEvtBroadcastFlagsI>
 8001e82:	2300      	movs	r3, #0
 8001e84:	f383 8811 	msr	BASEPRI, r3
 8001e88:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t rf1r;

  rf1r = canp->can->RF1R;
  if ((rf1r & CAN_RF1R_FMP1) > 0) {
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE1;
 8001e8a:	695a      	ldr	r2, [r3, #20]
 8001e8c:	f022 0210 	bic.w	r2, r2, #16
 8001e90:	615a      	str	r2, [r3, #20]
 8001e92:	2320      	movs	r3, #32
 8001e94:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8001e98:	2100      	movs	r1, #0
 8001e9a:	3010      	adds	r0, #16
 8001e9c:	f7ff fe30 	bl	8001b00 <chThdDequeueAllI>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001ea0:	f104 0018 	add.w	r0, r4, #24
 8001ea4:	2102      	movs	r1, #2
 8001ea6:	f7ff fc93 	bl	80017d0 <chEvtBroadcastFlagsI>
 8001eaa:	2300      	movs	r3, #0
 8001eac:	f383 8811 	msr	BASEPRI, r3
 8001eb0:	e7dc      	b.n	8001e6c <can_lld_rx1_handler.9442.4363+0xc>
 8001eb2:	bf00      	nop
	...

08001ec0 <Vector144>:
/**
 * @brief   CAN2 RX1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN2_RX1_HANDLER) {
 8001ec0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx1_handler(&CAND2);
 8001ec2:	4803      	ldr	r0, [pc, #12]	; (8001ed0 <Vector144+0x10>)
 8001ec4:	f7ff ffcc 	bl	8001e60 <can_lld_rx1_handler.9442.4363>

  OSAL_IRQ_EPILOGUE();
}
 8001ec8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx1_handler(&CAND2);

  OSAL_IRQ_EPILOGUE();
 8001ecc:	f7ff ba30 	b.w	8001330 <_port_irq_epilogue>
 8001ed0:	20000d80 	.word	0x20000d80
	...

08001ee0 <Vector94>:
/**
 * @brief   CAN1 RX1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_RX1_HANDLER) {
 8001ee0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx1_handler(&CAND1);
 8001ee2:	4803      	ldr	r0, [pc, #12]	; (8001ef0 <Vector94+0x10>)
 8001ee4:	f7ff ffbc 	bl	8001e60 <can_lld_rx1_handler.9442.4363>

  OSAL_IRQ_EPILOGUE();
}
 8001ee8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx1_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 8001eec:	f7ff ba20 	b.w	8001330 <_port_irq_epilogue>
 8001ef0:	20000d58 	.word	0x20000d58
	...

08001f00 <can_lld_rx0_handler.9436.4438>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx0_handler(CANDriver *canp) {
 8001f00:	b538      	push	{r3, r4, r5, lr}
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
 8001f02:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001f04:	68dd      	ldr	r5, [r3, #12]
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
 8001f06:	07aa      	lsls	r2, r5, #30
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_rx0_handler(CANDriver *canp) {
 8001f08:	4604      	mov	r4, r0
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
 8001f0a:	d10e      	bne.n	8001f2a <can_lld_rx0_handler.9436.4438+0x2a>
    osalSysLockFromISR();
    osalThreadDequeueAllI(&canp->rxqueue, MSG_OK);
    osalEventBroadcastFlagsI(&canp->rxfull_event, CAN_MAILBOX_TO_MASK(1));
    osalSysUnlockFromISR();
  }
  if ((rf0r & CAN_RF0R_FOVR0) > 0) {
 8001f0c:	06eb      	lsls	r3, r5, #27
 8001f0e:	d50b      	bpl.n	8001f28 <can_lld_rx0_handler.9436.4438+0x28>
    /* Overflow events handling.*/
    canp->can->RF0R = CAN_RF0R_FOVR0;
 8001f10:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001f12:	2110      	movs	r1, #16
 8001f14:	60d9      	str	r1, [r3, #12]
 8001f16:	2320      	movs	r3, #32
 8001f18:	f383 8811 	msr	BASEPRI, r3
 8001f1c:	18e0      	adds	r0, r4, r3
 8001f1e:	f7ff fc57 	bl	80017d0 <chEvtBroadcastFlagsI>
 8001f22:	2300      	movs	r3, #0
 8001f24:	f383 8811 	msr	BASEPRI, r3
 8001f28:	bd38      	pop	{r3, r4, r5, pc}
  uint32_t rf0r;

  rf0r = canp->can->RF0R;
  if ((rf0r & CAN_RF0R_FMP0) > 0) {
    /* No more receive events until the queue 0 has been emptied.*/
    canp->can->IER &= ~CAN_IER_FMPIE0;
 8001f2a:	695a      	ldr	r2, [r3, #20]
 8001f2c:	f022 0202 	bic.w	r2, r2, #2
 8001f30:	615a      	str	r2, [r3, #20]
 8001f32:	2320      	movs	r3, #32
 8001f34:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8001f38:	2100      	movs	r1, #0
 8001f3a:	3010      	adds	r0, #16
 8001f3c:	f7ff fde0 	bl	8001b00 <chThdDequeueAllI>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001f40:	f104 0018 	add.w	r0, r4, #24
 8001f44:	2101      	movs	r1, #1
 8001f46:	f7ff fc43 	bl	80017d0 <chEvtBroadcastFlagsI>
 8001f4a:	2300      	movs	r3, #0
 8001f4c:	f383 8811 	msr	BASEPRI, r3
 8001f50:	e7dc      	b.n	8001f0c <can_lld_rx0_handler.9436.4438+0xc>
 8001f52:	bf00      	nop
	...

08001f60 <Vector140>:
/*
 * @brief   CAN2 RX0 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN2_RX0_HANDLER) {
 8001f60:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx0_handler(&CAND2);
 8001f62:	4803      	ldr	r0, [pc, #12]	; (8001f70 <Vector140+0x10>)
 8001f64:	f7ff ffcc 	bl	8001f00 <can_lld_rx0_handler.9436.4438>

  OSAL_IRQ_EPILOGUE();
}
 8001f68:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx0_handler(&CAND2);

  OSAL_IRQ_EPILOGUE();
 8001f6c:	f7ff b9e0 	b.w	8001330 <_port_irq_epilogue>
 8001f70:	20000d80 	.word	0x20000d80
	...

08001f80 <Vector90>:
/*
 * @brief   CAN1 RX0 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_RX0_HANDLER) {
 8001f80:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx0_handler(&CAND1);
 8001f82:	4803      	ldr	r0, [pc, #12]	; (8001f90 <Vector90+0x10>)
 8001f84:	f7ff ffbc 	bl	8001f00 <can_lld_rx0_handler.9436.4438>

  OSAL_IRQ_EPILOGUE();
}
 8001f88:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_rx0_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 8001f8c:	f7ff b9d0 	b.w	8001330 <_port_irq_epilogue>
 8001f90:	20000d58 	.word	0x20000d58
	...

08001fa0 <can_lld_tx_handler.9427.4447>:
 * @notapi
 */
static void can_lld_tx_handler(CANDriver *canp) {

  /* No more events until a message is transmitted.*/
  canp->can->TSR = CAN_TSR_RQCP0 | CAN_TSR_RQCP1 | CAN_TSR_RQCP2;
 8001fa0:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8001fa2:	490a      	ldr	r1, [pc, #40]	; (8001fcc <can_lld_tx_handler.9427.4447+0x2c>)
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
static void can_lld_tx_handler(CANDriver *canp) {
 8001fa4:	b510      	push	{r4, lr}
 8001fa6:	2220      	movs	r2, #32
 8001fa8:	4604      	mov	r4, r0

  /* No more events until a message is transmitted.*/
  canp->can->TSR = CAN_TSR_RQCP0 | CAN_TSR_RQCP1 | CAN_TSR_RQCP2;
 8001faa:	6099      	str	r1, [r3, #8]
 8001fac:	f382 8811 	msr	BASEPRI, r2
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  chThdDequeueAllI(tqp, msg);
 8001fb0:	2100      	movs	r1, #0
 8001fb2:	3008      	adds	r0, #8
 8001fb4:	f7ff fda4 	bl	8001b00 <chThdDequeueAllI>
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8001fb8:	f104 001c 	add.w	r0, r4, #28
 8001fbc:	2101      	movs	r1, #1
 8001fbe:	f7ff fc07 	bl	80017d0 <chEvtBroadcastFlagsI>
 8001fc2:	2300      	movs	r3, #0
 8001fc4:	f383 8811 	msr	BASEPRI, r3
 8001fc8:	bd10      	pop	{r4, pc}
 8001fca:	bf00      	nop
 8001fcc:	00010101 	.word	0x00010101

08001fd0 <Vector13C>:
/**
 * @brief   CAN2 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN2_TX_HANDLER) {
 8001fd0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_tx_handler(&CAND2);
 8001fd2:	4803      	ldr	r0, [pc, #12]	; (8001fe0 <Vector13C+0x10>)
 8001fd4:	f7ff ffe4 	bl	8001fa0 <can_lld_tx_handler.9427.4447>

  OSAL_IRQ_EPILOGUE();
}
 8001fd8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_tx_handler(&CAND2);

  OSAL_IRQ_EPILOGUE();
 8001fdc:	f7ff b9a8 	b.w	8001330 <_port_irq_epilogue>
 8001fe0:	20000d80 	.word	0x20000d80
	...

08001ff0 <Vector8C>:
/**
 * @brief   CAN1 TX interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_CAN1_TX_HANDLER) {
 8001ff0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_tx_handler(&CAND1);
 8001ff2:	4803      	ldr	r0, [pc, #12]	; (8002000 <Vector8C+0x10>)
 8001ff4:	f7ff ffd4 	bl	8001fa0 <can_lld_tx_handler.9427.4447>

  OSAL_IRQ_EPILOGUE();
}
 8001ff8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  can_lld_tx_handler(&CAND1);

  OSAL_IRQ_EPILOGUE();
 8001ffc:	f7ff b998 	b.w	8001330 <_port_irq_epilogue>
 8002000:	20000d58 	.word	0x20000d58
	...

08002010 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8002010:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8002012:	4b0e      	ldr	r3, [pc, #56]	; (800204c <chThdExitS+0x3c>)
 8002014:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8002016:	6a63      	ldr	r3, [r4, #36]	; 0x24

  tp->p_u.exitcode = msg;
 8002018:	6220      	str	r0, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800201a:	f104 0524 	add.w	r5, r4, #36	; 0x24
 800201e:	429d      	cmp	r5, r3
 8002020:	d007      	beq.n	8002032 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8002022:	681a      	ldr	r2, [r3, #0]
 8002024:	6262      	str	r2, [r4, #36]	; 0x24
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8002026:	4618      	mov	r0, r3
 8002028:	f7ff fbba 	bl	80017a0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 800202c:	6a63      	ldr	r3, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800202e:	42ab      	cmp	r3, r5
 8002030:	d1f7      	bne.n	8002022 <chThdExitS+0x12>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8002032:	7f63      	ldrb	r3, [r4, #29]
 8002034:	079b      	lsls	r3, r3, #30
 8002036:	d104      	bne.n	8002042 <chThdExitS+0x32>
    REG_REMOVE(tp);
 8002038:	6963      	ldr	r3, [r4, #20]
 800203a:	6922      	ldr	r2, [r4, #16]
 800203c:	611a      	str	r2, [r3, #16]
 800203e:	6922      	ldr	r2, [r4, #16]
 8002040:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8002042:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8002044:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8002048:	f7ff bb92 	b.w	8001770 <chSchGoSleepS>
 800204c:	200016a8 	.word	0x200016a8

08002050 <chSysPolledDelayX>:
 8002050:	4903      	ldr	r1, [pc, #12]	; (8002060 <chSysPolledDelayX+0x10>)
 8002052:	684a      	ldr	r2, [r1, #4]
 8002054:	684b      	ldr	r3, [r1, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
 8002056:	1a9b      	subs	r3, r3, r2
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8002058:	4298      	cmp	r0, r3
 800205a:	d8fb      	bhi.n	8002054 <chSysPolledDelayX+0x4>
  }
}
 800205c:	4770      	bx	lr
 800205e:	bf00      	nop
 8002060:	e0001000 	.word	0xe0001000
	...

08002070 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8002070:	e7fe      	b.n	8002070 <BusFault_Handler>
 8002072:	bf00      	nop
	...

08002080 <buttonInterupt.4223>:
    StartEXT(); /** EXT driver On agen **/
    }
}

/** button interupt universal **/
void buttonInterupt(){
 8002080:	b510      	push	{r4, lr}
 8002082:	2320      	movs	r3, #32
 8002084:	f383 8811 	msr	BASEPRI, r3
    static virtual_timer_t vt4;

    chSysLock();
        thread_t *ntp = tp_button;
 8002088:	4b13      	ldr	r3, [pc, #76]	; (80020d8 <buttonInterupt.4223+0x58>)
 800208a:	6818      	ldr	r0, [r3, #0]
        if(ntp){
 800208c:	b118      	cbz	r0, 8002096 <buttonInterupt.4223+0x16>
            tp_button = NULL;
 800208e:	2200      	movs	r2, #0
 8002090:	601a      	str	r2, [r3, #0]
            chSchWakeupS(ntp, MSG_OK);
 8002092:	f003 f97d 	bl	8005390 <chSchWakeupS.constprop.49>
 8002096:	2300      	movs	r3, #0
 8002098:	f383 8811 	msr	BASEPRI, r3
        }
        chSysUnlock();

  palSetPad(GPIOD, GPIOD_LED6);
 800209c:	4b0f      	ldr	r3, [pc, #60]	; (80020dc <buttonInterupt.4223+0x5c>)
 800209e:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 80020a2:	831a      	strh	r2, [r3, #24]
 80020a4:	2320      	movs	r3, #32
 80020a6:	f383 8811 	msr	BASEPRI, r3
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 80020aa:	4c0d      	ldr	r4, [pc, #52]	; (80020e0 <buttonInterupt.4223+0x60>)

  if (chVTIsArmedI(vtp)) {
 80020ac:	68e3      	ldr	r3, [r4, #12]
 80020ae:	b13b      	cbz	r3, 80020c0 <buttonInterupt.4223+0x40>
    chVTDoResetI(vtp);
 80020b0:	4620      	mov	r0, r4
 80020b2:	f001 fcb5 	bl	8003a20 <chVTDoResetI>
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 80020b6:	68e3      	ldr	r3, [r4, #12]
 80020b8:	b113      	cbz	r3, 80020c0 <buttonInterupt.4223+0x40>
    chVTDoResetI(vtp);
 80020ba:	4620      	mov	r0, r4
 80020bc:	f001 fcb0 	bl	8003a20 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 80020c0:	4807      	ldr	r0, [pc, #28]	; (80020e0 <buttonInterupt.4223+0x60>)
 80020c2:	4a08      	ldr	r2, [pc, #32]	; (80020e4 <buttonInterupt.4223+0x64>)
 80020c4:	f44f 61fa 	mov.w	r1, #2000	; 0x7d0
 80020c8:	2300      	movs	r3, #0
 80020ca:	f001 fe49 	bl	8003d60 <chVTDoSetI>
 80020ce:	2300      	movs	r3, #0
 80020d0:	f383 8811 	msr	BASEPRI, r3
 80020d4:	bd10      	pop	{r4, pc}
 80020d6:	bf00      	nop
 80020d8:	20002410 	.word	0x20002410
 80020dc:	40020c00 	.word	0x40020c00
 80020e0:	20000d24 	.word	0x20000d24
 80020e4:	08005231 	.word	0x08005231
	...

080020f0 <extcb0.15448>:
  chSysUnlockFromISR();
}

/* Triggered when the button is pressed or released. The PC0 pin ( cable blue 3P mode).*/
static void extcb0(EXTDriver *extp, expchannel_t channel) {
  button_ID = 0;
 80020f0:	4b02      	ldr	r3, [pc, #8]	; (80020fc <extcb0.15448+0xc>)
 80020f2:	2200      	movs	r2, #0
 80020f4:	601a      	str	r2, [r3, #0]
  buttonInterupt();
 80020f6:	f7ff bfc3 	b.w	8002080 <buttonInterupt.4223>
 80020fa:	bf00      	nop
 80020fc:	20002414 	.word	0x20002414

08002100 <extcb1.15444>:

}

/* Triggered when the button is pressed or released. The PC1 pin STOP MODE BUTTON */
static void extcb1(EXTDriver *extp, expchannel_t channel) {
  button_ID = 1;
 8002100:	4b02      	ldr	r3, [pc, #8]	; (800210c <extcb1.15444+0xc>)
 8002102:	2201      	movs	r2, #1
 8002104:	601a      	str	r2, [r3, #0]
  buttonInterupt();
 8002106:	f7ff bfbb 	b.w	8002080 <buttonInterupt.4223>
 800210a:	bf00      	nop
 800210c:	20002414 	.word	0x20002414

08002110 <extcb2.15440>:
}

/* Triggered when the button is pressed or released. The PC2 pin  BUTTON mode */
static void extcb2(EXTDriver *extp, expchannel_t channel) {
  button_ID = 2;
 8002110:	4b02      	ldr	r3, [pc, #8]	; (800211c <extcb2.15440+0xc>)
 8002112:	2202      	movs	r2, #2
 8002114:	601a      	str	r2, [r3, #0]
  buttonInterupt();
 8002116:	f7ff bfb3 	b.w	8002080 <buttonInterupt.4223>
 800211a:	bf00      	nop
 800211c:	20002414 	.word	0x20002414

08002120 <extcb3.15436>:
}

/* Triggered when the button is pressed or released. The PC3 pin  is set to ON.*/
static void extcb3(EXTDriver *extp, expchannel_t channel) {
  button_ID = 3;
 8002120:	4b02      	ldr	r3, [pc, #8]	; (800212c <extcb3.15436+0xc>)
 8002122:	2203      	movs	r2, #3
 8002124:	601a      	str	r2, [r3, #0]
  buttonInterupt();
 8002126:	f7ff bfab 	b.w	8002080 <buttonInterupt.4223>
 800212a:	bf00      	nop
 800212c:	20002414 	.word	0x20002414

08002130 <CanReadDATA.4386>:
 chSysUnlock();
// auto stop

}

CANRxFrameClone CanReadDATA(uint16_t FROM, uint16_t PID){
 8002130:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 //uint32_t Rdata = 8; // idejglenes tarolo

 SERVICES_ID_S = 0x1; // serveice ID Read mode
 DATA_LENGHT_RW_S = 2; // data length in read mode

 DEVICE_ID_S = FROM;  // from device
 8002132:	4e12      	ldr	r6, [pc, #72]	; (800217c <CanReadDATA.4386+0x4c>)

CANRxFrameClone CanReadDATA(uint16_t FROM, uint16_t PID){

 //uint32_t Rdata = 8; // idejglenes tarolo

 SERVICES_ID_S = 0x1; // serveice ID Read mode
 8002134:	4d12      	ldr	r5, [pc, #72]	; (8002180 <CanReadDATA.4386+0x50>)
 DATA_LENGHT_RW_S = 2; // data length in read mode
 8002136:	4c13      	ldr	r4, [pc, #76]	; (8002184 <CanReadDATA.4386+0x54>)

 DEVICE_ID_S = FROM;  // from device
 id_S = PID;          // form parameter ID
 8002138:	4b13      	ldr	r3, [pc, #76]	; (8002188 <CanReadDATA.4386+0x58>)
 //uint32_t Rdata = 8; // idejglenes tarolo

 SERVICES_ID_S = 0x1; // serveice ID Read mode
 DATA_LENGHT_RW_S = 2; // data length in read mode

 DEVICE_ID_S = FROM;  // from device
 800213a:	6031      	str	r1, [r6, #0]

CANRxFrameClone CanReadDATA(uint16_t FROM, uint16_t PID){

 //uint32_t Rdata = 8; // idejglenes tarolo

 SERVICES_ID_S = 0x1; // serveice ID Read mode
 800213c:	2701      	movs	r7, #1
 DATA_LENGHT_RW_S = 2; // data length in read mode
 800213e:	2102      	movs	r1, #2

 DEVICE_ID_S = FROM;  // from device
 id_S = PID;          // form parameter ID
 8002140:	801a      	strh	r2, [r3, #0]
 chSysUnlock();
// auto stop

}

CANRxFrameClone CanReadDATA(uint16_t FROM, uint16_t PID){
 8002142:	4606      	mov	r6, r0

 //uint32_t Rdata = 8; // idejglenes tarolo

 SERVICES_ID_S = 0x1; // serveice ID Read mode
 8002144:	602f      	str	r7, [r5, #0]
 DATA_LENGHT_RW_S = 2; // data length in read mode
 8002146:	6021      	str	r1, [r4, #0]
 8002148:	2320      	movs	r3, #32
 800214a:	f383 8811 	msr	BASEPRI, r3
 DEVICE_ID_S = FROM;  // from device
 id_S = PID;          // form parameter ID

// write data reqest
  chSysLock();
    thread_t *ntp = tp_S;
 800214e:	4b0f      	ldr	r3, [pc, #60]	; (800218c <CanReadDATA.4386+0x5c>)
 8002150:	6818      	ldr	r0, [r3, #0]
    if(ntp){
 8002152:	b118      	cbz	r0, 800215c <CanReadDATA.4386+0x2c>
        tp_S = NULL;
 8002154:	2200      	movs	r2, #0
 8002156:	601a      	str	r2, [r3, #0]
        chSchWakeupS(ntp, MSG_OK);
 8002158:	f003 f91a 	bl	8005390 <chSchWakeupS.constprop.49>
 800215c:	2300      	movs	r3, #0
 800215e:	f383 8811 	msr	BASEPRI, r3
    }
 chSysUnlock();

  chThdSleep(4000);
return texmex;
 8002162:	4d0b      	ldr	r5, [pc, #44]	; (8002190 <CanReadDATA.4386+0x60>)
        tp_S = NULL;
        chSchWakeupS(ntp, MSG_OK);
    }
 chSysUnlock();

  chThdSleep(4000);
 8002164:	f44f 607a 	mov.w	r0, #4000	; 0xfa0
 8002168:	f001 fe62 	bl	8003e30 <chThdSleep>
return texmex;
 800216c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 800216e:	4634      	mov	r4, r6
 8002170:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 8002172:	682b      	ldr	r3, [r5, #0]
 8002174:	6023      	str	r3, [r4, #0]

// start can reading
// ellenorzes

}
 8002176:	4630      	mov	r0, r6
 8002178:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800217a:	bf00      	nop
 800217c:	20000810 	.word	0x20000810
 8002180:	20000d00 	.word	0x20000d00
 8002184:	20000808 	.word	0x20000808
 8002188:	20000d0c 	.word	0x20000d0c
 800218c:	20000d10 	.word	0x20000d10
 8002190:	20000d44 	.word	0x20000d44
	...

080021a0 <can_rx.14916>:
/*
 * Receiver thread.
 */

static THD_WORKING_AREA(can_rx1_wa, 256);
static THD_FUNCTION(can_rx, p) {
 80021a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80021a4:	f8df b188 	ldr.w	fp, [pc, #392]	; 8002330 <can_rx.14916+0x190>
 80021a8:	4c5e      	ldr	r4, [pc, #376]	; (8002324 <can_rx.14916+0x184>)
 80021aa:	f8db 2018 	ldr.w	r2, [fp, #24]
  rxmsg.DLC = 7;


  (void)p;
  chRegSetThreadName("receiver");
  chEvtRegister(&cip->canp->rxfull_event, &el, 0);
 80021ae:	6801      	ldr	r1, [r0, #0]
 80021b0:	6194      	str	r4, [r2, #24]
/*
 * Receiver thread.
 */

static THD_WORKING_AREA(can_rx1_wa, 256);
static THD_FUNCTION(can_rx, p) {
 80021b2:	b091      	sub	sp, #68	; 0x44
  struct can_instance *cip = p;
  event_listener_t el;
  CANRxFrameClone rxmsg;
  rxmsg.DLC = 7;
 80021b4:	2207      	movs	r2, #7
 80021b6:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
 80021ba:	f362 0303 	bfi	r3, r2, #0, #4
 80021be:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
 80021c2:	f04f 0a20 	mov.w	sl, #32
 80021c6:	f38a 8811 	msr	BASEPRI, sl
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
 80021ca:	ab10      	add	r3, sp, #64	; 0x40
 80021cc:	698a      	ldr	r2, [r1, #24]
 80021ce:	f843 2d28 	str.w	r2, [r3, #-40]!
  esp->es_next     = elp;
  elp->el_listener = currp;
 80021d2:	f8db 2018 	ldr.w	r2, [fp, #24]
 80021d6:	9207      	str	r2, [sp, #28]
  elp->el_events   = events;
 80021d8:	2401      	movs	r4, #1
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 80021da:	f04f 30ff 	mov.w	r0, #4294967295
  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 80021de:	2200      	movs	r2, #0

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
  elp->el_listener = currp;
  elp->el_events   = events;
 80021e0:	9408      	str	r4, [sp, #32]
  elp->el_flags    = (eventflags_t)0;
  elp->el_wflags   = wflags;
 80021e2:	900a      	str	r0, [sp, #40]	; 0x28

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->el_next     = esp->es_next;
  esp->es_next     = elp;
 80021e4:	618b      	str	r3, [r1, #24]
  elp->el_listener = currp;
  elp->el_events   = events;
  elp->el_flags    = (eventflags_t)0;
 80021e6:	9209      	str	r2, [sp, #36]	; 0x24
 80021e8:	f382 8811 	msr	BASEPRI, r2
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 80021ec:	f8db 3018 	ldr.w	r3, [fp, #24]
 80021f0:	7f5b      	ldrb	r3, [r3, #29]

  (void)p;
  chRegSetThreadName("receiver");
  chEvtRegister(&cip->canp->rxfull_event, &el, 0);

  while(!chThdShouldTerminateX()){//(true){
 80021f2:	075c      	lsls	r4, r3, #29
 80021f4:	f100 8092 	bmi.w	800231c <can_rx.14916+0x17c>

  osalSysLock();
  osalDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
                "invalid state");
  /*lint -save -e9007 [13.5] Right side is supposed to be pure.*/
  while ((canp->state == CAN_SLEEP) || !can_lld_is_rx_nonempty(canp, mailbox)) {
 80021f8:	4c4b      	ldr	r4, [pc, #300]	; (8002328 <can_rx.14916+0x188>)
 80021fa:	e035      	b.n	8002268 <can_rx.14916+0xc8>
bool can_lld_is_rx_nonempty(CANDriver *canp, canmbx_t mailbox) {

  switch (mailbox) {
  case CAN_ANY_MAILBOX:
    return ((canp->can->RF0R & CAN_RF0R_FMP0) != 0 ||
            (canp->can->RF1R & CAN_RF1R_FMP1) != 0);
 80021fc:	691a      	ldr	r2, [r3, #16]
 */
bool can_lld_is_rx_nonempty(CANDriver *canp, canmbx_t mailbox) {

  switch (mailbox) {
  case CAN_ANY_MAILBOX:
    return ((canp->can->RF0R & CAN_RF0R_FMP0) != 0 ||
 80021fe:	0791      	lsls	r1, r2, #30
 8002200:	d13c      	bne.n	800227c <can_rx.14916+0xdc>
 8002202:	2300      	movs	r3, #0
 8002204:	f383 8811 	msr	BASEPRI, r3
  canReceive(&CAND1, CAN_ANY_MAILBOX, &rxmsg, TIME_IMMEDIATE);
  //canReceive(&CAND1, NULL , &rxmsg, TIME_IMMEDIATE);
    chThdSleepMilliseconds(100);
 8002208:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800220c:	f001 fe10 	bl	8003e30 <chThdSleep>
  texmex = rxmsg;
 8002210:	9d04      	ldr	r5, [sp, #16]
 8002212:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
 8002216:	f8ad 502e 	strh.w	r5, [sp, #46]	; 0x2e
 800221a:	9d05      	ldr	r5, [sp, #20]
 800221c:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
 8002220:	f365 0303 	bfi	r3, r5, #0, #4
 8002224:	9d03      	ldr	r5, [sp, #12]
 8002226:	4e41      	ldr	r6, [pc, #260]	; (800232c <can_rx.14916+0x18c>)
 8002228:	f365 1304 	bfi	r3, r5, #4, #1
 800222c:	f369 1345 	bfi	r3, r9, #5, #1
 8002230:	9d02      	ldr	r5, [sp, #8]
 8002232:	950e      	str	r5, [sp, #56]	; 0x38
 8002234:	f88d 3030 	strb.w	r3, [sp, #48]	; 0x30
 8002238:	af0b      	add	r7, sp, #44	; 0x2c
 800223a:	cf0f      	ldmia	r7!, {r0, r1, r2, r3}
 800223c:	c60f      	stmia	r6!, {r0, r1, r2, r3}
 800223e:	4635      	mov	r5, r6
  chThdSleepMilliseconds(100);
 8002240:	f44f 707a 	mov.w	r0, #1000	; 0x3e8

  while(!chThdShouldTerminateX()){//(true){
  canReceive(&CAND1, CAN_ANY_MAILBOX, &rxmsg, TIME_IMMEDIATE);
  //canReceive(&CAND1, NULL , &rxmsg, TIME_IMMEDIATE);
    chThdSleepMilliseconds(100);
  texmex = rxmsg;
 8002244:	f845 8910 	str.w	r8, [r5], #-16
 8002248:	9501      	str	r5, [sp, #4]
  chThdSleepMilliseconds(100);
 800224a:	f001 fdf1 	bl	8003e30 <chThdSleep>
  texmex = rxmsg;
 800224e:	f10d 0c2c 	add.w	ip, sp, #44	; 0x2c
 8002252:	f8db 5018 	ldr.w	r5, [fp, #24]
 8002256:	683f      	ldr	r7, [r7, #0]
 8002258:	6037      	str	r7, [r6, #0]
 800225a:	e8bc 000f 	ldmia.w	ip!, {r0, r1, r2, r3}
 800225e:	7f6f      	ldrb	r7, [r5, #29]
 8002260:	9d01      	ldr	r5, [sp, #4]

  (void)p;
  chRegSetThreadName("receiver");
  chEvtRegister(&cip->canp->rxfull_event, &el, 0);

  while(!chThdShouldTerminateX()){//(true){
 8002262:	077f      	lsls	r7, r7, #29
  canReceive(&CAND1, CAN_ANY_MAILBOX, &rxmsg, TIME_IMMEDIATE);
  //canReceive(&CAND1, NULL , &rxmsg, TIME_IMMEDIATE);
    chThdSleepMilliseconds(100);
  texmex = rxmsg;
  chThdSleepMilliseconds(100);
  texmex = rxmsg;
 8002264:	c50f      	stmia	r5!, {r0, r1, r2, r3}

  (void)p;
  chRegSetThreadName("receiver");
  chEvtRegister(&cip->canp->rxfull_event, &el, 0);

  while(!chThdShouldTerminateX()){//(true){
 8002266:	d459      	bmi.n	800231c <can_rx.14916+0x17c>
 8002268:	f38a 8811 	msr	BASEPRI, sl
 800226c:	482e      	ldr	r0, [pc, #184]	; (8002328 <can_rx.14916+0x188>)
 800226e:	7803      	ldrb	r3, [r0, #0]
 8002270:	2b04      	cmp	r3, #4
 8002272:	d0c6      	beq.n	8002202 <can_rx.14916+0x62>
 8002274:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002276:	68da      	ldr	r2, [r3, #12]
 8002278:	0790      	lsls	r0, r2, #30
 800227a:	d0bf      	beq.n	80021fc <can_rx.14916+0x5c>
                     canmbx_t mailbox,
                     CANRxFrame *crfp) {
  uint32_t rir, rdtr;

  if (mailbox == CAN_ANY_MAILBOX) {
    if ((canp->can->RF0R & CAN_RF0R_FMP0) != 0)
 800227c:	68da      	ldr	r2, [r3, #12]
 800227e:	0796      	lsls	r6, r2, #30
 8002280:	d027      	beq.n	80022d2 <can_rx.14916+0x132>
    }
  }
  switch (mailbox) {
  case 1:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[0].RIR;
 8002282:	f8d3 11b0 	ldr.w	r1, [r3, #432]	; 0x1b0
    rdtr = canp->can->sFIFOMailBox[0].RDTR;
 8002286:	f8d3 21b4 	ldr.w	r2, [r3, #436]	; 0x1b4
    crfp->data32[0] = canp->can->sFIFOMailBox[0].RDLR;
 800228a:	f8d3 51b8 	ldr.w	r5, [r3, #440]	; 0x1b8
    crfp->data32[1] = canp->can->sFIFOMailBox[0].RDHR;
 800228e:	f8d3 81bc 	ldr.w	r8, [r3, #444]	; 0x1bc

    /* Releases the mailbox.*/
    canp->can->RF0R = CAN_RF0R_RFOM0;
 8002292:	f8c3 a00c 	str.w	sl, [r3, #12]

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF0R & CAN_RF0R_FMP0) == 0)
 8002296:	68d8      	ldr	r0, [r3, #12]
  switch (mailbox) {
  case 1:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[0].RIR;
    rdtr = canp->can->sFIFOMailBox[0].RDTR;
    crfp->data32[0] = canp->can->sFIFOMailBox[0].RDLR;
 8002298:	9502      	str	r5, [sp, #8]
    /* Releases the mailbox.*/
    canp->can->RF0R = CAN_RF0R_RFOM0;

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF0R & CAN_RF0R_FMP0) == 0)
 800229a:	0780      	lsls	r0, r0, #30
 800229c:	d103      	bne.n	80022a6 <can_rx.14916+0x106>
      canp->can->IER |= CAN_IER_FMPIE0;
 800229e:	6958      	ldr	r0, [r3, #20]
 80022a0:	f040 0002 	orr.w	r0, r0, #2
 80022a4:	6158      	str	r0, [r3, #20]
    /* Should not happen, do nothing.*/
    return;
  }

  /* Decodes the various fields in the RX frame.*/
  crfp->RTR = (rir & CAN_RI0R_RTR) >> 1;
 80022a6:	f3c1 0540 	ubfx	r5, r1, #1, #1
  crfp->IDE = (rir & CAN_RI0R_IDE) >> 2;
 80022aa:	f3c1 0980 	ubfx	r9, r1, #2, #1
    /* Should not happen, do nothing.*/
    return;
  }

  /* Decodes the various fields in the RX frame.*/
  crfp->RTR = (rir & CAN_RI0R_RTR) >> 1;
 80022ae:	9503      	str	r5, [sp, #12]
  crfp->IDE = (rir & CAN_RI0R_IDE) >> 2;
  if (crfp->IDE)
 80022b0:	f1b9 0f00 	cmp.w	r9, #0
 80022b4:	d02a      	beq.n	800230c <can_rx.14916+0x16c>
    crfp->EID = rir >> 3;
 80022b6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80022b8:	08c9      	lsrs	r1, r1, #3
 80022ba:	f361 031c 	bfi	r3, r1, #0, #29
 80022be:	930d      	str	r3, [sp, #52]	; 0x34
  else
    crfp->SID = rir >> 21;
  crfp->DLC = rdtr & CAN_RDT0R_DLC;
  crfp->FMI = (uint8_t)(rdtr >> 8);
 80022c0:	0a13      	lsrs	r3, r2, #8
  crfp->IDE = (rir & CAN_RI0R_IDE) >> 2;
  if (crfp->IDE)
    crfp->EID = rir >> 3;
  else
    crfp->SID = rir >> 21;
  crfp->DLC = rdtr & CAN_RDT0R_DLC;
 80022c2:	f002 050f 	and.w	r5, r2, #15
  crfp->FMI = (uint8_t)(rdtr >> 8);
  crfp->TIME = (uint16_t)(rdtr >> 16);
 80022c6:	0c12      	lsrs	r2, r2, #16
  if (crfp->IDE)
    crfp->EID = rir >> 3;
  else
    crfp->SID = rir >> 21;
  crfp->DLC = rdtr & CAN_RDT0R_DLC;
  crfp->FMI = (uint8_t)(rdtr >> 8);
 80022c8:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
  crfp->IDE = (rir & CAN_RI0R_IDE) >> 2;
  if (crfp->IDE)
    crfp->EID = rir >> 3;
  else
    crfp->SID = rir >> 21;
  crfp->DLC = rdtr & CAN_RDT0R_DLC;
 80022cc:	9505      	str	r5, [sp, #20]
  crfp->FMI = (uint8_t)(rdtr >> 8);
  crfp->TIME = (uint16_t)(rdtr >> 16);
 80022ce:	9204      	str	r2, [sp, #16]
 80022d0:	e797      	b.n	8002202 <can_rx.14916+0x62>
  uint32_t rir, rdtr;

  if (mailbox == CAN_ANY_MAILBOX) {
    if ((canp->can->RF0R & CAN_RF0R_FMP0) != 0)
      mailbox = 1;
    else if ((canp->can->RF1R & CAN_RF1R_FMP1) != 0)
 80022d2:	691a      	ldr	r2, [r3, #16]
 80022d4:	0792      	lsls	r2, r2, #30
 80022d6:	d094      	beq.n	8002202 <can_rx.14916+0x62>
    if ((canp->can->RF0R & CAN_RF0R_FMP0) == 0)
      canp->can->IER |= CAN_IER_FMPIE0;
    break;
  case 2:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[1].RIR;
 80022d8:	f8d3 11c0 	ldr.w	r1, [r3, #448]	; 0x1c0
    rdtr = canp->can->sFIFOMailBox[1].RDTR;
 80022dc:	f8d3 21c4 	ldr.w	r2, [r3, #452]	; 0x1c4
    crfp->data32[0] = canp->can->sFIFOMailBox[1].RDLR;
 80022e0:	f8d3 51c8 	ldr.w	r5, [r3, #456]	; 0x1c8
    crfp->data32[1] = canp->can->sFIFOMailBox[1].RDHR;
 80022e4:	f8d3 81cc 	ldr.w	r8, [r3, #460]	; 0x1cc

    /* Releases the mailbox.*/
    canp->can->RF1R = CAN_RF1R_RFOM1;
 80022e8:	f8c3 a010 	str.w	sl, [r3, #16]

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF1R & CAN_RF1R_FMP1) == 0)
 80022ec:	6918      	ldr	r0, [r3, #16]
    break;
  case 2:
    /* Fetches the message.*/
    rir  = canp->can->sFIFOMailBox[1].RIR;
    rdtr = canp->can->sFIFOMailBox[1].RDTR;
    crfp->data32[0] = canp->can->sFIFOMailBox[1].RDLR;
 80022ee:	9502      	str	r5, [sp, #8]
    /* Releases the mailbox.*/
    canp->can->RF1R = CAN_RF1R_RFOM1;

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF1R & CAN_RF1R_FMP1) == 0)
 80022f0:	0785      	lsls	r5, r0, #30
 80022f2:	d1d8      	bne.n	80022a6 <can_rx.14916+0x106>
      canp->can->IER |= CAN_IER_FMPIE1;
 80022f4:	6958      	ldr	r0, [r3, #20]
    /* Should not happen, do nothing.*/
    return;
  }

  /* Decodes the various fields in the RX frame.*/
  crfp->RTR = (rir & CAN_RI0R_RTR) >> 1;
 80022f6:	f3c1 0540 	ubfx	r5, r1, #1, #1
    canp->can->RF1R = CAN_RF1R_RFOM1;

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF1R & CAN_RF1R_FMP1) == 0)
      canp->can->IER |= CAN_IER_FMPIE1;
 80022fa:	f040 0010 	orr.w	r0, r0, #16
    return;
  }

  /* Decodes the various fields in the RX frame.*/
  crfp->RTR = (rir & CAN_RI0R_RTR) >> 1;
  crfp->IDE = (rir & CAN_RI0R_IDE) >> 2;
 80022fe:	f3c1 0980 	ubfx	r9, r1, #2, #1
    canp->can->RF1R = CAN_RF1R_RFOM1;

    /* If the queue is empty re-enables the interrupt in order to generate
       events again.*/
    if ((canp->can->RF1R & CAN_RF1R_FMP1) == 0)
      canp->can->IER |= CAN_IER_FMPIE1;
 8002302:	6158      	str	r0, [r3, #20]
    /* Should not happen, do nothing.*/
    return;
  }

  /* Decodes the various fields in the RX frame.*/
  crfp->RTR = (rir & CAN_RI0R_RTR) >> 1;
 8002304:	9503      	str	r5, [sp, #12]
  crfp->IDE = (rir & CAN_RI0R_IDE) >> 2;
  if (crfp->IDE)
 8002306:	f1b9 0f00 	cmp.w	r9, #0
 800230a:	d1d4      	bne.n	80022b6 <can_rx.14916+0x116>
    crfp->EID = rir >> 3;
  else
    crfp->SID = rir >> 21;
 800230c:	f8bd 3034 	ldrh.w	r3, [sp, #52]	; 0x34
 8002310:	0d49      	lsrs	r1, r1, #21
 8002312:	f361 030a 	bfi	r3, r1, #0, #11
 8002316:	f8ad 3034 	strh.w	r3, [sp, #52]	; 0x34
 800231a:	e7d1      	b.n	80022c0 <can_rx.14916+0x120>
  //chprintf(&SDU3, "%X\r\n",rxdata);
  //rxdata = 0x12345678;
  //chThdSleepMilliseconds(100);

  }
}
 800231c:	b011      	add	sp, #68	; 0x44
 800231e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002322:	bf00      	nop
 8002324:	08006c80 	.word	0x08006c80
 8002328:	20000d58 	.word	0x20000d58
 800232c:	20000d44 	.word	0x20000d44
 8002330:	200016a8 	.word	0x200016a8
	...

08002340 <Thread1.16339>:
/* Initialization and main thread.                                           */
/*===========================================================================*/

/**  life blinking hello word task **/
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8002340:	b508      	push	{r3, lr}
 8002342:	4b13      	ldr	r3, [pc, #76]	; (8002390 <Thread1.16339+0x50>)
 8002344:	4a13      	ldr	r2, [pc, #76]	; (8002394 <Thread1.16339+0x54>)
 8002346:	699b      	ldr	r3, [r3, #24]

  chRegSetThreadName("ON");

    while(true){
        pwmEnableChannel(&PWMD4, 2, 255);
        palSetPad(GPIOE, 8);
 8002348:	4d13      	ldr	r5, [pc, #76]	; (8002398 <Thread1.16339+0x58>)
 800234a:	619a      	str	r2, [r3, #24]
 800234c:	f44f 7480 	mov.w	r4, #256	; 0x100
  (void)arg;

  chRegSetThreadName("ON");

    while(true){
        pwmEnableChannel(&PWMD4, 2, 255);
 8002350:	4812      	ldr	r0, [pc, #72]	; (800239c <Thread1.16339+0x5c>)
 8002352:	2102      	movs	r1, #2
 8002354:	22ff      	movs	r2, #255	; 0xff
 8002356:	f003 fa83 	bl	8005860 <pwmEnableChannel>
        palSetPad(GPIOE, 8);
        pwmEnableChannel(&PWMD1, 0, 600);
 800235a:	2100      	movs	r1, #0
 800235c:	f44f 7216 	mov.w	r2, #600	; 0x258

  chRegSetThreadName("ON");

    while(true){
        pwmEnableChannel(&PWMD4, 2, 255);
        palSetPad(GPIOE, 8);
 8002360:	832c      	strh	r4, [r5, #24]
        pwmEnableChannel(&PWMD1, 0, 600);
 8002362:	480f      	ldr	r0, [pc, #60]	; (80023a0 <Thread1.16339+0x60>)
 8002364:	f003 fa7c 	bl	8005860 <pwmEnableChannel>

        chThdSleep(1000);
 8002368:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800236c:	f001 fd60 	bl	8003e30 <chThdSleep>

        pwmEnableChannel(&PWMD4, 2, 0);
 8002370:	480a      	ldr	r0, [pc, #40]	; (800239c <Thread1.16339+0x5c>)
 8002372:	2102      	movs	r1, #2
 8002374:	2200      	movs	r2, #0
 8002376:	f003 fa73 	bl	8005860 <pwmEnableChannel>

        pwmEnableChannel(&PWMD1, 0, 0);
 800237a:	2100      	movs	r1, #0
 800237c:	460a      	mov	r2, r1
 800237e:	4808      	ldr	r0, [pc, #32]	; (80023a0 <Thread1.16339+0x60>)
 8002380:	f003 fa6e 	bl	8005860 <pwmEnableChannel>
        palClearPad(GPIOE, 8);
 8002384:	836c      	strh	r4, [r5, #26]

        chThdSleep(1000);
 8002386:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800238a:	f001 fd51 	bl	8003e30 <chThdSleep>
 800238e:	e7dd      	b.n	800234c <Thread1.16339+0xc>
 8002390:	200016a8 	.word	0x200016a8
 8002394:	08006c8c 	.word	0x08006c8c
 8002398:	40021000 	.word	0x40021000
 800239c:	20001bec 	.word	0x20001bec
 80023a0:	20001bd0 	.word	0x20001bd0
	...

080023b0 <cmd_pid.16113>:
     chprintf(chp, "INT: %d\n\n\r", CanReadInt(DEVICE_ID,id));
     chprintf(chp, "RX_CAN: %X %X %X\n\n\r",rxidd ,rxd,rxd2);
    return f;
}

static void cmd_pid(BaseSequentialStream *chp, int argc, char *argv[]) {
 80023b0:	b510      	push	{r4, lr}

  uint8_t u[5];
  (void)argv;
  if (argc > 0) {
 80023b2:	2900      	cmp	r1, #0
     chprintf(chp, "INT: %d\n\n\r", CanReadInt(DEVICE_ID,id));
     chprintf(chp, "RX_CAN: %X %X %X\n\n\r",rxidd ,rxd,rxd2);
    return f;
}

static void cmd_pid(BaseSequentialStream *chp, int argc, char *argv[]) {
 80023b4:	b082      	sub	sp, #8
 80023b6:	4604      	mov	r4, r0

  uint8_t u[5];
  (void)argv;
  if (argc > 0) {
 80023b8:	dd04      	ble.n	80023c4 <cmd_pid.16113+0x14>
    chprintf(chp, "id\r\n");
 80023ba:	4910      	ldr	r1, [pc, #64]	; (80023fc <cmd_pid.16113+0x4c>)
 80023bc:	f003 f840 	bl	8005440 <chprintf.16065>
               chprintf(chp, "ID_int:--%d--\r\n",id);

               chThdSleep(10000);
               return 1;
    }
}
 80023c0:	b002      	add	sp, #8
 80023c2:	bd10      	pop	{r4, pc}
  if (argc > 0) {
    chprintf(chp, "id\r\n");
    return;
  }
    while(true){
               chprintf(chp,"Pleas ID:\r\n");
 80023c4:	490e      	ldr	r1, [pc, #56]	; (8002400 <cmd_pid.16113+0x50>)
 80023c6:	f003 f83b 	bl	8005440 <chprintf.16065>

               chSequentialStreamRead(serial,&u,6);
 80023ca:	4b0e      	ldr	r3, [pc, #56]	; (8002404 <cmd_pid.16113+0x54>)
 80023cc:	6818      	ldr	r0, [r3, #0]
 80023ce:	6803      	ldr	r3, [r0, #0]
 80023d0:	4669      	mov	r1, sp
 80023d2:	685b      	ldr	r3, [r3, #4]
 80023d4:	2206      	movs	r2, #6
 80023d6:	4798      	blx	r3
               //chprintf(chp, "ID:--%s--\r\n",u);
               id = atoi(u);
 80023d8:	4668      	mov	r0, sp
 80023da:	f004 fba1 	bl	8006b20 <atoi>
 80023de:	4b0a      	ldr	r3, [pc, #40]	; (8002408 <cmd_pid.16113+0x58>)
               chprintf(chp, "ID_int:--%d--\r\n",id);
 80023e0:	490a      	ldr	r1, [pc, #40]	; (800240c <cmd_pid.16113+0x5c>)
    while(true){
               chprintf(chp,"Pleas ID:\r\n");

               chSequentialStreamRead(serial,&u,6);
               //chprintf(chp, "ID:--%s--\r\n",u);
               id = atoi(u);
 80023e2:	8018      	strh	r0, [r3, #0]
 80023e4:	4602      	mov	r2, r0
               chprintf(chp, "ID_int:--%d--\r\n",id);
 80023e6:	b292      	uxth	r2, r2
 80023e8:	4620      	mov	r0, r4
 80023ea:	f003 f829 	bl	8005440 <chprintf.16065>

               chThdSleep(10000);
 80023ee:	f242 7010 	movw	r0, #10000	; 0x2710
 80023f2:	f001 fd1d 	bl	8003e30 <chThdSleep>
               return 1;
    }
}
 80023f6:	b002      	add	sp, #8
 80023f8:	bd10      	pop	{r4, pc}
 80023fa:	bf00      	nop
 80023fc:	08006c90 	.word	0x08006c90
 8002400:	08006c98 	.word	0x08006c98
 8002404:	200008c4 	.word	0x200008c4
 8002408:	20000d14 	.word	0x20000d14
 800240c:	08006ca4 	.word	0x08006ca4

08002410 <cmd_pad.16121>:

static void cmd_pad(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002410:	b510      	push	{r4, lr}

  uint8_t u[4];
  //uint16_t id;

  (void)argv;
  if (argc > 0) {
 8002412:	2900      	cmp	r1, #0
               chThdSleep(10000);
               return 1;
    }
}

static void cmd_pad(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002414:	b082      	sub	sp, #8

  uint8_t u[4];
  //uint16_t id;

  (void)argv;
  if (argc > 0) {
 8002416:	dd04      	ble.n	8002422 <cmd_pad.16121+0x12>
    chprintf(chp, "id\n\r");
 8002418:	4914      	ldr	r1, [pc, #80]	; (800246c <cmd_pad.16121+0x5c>)
 800241a:	f003 f811 	bl	8005440 <chprintf.16065>
               //chprintf(chp, "char:-%s-\n\n\r",u);
               CanWriteDATA(DEVICE_ID,id,data);
               chThdSleep(1000);
               return 1;
    }
}
 800241e:	b002      	add	sp, #8
 8002420:	bd10      	pop	{r4, pc}
    return;
  }
    while(true){
               chprintf(chp, "Pleas DATA:\n\r");

               chSequentialStreamRead(serial,&u,5);
 8002422:	4c13      	ldr	r4, [pc, #76]	; (8002470 <cmd_pad.16121+0x60>)
  if (argc > 0) {
    chprintf(chp, "id\n\r");
    return;
  }
    while(true){
               chprintf(chp, "Pleas DATA:\n\r");
 8002424:	4913      	ldr	r1, [pc, #76]	; (8002474 <cmd_pad.16121+0x64>)
 8002426:	f003 f80b 	bl	8005440 <chprintf.16065>

               chSequentialStreamRead(serial,&u,5);
 800242a:	6820      	ldr	r0, [r4, #0]
 800242c:	6803      	ldr	r3, [r0, #0]
 800242e:	a901      	add	r1, sp, #4
 8002430:	685b      	ldr	r3, [r3, #4]
 8002432:	2205      	movs	r2, #5
 8002434:	4798      	blx	r3


                int ia = atoi(u);
 8002436:	a801      	add	r0, sp, #4
 8002438:	f004 fb72 	bl	8006b20 <atoi>
                f = (float ) ia;
 800243c:	f7fe fc32 	bl	8000ca4 <__aeabi_i2f>
 8002440:	4a0d      	ldr	r2, [pc, #52]	; (8002478 <cmd_pad.16121+0x68>)
                uint32_t data;
               //chprintf(serial, "int: %d\r\n",ia);
               //STdata = *(unsigned*)&f;
               data = *(unsigned*)&f;
               chprintf(serial, "value: %x\r\n",data);
 8002442:	490e      	ldr	r1, [pc, #56]	; (800247c <cmd_pad.16121+0x6c>)

               chSequentialStreamRead(serial,&u,5);


                int ia = atoi(u);
                f = (float ) ia;
 8002444:	4603      	mov	r3, r0
 8002446:	6013      	str	r3, [r2, #0]
                uint32_t data;
               //chprintf(serial, "int: %d\r\n",ia);
               //STdata = *(unsigned*)&f;
               data = *(unsigned*)&f;
               chprintf(serial, "value: %x\r\n",data);
 8002448:	6820      	ldr	r0, [r4, #0]
 800244a:	461a      	mov	r2, r3
 800244c:	461c      	mov	r4, r3
 800244e:	f002 fff7 	bl	8005440 <chprintf.16065>
               //chprintf(chp, "char:-%s-\n\n\r",u);
               CanWriteDATA(DEVICE_ID,id,data);
 8002452:	4b0b      	ldr	r3, [pc, #44]	; (8002480 <cmd_pad.16121+0x70>)
 8002454:	4a0b      	ldr	r2, [pc, #44]	; (8002484 <cmd_pad.16121+0x74>)
 8002456:	8819      	ldrh	r1, [r3, #0]
 8002458:	6810      	ldr	r0, [r2, #0]
 800245a:	4622      	mov	r2, r4
 800245c:	f001 ff50 	bl	8004300 <CanWriteDATA>
               chThdSleep(1000);
 8002460:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002464:	f001 fce4 	bl	8003e30 <chThdSleep>
               return 1;
    }
}
 8002468:	b002      	add	sp, #8
 800246a:	bd10      	pop	{r4, pc}
 800246c:	08006cb4 	.word	0x08006cb4
 8002470:	200008c4 	.word	0x200008c4
 8002474:	08006cbc 	.word	0x08006cbc
 8002478:	20000814 	.word	0x20000814
 800247c:	08006ccc 	.word	0x08006ccc
 8002480:	20000d14 	.word	0x20000d14
 8002484:	2000080c 	.word	0x2000080c
	...

08002490 <cmd_temp.16129>:


static void cmd_temp(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8002490:	2900      	cmp	r1, #0
  }
  chThdWait(tp);
}


static void cmd_temp(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002492:	b510      	push	{r4, lr}
 8002494:	4604      	mov	r4, r0

  (void)argv;
  if (argc > 0) {
 8002496:	dd04      	ble.n	80024a2 <cmd_temp.16129+0x12>
    chprintf(chp, "temp\r\n");
 8002498:	491a      	ldr	r1, [pc, #104]	; (8002504 <cmd_temp.16129+0x74>)
               chprintf(chp,"%d\r\n\n", oro());

               chThdSleep(10000);
               return f;
    }
}
 800249a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

static void cmd_temp(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
    chprintf(chp, "temp\r\n");
 800249e:	f002 bfcf 	b.w	8005440 <chprintf.16065>
    return;
  }
    while(true){
               chprintf(chp, "SENSOR_1: %d\r\n",getAktTemp(1));
 80024a2:	2001      	movs	r0, #1
 80024a4:	f003 f8fc 	bl	80056a0 <getAktTemp>
 80024a8:	4917      	ldr	r1, [pc, #92]	; (8002508 <cmd_temp.16129+0x78>)
 80024aa:	4602      	mov	r2, r0
 80024ac:	4620      	mov	r0, r4
 80024ae:	f002 ffc7 	bl	8005440 <chprintf.16065>
               chprintf(chp, "SENSOR_2: %d\r\n",getAktTemp(2));
 80024b2:	2002      	movs	r0, #2
 80024b4:	f003 f8f4 	bl	80056a0 <getAktTemp>
 80024b8:	4914      	ldr	r1, [pc, #80]	; (800250c <cmd_temp.16129+0x7c>)
 80024ba:	4602      	mov	r2, r0
 80024bc:	4620      	mov	r0, r4
 80024be:	f002 ffbf 	bl	8005440 <chprintf.16065>
               chprintf(chp, "SENSOR_3: %d\r\n",getAktTemp(3));
 80024c2:	2003      	movs	r0, #3
 80024c4:	f003 f8ec 	bl	80056a0 <getAktTemp>
 80024c8:	4911      	ldr	r1, [pc, #68]	; (8002510 <cmd_temp.16129+0x80>)
 80024ca:	4602      	mov	r2, r0
 80024cc:	4620      	mov	r0, r4
 80024ce:	f002 ffb7 	bl	8005440 <chprintf.16065>
//chThdSleep(100);

}

int allertlevel(void){
return alert;
 80024d2:	4b10      	ldr	r3, [pc, #64]	; (8002514 <cmd_temp.16129+0x84>)
               chprintf(chp,"alarm: %d\r\n", allertlevel());
 80024d4:	4910      	ldr	r1, [pc, #64]	; (8002518 <cmd_temp.16129+0x88>)
 80024d6:	681a      	ldr	r2, [r3, #0]
 80024d8:	4620      	mov	r0, r4
 80024da:	f002 ffb1 	bl	8005440 <chprintf.16065>

}

int hitemplevel(void){
return hiteup;
 80024de:	4b0f      	ldr	r3, [pc, #60]	; (800251c <cmd_temp.16129+0x8c>)
               chprintf(chp,"hightemp: %d\r\n\n", hitemplevel());
 80024e0:	490f      	ldr	r1, [pc, #60]	; (8002520 <cmd_temp.16129+0x90>)
 80024e2:	781a      	ldrb	r2, [r3, #0]
 80024e4:	4620      	mov	r0, r4
 80024e6:	f002 ffab 	bl	8005440 <chprintf.16065>
}

int oro(void){

return originCurrent;
 80024ea:	4b0e      	ldr	r3, [pc, #56]	; (8002524 <cmd_temp.16129+0x94>)
               chprintf(chp,"%d\r\n\n", oro());
 80024ec:	490e      	ldr	r1, [pc, #56]	; (8002528 <cmd_temp.16129+0x98>)
 80024ee:	681a      	ldr	r2, [r3, #0]
 80024f0:	4620      	mov	r0, r4
 80024f2:	f002 ffa5 	bl	8005440 <chprintf.16065>

               chThdSleep(10000);
 80024f6:	f242 7010 	movw	r0, #10000	; 0x2710
               return f;
    }
}
 80024fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
               chprintf(chp, "SENSOR_3: %d\r\n",getAktTemp(3));
               chprintf(chp,"alarm: %d\r\n", allertlevel());
               chprintf(chp,"hightemp: %d\r\n\n", hitemplevel());
               chprintf(chp,"%d\r\n\n", oro());

               chThdSleep(10000);
 80024fe:	f001 bc97 	b.w	8003e30 <chThdSleep>
 8002502:	bf00      	nop
 8002504:	08006cd8 	.word	0x08006cd8
 8002508:	08006ce0 	.word	0x08006ce0
 800250c:	08006cf0 	.word	0x08006cf0
 8002510:	08006d00 	.word	0x08006d00
 8002514:	20002688 	.word	0x20002688
 8002518:	08006d10 	.word	0x08006d10
 800251c:	20002670 	.word	0x20002670
 8002520:	08006d1c 	.word	0x08006d1c
 8002524:	2000084c 	.word	0x2000084c
 8002528:	08006d2c 	.word	0x08006d2c
 800252c:	00000000 	.word	0x00000000

08002530 <ThCanSend.14919>:

return tempi;
}

static THD_WORKING_AREA(waThCanSend, 256);
static THD_FUNCTION(ThCanSend, arg) {
 8002530:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8002534:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 800262c <ThCanSend.14919+0xfc>
 8002538:	4c36      	ldr	r4, [pc, #216]	; (8002614 <ThCanSend.14919+0xe4>)
 800253a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800253e:	4a36      	ldr	r2, [pc, #216]	; (8002618 <ThCanSend.14919+0xe8>)
 8002540:	f8df b0ec 	ldr.w	fp, [pc, #236]	; 8002630 <ThCanSend.14919+0x100>
 8002544:	4e35      	ldr	r6, [pc, #212]	; (800261c <ThCanSend.14919+0xec>)
 8002546:	f8df a0ec 	ldr.w	sl, [pc, #236]	; 8002634 <ThCanSend.14919+0x104>
 800254a:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 8002638 <ThCanSend.14919+0x108>
 800254e:	619a      	str	r2, [r3, #24]
 8002550:	b085      	sub	sp, #20

  osalSysLock();
  osalDbgAssert((canp->state == CAN_READY) || (canp->state == CAN_SLEEP),
                "invalid state");
  /*lint -save -e9007 [13.5] Right side is supposed to be pure.*/
  while ((canp->state == CAN_SLEEP) || !can_lld_is_tx_empty(canp, mailbox)) {
 8002552:	4625      	mov	r5, r4

  while (true){



    chThdSleepMilliseconds(500);//?
 8002554:	f241 3088 	movw	r0, #5000	; 0x1388
 8002558:	f001 fc6a 	bl	8003e30 <chThdSleep>
            txmsg.data8[3] = STdata_S >> 24;    /** data shift 32bit ot 4 section **/
            txmsg.data8[4] = STdata_S >> 16;
            txmsg.data8[5] = STdata_S >> 8;
            txmsg.data8[6] = STdata_S >> 0;

            ST_ID = (DEVICE_ID_S << 19) | (MY_ID << 9) | (SERVICES_ID_S << 6) | FLAG; /**Studer iD  creation **/
 800255c:	f8d9 0000 	ldr.w	r0, [r9]
 8002560:	f8da 1000 	ldr.w	r1, [sl]



    chThdSleepMilliseconds(500);//?

            txmsg.data8[0] = id_S >> 8;  /**chop the 2HEX to 2 1Hex **/
 8002564:	f8bb 2000 	ldrh.w	r2, [fp]
            txmsg.data8[5] = STdata_S >> 8;
            txmsg.data8[6] = STdata_S >> 0;

            ST_ID = (DEVICE_ID_S << 19) | (MY_ID << 9) | (SERVICES_ID_S << 6) | FLAG; /**Studer iD  creation **/

            txmsg.EID = ST_ID;                                                        /** Studer ID add tha CAN ID Structure**/
 8002568:	9b01      	ldr	r3, [sp, #4]
    chThdSleepMilliseconds(500);//?

            txmsg.data8[0] = id_S >> 8;  /**chop the 2HEX to 2 1Hex **/
            txmsg.data8[1] = id_S >> 0;

            txmsg.data8[3] = STdata_S >> 24;    /** data shift 32bit ot 4 section **/
 800256a:	6837      	ldr	r7, [r6, #0]


    chThdSleepMilliseconds(500);//?

            txmsg.data8[0] = id_S >> 8;  /**chop the 2HEX to 2 1Hex **/
            txmsg.data8[1] = id_S >> 0;
 800256c:	f88d 2009 	strb.w	r2, [sp, #9]
            txmsg.data8[3] = STdata_S >> 24;    /** data shift 32bit ot 4 section **/
            txmsg.data8[4] = STdata_S >> 16;
            txmsg.data8[5] = STdata_S >> 8;
            txmsg.data8[6] = STdata_S >> 0;

            ST_ID = (DEVICE_ID_S << 19) | (MY_ID << 9) | (SERVICES_ID_S << 6) | FLAG; /**Studer iD  creation **/
 8002570:	ea4f 1e80 	mov.w	lr, r0, lsl #6
 8002574:	ea4e 4ec1 	orr.w	lr, lr, r1, lsl #19

            txmsg.data8[0] = id_S >> 8;  /**chop the 2HEX to 2 1Hex **/
            txmsg.data8[1] = id_S >> 0;

            txmsg.data8[3] = STdata_S >> 24;    /** data shift 32bit ot 4 section **/
            txmsg.data8[4] = STdata_S >> 16;
 8002578:	6830      	ldr	r0, [r6, #0]
            txmsg.data8[5] = STdata_S >> 8;
 800257a:	6831      	ldr	r1, [r6, #0]
            txmsg.data8[6] = STdata_S >> 0;

            ST_ID = (DEVICE_ID_S << 19) | (MY_ID << 9) | (SERVICES_ID_S << 6) | FLAG; /**Studer iD  creation **/
 800257c:	f44e 3ebb 	orr.w	lr, lr, #95744	; 0x17600



    chThdSleepMilliseconds(500);//?

            txmsg.data8[0] = id_S >> 8;  /**chop the 2HEX to 2 1Hex **/
 8002580:	0a12      	lsrs	r2, r2, #8
            txmsg.data8[5] = STdata_S >> 8;
            txmsg.data8[6] = STdata_S >> 0;

            ST_ID = (DEVICE_ID_S << 19) | (MY_ID << 9) | (SERVICES_ID_S << 6) | FLAG; /**Studer iD  creation **/

            txmsg.EID = ST_ID;                                                        /** Studer ID add tha CAN ID Structure**/
 8002582:	f36e 031c 	bfi	r3, lr, #0, #29



    chThdSleepMilliseconds(500);//?

            txmsg.data8[0] = id_S >> 8;  /**chop the 2HEX to 2 1Hex **/
 8002586:	f88d 2008 	strb.w	r2, [sp, #8]
            txmsg.data8[6] = STdata_S >> 0;

            ST_ID = (DEVICE_ID_S << 19) | (MY_ID << 9) | (SERVICES_ID_S << 6) | FLAG; /**Studer iD  creation **/

            txmsg.EID = ST_ID;                                                        /** Studer ID add tha CAN ID Structure**/
            txmsg.DLC = DATA_LENGHT_RW_S;                                             /** Data Lenght add the CAN Data lenght**/
 800258a:	4a25      	ldr	r2, [pc, #148]	; (8002620 <ThCanSend.14919+0xf0>)
            txmsg.data8[5] = STdata_S >> 8;
            txmsg.data8[6] = STdata_S >> 0;

            ST_ID = (DEVICE_ID_S << 19) | (MY_ID << 9) | (SERVICES_ID_S << 6) | FLAG; /**Studer iD  creation **/

            txmsg.EID = ST_ID;                                                        /** Studer ID add tha CAN ID Structure**/
 800258c:	9301      	str	r3, [sp, #4]
    chThdSleepMilliseconds(500);//?

            txmsg.data8[0] = id_S >> 8;  /**chop the 2HEX to 2 1Hex **/
            txmsg.data8[1] = id_S >> 0;

            txmsg.data8[3] = STdata_S >> 24;    /** data shift 32bit ot 4 section **/
 800258e:	0e3f      	lsrs	r7, r7, #24
            txmsg.data8[4] = STdata_S >> 16;
            txmsg.data8[5] = STdata_S >> 8;
            txmsg.data8[6] = STdata_S >> 0;
 8002590:	6833      	ldr	r3, [r6, #0]
    chThdSleepMilliseconds(500);//?

            txmsg.data8[0] = id_S >> 8;  /**chop the 2HEX to 2 1Hex **/
            txmsg.data8[1] = id_S >> 0;

            txmsg.data8[3] = STdata_S >> 24;    /** data shift 32bit ot 4 section **/
 8002592:	f88d 700b 	strb.w	r7, [sp, #11]
            txmsg.data8[4] = STdata_S >> 16;
 8002596:	0c00      	lsrs	r0, r0, #16
            txmsg.data8[5] = STdata_S >> 8;
 8002598:	0a09      	lsrs	r1, r1, #8
            txmsg.data8[6] = STdata_S >> 0;
 800259a:	f88d 300e 	strb.w	r3, [sp, #14]

            txmsg.data8[0] = id_S >> 8;  /**chop the 2HEX to 2 1Hex **/
            txmsg.data8[1] = id_S >> 0;

            txmsg.data8[3] = STdata_S >> 24;    /** data shift 32bit ot 4 section **/
            txmsg.data8[4] = STdata_S >> 16;
 800259e:	f88d 000c 	strb.w	r0, [sp, #12]
            txmsg.data8[5] = STdata_S >> 8;
 80025a2:	f88d 100d 	strb.w	r1, [sp, #13]
            txmsg.data8[6] = STdata_S >> 0;

            ST_ID = (DEVICE_ID_S << 19) | (MY_ID << 9) | (SERVICES_ID_S << 6) | FLAG; /**Studer iD  creation **/

            txmsg.EID = ST_ID;                                                        /** Studer ID add tha CAN ID Structure**/
            txmsg.DLC = DATA_LENGHT_RW_S;                                             /** Data Lenght add the CAN Data lenght**/
 80025a6:	6817      	ldr	r7, [r2, #0]
 80025a8:	2320      	movs	r3, #32
 80025aa:	f383 8811 	msr	BASEPRI, r3
 80025ae:	7823      	ldrb	r3, [r4, #0]
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 80025b0:	481c      	ldr	r0, [pc, #112]	; (8002624 <ThCanSend.14919+0xf4>)
 80025b2:	2b04      	cmp	r3, #4
 80025b4:	f04f 0164 	mov.w	r1, #100	; 0x64
 80025b8:	d003      	beq.n	80025c2 <ThCanSend.14919+0x92>

  switch (mailbox) {
  case CAN_ANY_MAILBOX:
    return (canp->can->TSR & CAN_TSR_TME) != 0;
  case 1:
    return (canp->can->TSR & CAN_TSR_TME0) != 0;
 80025ba:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 80025bc:	689a      	ldr	r2, [r3, #8]
 80025be:	0152      	lsls	r2, r2, #5
 80025c0:	d414      	bmi.n	80025ec <ThCanSend.14919+0xbc>
 80025c2:	f001 fc45 	bl	8003e50 <chThdEnqueueTimeoutS>
  /*lint -restore*/
   msg_t msg = osalThreadEnqueueTimeoutS(&canp->txqueue, timeout);
    if (msg != MSG_OK) {
 80025c6:	2800      	cmp	r0, #0
 80025c8:	d0f1      	beq.n	80025ae <ThCanSend.14919+0x7e>
 80025ca:	2300      	movs	r3, #0
 80025cc:	f383 8811 	msr	BASEPRI, r3
 80025d0:	2320      	movs	r3, #32
 80025d2:	f383 8811 	msr	BASEPRI, r3
            //canTransmit(&CAND2, 1, &txmsg, 100);                                      /** CAN package sendt out CAN2 port **/
            canTransmit(&CAND1, 1, &txmsg, 100);                                      /** CAN package sendt out CAN1 port **/


    chSysLock();
    tp_S = chThdGetSelfX();
 80025d6:	4a14      	ldr	r2, [pc, #80]	; (8002628 <ThCanSend.14919+0xf8>)
 80025d8:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80025dc:	6013      	str	r3, [r2, #0]
    chSchGoSleepS(CH_STATE_SUSPENDED);
 80025de:	2003      	movs	r0, #3
 80025e0:	f7ff f8c6 	bl	8001770 <chSchGoSleepS>
 80025e4:	2300      	movs	r3, #0
 80025e6:	f383 8811 	msr	BASEPRI, r3
 80025ea:	e7b3      	b.n	8002554 <ThCanSend.14919+0x24>
          CAN_TI0R_IDE;
  else
    tir = ((uint32_t)ctfp->SID << 21) | ((uint32_t)ctfp->RTR << 1);
  tmbp->TDTR = ctfp->DLC;
  tmbp->TDLR = ctfp->data32[0];
  tmbp->TDHR = ctfp->data32[1];
 80025ec:	a801      	add	r0, sp, #4
 80025ee:	c807      	ldmia	r0, {r0, r1, r2}
    return;
  }

  /* Preparing the message.*/
  if (ctfp->IDE)
    tir = ((uint32_t)ctfp->EID << 3) | ((uint32_t)ctfp->RTR << 1) |
 80025f0:	00c0      	lsls	r0, r0, #3
          CAN_TI0R_IDE;
  else
    tir = ((uint32_t)ctfp->SID << 21) | ((uint32_t)ctfp->RTR << 1);
  tmbp->TDTR = ctfp->DLC;
 80025f2:	f007 070f 	and.w	r7, r7, #15
  tmbp->TDLR = ctfp->data32[0];
  tmbp->TDHR = ctfp->data32[1];
  tmbp->TIR  = tir | CAN_TI0R_TXRQ;
 80025f6:	f040 0005 	orr.w	r0, r0, #5
  if (ctfp->IDE)
    tir = ((uint32_t)ctfp->EID << 3) | ((uint32_t)ctfp->RTR << 1) |
          CAN_TI0R_IDE;
  else
    tir = ((uint32_t)ctfp->SID << 21) | ((uint32_t)ctfp->RTR << 1);
  tmbp->TDTR = ctfp->DLC;
 80025fa:	f8c3 7184 	str.w	r7, [r3, #388]	; 0x184
  tmbp->TDLR = ctfp->data32[0];
 80025fe:	f8c3 1188 	str.w	r1, [r3, #392]	; 0x188
  tmbp->TDHR = ctfp->data32[1];
 8002602:	f8c3 218c 	str.w	r2, [r3, #396]	; 0x18c
 8002606:	2100      	movs	r1, #0
  tmbp->TIR  = tir | CAN_TI0R_TXRQ;
 8002608:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
 800260c:	f381 8811 	msr	BASEPRI, r1
 8002610:	e7de      	b.n	80025d0 <ThCanSend.14919+0xa0>
 8002612:	bf00      	nop
 8002614:	20000d58 	.word	0x20000d58
 8002618:	08006d34 	.word	0x08006d34
 800261c:	20000d38 	.word	0x20000d38
 8002620:	20000808 	.word	0x20000808
 8002624:	20000d60 	.word	0x20000d60
 8002628:	20000d10 	.word	0x20000d10
 800262c:	200016a8 	.word	0x200016a8
 8002630:	20000d0c 	.word	0x20000d0c
 8002634:	20000810 	.word	0x20000810
 8002638:	20000d00 	.word	0x20000d00
 800263c:	00000000 	.word	0x00000000

08002640 <DS18B20_GetTemp.4406>:
SEN_ID = id;

}

float DS18B20_GetTemp(uint8_t SensorNum)
{
 8002640:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

	uint8_t TL, TH;
	uint16_t Temp = 220;
    int i = 0;
    SEN_ID = SensorNum;
 8002644:	4e41      	ldr	r6, [pc, #260]	; (800274c <DS18B20_GetTemp.4406+0x10c>)
SEN_ID = id;

}

float DS18B20_GetTemp(uint8_t SensorNum)
{
 8002646:	4607      	mov	r7, r0

	uint8_t TL, TH;
	uint16_t Temp = 220;
    int i = 0;
    SEN_ID = SensorNum;
 8002648:	7030      	strb	r0, [r6, #0]
 800264a:	2320      	movs	r3, #32
 800264c:	f383 8811 	msr	BASEPRI, r3

            chSysLock();
            OneWire_Reset(SEN_ID);
 8002650:	f896 8000 	ldrb.w	r8, [r6]
 8002654:	4640      	mov	r0, r8
 8002656:	f001 fa1b 	bl	8003a90 <OneWire_Reset>
 800265a:	2508      	movs	r5, #8
	OneWire_SetBusLine(1,SEN_ID);
}

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
 800265c:	2455      	movs	r4, #85	; 0x55
    int i = 0;
	for(i; i<8; i++)
	{
		OneWire_WriteBit(_data & 0x01);
 800265e:	f004 0001 	and.w	r0, r4, #1
 8002662:	f001 fa45 	bl	8003af0 <OneWire_WriteBit>

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8002666:	3d01      	subs	r5, #1
	{
		OneWire_WriteBit(_data & 0x01);
		_data>>= 1;
 8002668:	ea4f 0454 	mov.w	r4, r4, lsr #1

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 800266c:	d1f7      	bne.n	800265e <DS18B20_GetTemp.4406+0x1e>
            chSysLock();
            OneWire_Reset(SEN_ID);

            OneWire_WriteByte(0x55);

            writeRomCode(SensorNum); // sned ROM code //64 bit rom code
 800266e:	4638      	mov	r0, r7
 8002670:	f001 fa8e 	bl	8003b90 <writeRomCode>
 8002674:	2408      	movs	r4, #8
	OneWire_SetBusLine(1,SEN_ID);
}

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
 8002676:	2544      	movs	r5, #68	; 0x44
    int i = 0;
	for(i; i<8; i++)
	{
		OneWire_WriteBit(_data & 0x01);
 8002678:	f005 0001 	and.w	r0, r5, #1
 800267c:	f001 fa38 	bl	8003af0 <OneWire_WriteBit>

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8002680:	3c01      	subs	r4, #1
	{
		OneWire_WriteBit(_data & 0x01);
		_data>>= 1;
 8002682:	ea4f 0555 	mov.w	r5, r5, lsr #1

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8002686:	d1f7      	bne.n	8002678 <DS18B20_GetTemp.4406+0x38>

            writeRomCode(SensorNum); // sned ROM code //64 bit rom code

            OneWire_WriteByte(0x44); //

            OneWire_SetBusLine(0,SEN_ID); // setup lint to output
 8002688:	4620      	mov	r0, r4
 800268a:	4641      	mov	r1, r8
 800268c:	f003 f8b0 	bl	80057f0 <OneWire_SetBusLine>
    }
}

void setPad(int c){

    switch (c-1){
 8002690:	f108 33ff 	add.w	r3, r8, #4294967295
 8002694:	2b01      	cmp	r3, #1
 8002696:	d04c      	beq.n	8002732 <DS18B20_GetTemp.4406+0xf2>
 8002698:	2b02      	cmp	r3, #2
 800269a:	d046      	beq.n	800272a <DS18B20_GetTemp.4406+0xea>
 800269c:	2b00      	cmp	r3, #0
 800269e:	d03d      	beq.n	800271c <DS18B20_GetTemp.4406+0xdc>

            OneWire_SetBusLine(0,SEN_ID); // setup lint to output

            setPad(SEN_ID); // parasita modepower to the line.

            chThdSleep(7500); // delay 750ms
 80026a0:	f641 504c 	movw	r0, #7500	; 0x1d4c
 80026a4:	f001 fbc4 	bl	8003e30 <chThdSleep>

            OneWire_Reset(SEN_ID);
 80026a8:	f896 8000 	ldrb.w	r8, [r6]
 80026ac:	4640      	mov	r0, r8
 80026ae:	f001 f9ef 	bl	8003a90 <OneWire_Reset>
 80026b2:	2508      	movs	r5, #8
	OneWire_SetBusLine(1,SEN_ID);
}

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
 80026b4:	2455      	movs	r4, #85	; 0x55
    int i = 0;
	for(i; i<8; i++)
	{
		OneWire_WriteBit(_data & 0x01);
 80026b6:	f004 0001 	and.w	r0, r4, #1
 80026ba:	f001 fa19 	bl	8003af0 <OneWire_WriteBit>

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 80026be:	3d01      	subs	r5, #1
	{
		OneWire_WriteBit(_data & 0x01);
		_data>>= 1;
 80026c0:	ea4f 0454 	mov.w	r4, r4, lsr #1

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 80026c4:	d1f7      	bne.n	80026b6 <DS18B20_GetTemp.4406+0x76>

            OneWire_Reset(SEN_ID);

            OneWire_WriteByte(0x55);
            //64 bit rom code
            writeRomCode(SensorNum);
 80026c6:	4638      	mov	r0, r7
 80026c8:	f001 fa62 	bl	8003b90 <writeRomCode>
 80026cc:	2408      	movs	r4, #8
	OneWire_SetBusLine(1,SEN_ID);
}

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
 80026ce:	25be      	movs	r5, #190	; 0xbe
    int i = 0;
	for(i; i<8; i++)
	{
		OneWire_WriteBit(_data & 0x01);
 80026d0:	f005 0001 	and.w	r0, r5, #1
 80026d4:	f001 fa0c 	bl	8003af0 <OneWire_WriteBit>

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 80026d8:	3c01      	subs	r4, #1
	{
		OneWire_WriteBit(_data & 0x01);
		_data>>= 1;
 80026da:	ea4f 0555 	mov.w	r5, r5, lsr #1

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 80026de:	d1f7      	bne.n	80026d0 <DS18B20_GetTemp.4406+0x90>
 80026e0:	4640      	mov	r0, r8
 80026e2:	f003 f85d 	bl	80057a0 <OneWire_SetBusLine.part.2.14391>


            OneWire_SetBusLine(1,SEN_ID);


            TL = OneWire_ReadByte();
 80026e6:	f001 fa9b 	bl	8003c20 <OneWire_ReadByte>
 80026ea:	4605      	mov	r5, r0
            TH = OneWire_ReadByte();
 80026ec:	f001 fa98 	bl	8003c20 <OneWire_ReadByte>
 80026f0:	f384 8811 	msr	BASEPRI, r4

            chSysUnlock();
            if(TL==0 && TH==0) return 0;
 80026f4:	b905      	cbnz	r5, 80026f8 <DS18B20_GetTemp.4406+0xb8>
 80026f6:	b328      	cbz	r0, 8002744 <DS18B20_GetTemp.4406+0x104>

            Temp = (int16_t)(TL)|((int16_t)TH<<8);
 80026f8:	ea45 2000 	orr.w	r0, r5, r0, lsl #8
            Temp*= 0.0625;
 80026fc:	b280      	uxth	r0, r0
 80026fe:	f7fd ff29 	bl	8000554 <__aeabi_i2d>
 8002702:	2200      	movs	r2, #0
 8002704:	4b12      	ldr	r3, [pc, #72]	; (8002750 <DS18B20_GetTemp.4406+0x110>)
 8002706:	f7fd ff8b 	bl	8000620 <__aeabi_dmul>
 800270a:	f7fe f9a1 	bl	8000a50 <__aeabi_d2uiz>
 800270e:	b280      	uxth	r0, r0

            if(Temp > 250)
 8002710:	28fa      	cmp	r0, #250	; 0xfa
 8002712:	d812      	bhi.n	800273a <DS18B20_GetTemp.4406+0xfa>
                ROM_CodeSearcher(SEN_ID);
            else

	return Temp;
 8002714:	f7fe fac2 	bl	8000c9c <__aeabi_ui2f>
 8002718:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

void setPad(int c){

    switch (c-1){
    case 0 :
        palSetPad(DS18B20_1_GPIO, DS18B20_1_DATAPIN);
 800271c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
 8002720:	f503 3304 	add.w	r3, r3, #135168	; 0x21000
 8002724:	2204      	movs	r2, #4
 8002726:	831a      	strh	r2, [r3, #24]
 8002728:	e7ba      	b.n	80026a0 <DS18B20_GetTemp.4406+0x60>
    break;
    case 1 :
        palSetPad(DS18B20_2_GPIO, DS18B20_2_DATAPIN);
    break;
    case 2:
        palSetPad(DS18B20_3_GPIO, DS18B20_3_DATAPIN);
 800272a:	4b0a      	ldr	r3, [pc, #40]	; (8002754 <DS18B20_GetTemp.4406+0x114>)
 800272c:	2210      	movs	r2, #16
 800272e:	831a      	strh	r2, [r3, #24]
 8002730:	e7b6      	b.n	80026a0 <DS18B20_GetTemp.4406+0x60>
    switch (c-1){
    case 0 :
        palSetPad(DS18B20_1_GPIO, DS18B20_1_DATAPIN);
    break;
    case 1 :
        palSetPad(DS18B20_2_GPIO, DS18B20_2_DATAPIN);
 8002732:	4b08      	ldr	r3, [pc, #32]	; (8002754 <DS18B20_GetTemp.4406+0x114>)
 8002734:	2208      	movs	r2, #8
 8002736:	831a      	strh	r2, [r3, #24]
 8002738:	e7b2      	b.n	80026a0 <DS18B20_GetTemp.4406+0x60>

            Temp = (int16_t)(TL)|((int16_t)TH<<8);
            Temp*= 0.0625;

            if(Temp > 250)
                ROM_CodeSearcher(SEN_ID);
 800273a:	7830      	ldrb	r0, [r6, #0]
 800273c:	f001 fa88 	bl	8003c50 <ROM_CodeSearcher>
 8002740:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

            TL = OneWire_ReadByte();
            TH = OneWire_ReadByte();

            chSysUnlock();
            if(TL==0 && TH==0) return 0;
 8002744:	2000      	movs	r0, #0
                ROM_CodeSearcher(SEN_ID);
            else

	return Temp;

}
 8002746:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800274a:	bf00      	nop
 800274c:	20000d3c 	.word	0x20000d3c
 8002750:	3fb00000 	.word	0x3fb00000
 8002754:	40021000 	.word	0x40021000
	...

08002760 <Thfuzzy.14568>:
}

static THD_FUNCTION(Thfuzzy, arg) {
 8002760:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8002764:	4b5e      	ldr	r3, [pc, #376]	; (80028e0 <Thfuzzy.14568+0x180>)
 8002766:	4a5f      	ldr	r2, [pc, #380]	; (80028e4 <Thfuzzy.14568+0x184>)
 8002768:	699b      	ldr	r3, [r3, #24]
 800276a:	4f5f      	ldr	r7, [pc, #380]	; (80028e8 <Thfuzzy.14568+0x188>)
 800276c:	f8df a190 	ldr.w	sl, [pc, #400]	; 8002900 <Thfuzzy.14568+0x1a0>
 8002770:	619a      	str	r2, [r3, #24]
 8002772:	b083      	sub	sp, #12
    chThdSleepMilliseconds(500);  // run up time
}

void getAllTemps(){

        currentTemp2[0] = DS18B20_GetTemp(1);
 8002774:	2001      	movs	r0, #1
 8002776:	f7ff ff63 	bl	8002640 <DS18B20_GetTemp.4406>
 800277a:	f7fe fcb1 	bl	80010e0 <__aeabi_f2iz>
 800277e:	4603      	mov	r3, r0
        chThdSleep(500);
 8002780:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
    chThdSleepMilliseconds(500);  // run up time
}

void getAllTemps(){

        currentTemp2[0] = DS18B20_GetTemp(1);
 8002784:	603b      	str	r3, [r7, #0]
        chThdSleep(500);
 8002786:	f001 fb53 	bl	8003e30 <chThdSleep>
        currentTemp2[1] = DS18B20_GetTemp(2);
 800278a:	2002      	movs	r0, #2
 800278c:	f7ff ff58 	bl	8002640 <DS18B20_GetTemp.4406>
 8002790:	f7fe fca6 	bl	80010e0 <__aeabi_f2iz>
 8002794:	4603      	mov	r3, r0
        chThdSleep(500);
 8002796:	f44f 70fa 	mov.w	r0, #500	; 0x1f4

void getAllTemps(){

        currentTemp2[0] = DS18B20_GetTemp(1);
        chThdSleep(500);
        currentTemp2[1] = DS18B20_GetTemp(2);
 800279a:	607b      	str	r3, [r7, #4]
        chThdSleep(500);
 800279c:	f001 fb48 	bl	8003e30 <chThdSleep>
        currentTemp2[2] = DS18B20_GetTemp(3);
 80027a0:	2003      	movs	r0, #3
 80027a2:	f7ff ff4d 	bl	8002640 <DS18B20_GetTemp.4406>
 80027a6:	f7fe fc9b 	bl	80010e0 <__aeabi_f2iz>
 80027aa:	4603      	mov	r3, r0
        chThdSleep(500);
 80027ac:	f44f 70fa 	mov.w	r0, #500	; 0x1f4

        currentTemp2[0] = DS18B20_GetTemp(1);
        chThdSleep(500);
        currentTemp2[1] = DS18B20_GetTemp(2);
        chThdSleep(500);
        currentTemp2[2] = DS18B20_GetTemp(3);
 80027b0:	60bb      	str	r3, [r7, #8]
        chThdSleep(500);
 80027b2:	f001 fb3d 	bl	8003e30 <chThdSleep>
 80027b6:	2500      	movs	r5, #0
    int per = 0;

    while (true) {

        getAllTemps();
        int s = 0;
 80027b8:	462c      	mov	r4, r5
        for(s ; s != 3; s++){
            if(currentTemp2[s] < TEMP[s] - DELTA[s]){
 80027ba:	4b4c      	ldr	r3, [pc, #304]	; (80028ec <Thfuzzy.14568+0x18c>)
 80027bc:	484c      	ldr	r0, [pc, #304]	; (80028f0 <Thfuzzy.14568+0x190>)
 80027be:	f857 b024 	ldr.w	fp, [r7, r4, lsl #2]
 80027c2:	5946      	ldr	r6, [r0, r5]
 80027c4:	5958      	ldr	r0, [r3, r5]
 80027c6:	f7fe fa6d 	bl	8000ca4 <__aeabi_i2f>
 80027ca:	4681      	mov	r9, r0
 80027cc:	4649      	mov	r1, r9
 80027ce:	4630      	mov	r0, r6
 80027d0:	f7fe f9b2 	bl	8000b38 <__aeabi_fsub>
 80027d4:	4680      	mov	r8, r0
 80027d6:	4658      	mov	r0, fp
 80027d8:	f7fe fa64 	bl	8000ca4 <__aeabi_i2f>
 80027dc:	4641      	mov	r1, r8
 80027de:	f7fe fc55 	bl	800108c <__aeabi_fcmplt>
 80027e2:	2800      	cmp	r0, #0
 80027e4:	d038      	beq.n	8002858 <Thfuzzy.14568+0xf8>
            /** OFF **/

            SensorPry[s] = 0;
 80027e6:	2600      	movs	r6, #0
 80027e8:	f84a 6005 	str.w	r6, [sl, r5]
int max_p(){
    int i= 0;
    int BP = 0;
    BP = SensorPry[i];
    for(i = 1 ; i != 3 ; i ++){
        if(SensorPry[i]> BP)
 80027ec:	e89a 0042 	ldmia.w	sl, {r1, r6}
            }
        /** FAN Low speed starter **/

         int newSpeed = max_p();

         if(newSpeed != FanSpeed && newSpeed > 30 )
 80027f0:	4840      	ldr	r0, [pc, #256]	; (80028f4 <Thfuzzy.14568+0x194>)
int max_p(){
    int i= 0;
    int BP = 0;
    BP = SensorPry[i];
    for(i = 1 ; i != 3 ; i ++){
        if(SensorPry[i]> BP)
 80027f2:	f8da 2008 	ldr.w	r2, [sl, #8]
            }
        /** FAN Low speed starter **/

         int newSpeed = max_p();

         if(newSpeed != FanSpeed && newSpeed > 30 )
 80027f6:	6803      	ldr	r3, [r0, #0]
 80027f8:	428e      	cmp	r6, r1
 80027fa:	bfb8      	it	lt
 80027fc:	460e      	movlt	r6, r1
 80027fe:	4296      	cmp	r6, r2
 8002800:	bfb8      	it	lt
 8002802:	4616      	movlt	r6, r2
 8002804:	429e      	cmp	r6, r3
 8002806:	d01b      	beq.n	8002840 <Thfuzzy.14568+0xe0>
 8002808:	2e1e      	cmp	r6, #30
 800280a:	dd19      	ble.n	8002840 <Thfuzzy.14568+0xe0>
            if(FanSpeed == 0){
 800280c:	2b00      	cmp	r3, #0
 800280e:	d15f      	bne.n	80028d0 <Thfuzzy.14568+0x170>
void FAN_FULL(void){
    pwmEnableChannel(&PWMD4, FAN_CH, 255);
}

void FAN_PER(int per){
    pwmEnableChannel(&PWMD4, FAN_CH, per);
 8002810:	4619      	mov	r1, r3
 8002812:	22c8      	movs	r2, #200	; 0xc8
 8002814:	4838      	ldr	r0, [pc, #224]	; (80028f8 <Thfuzzy.14568+0x198>)
 8002816:	9301      	str	r3, [sp, #4]
 8002818:	f003 f822 	bl	8005860 <pwmEnableChannel>
}

/**FAN Soft start on low speed **/
void FAN_SOFT_START(void){
    FAN_PER(StartPWM);
    chThdSleepMilliseconds(500);  // run up time
 800281c:	f241 3088 	movw	r0, #5000	; 0x1388
 8002820:	f001 fb06 	bl	8003e30 <chThdSleep>
void FAN_PER(int per){
    pwmEnableChannel(&PWMD4, FAN_CH, per);
}

void FAN_DRIVE(int d){
    pwmEnableChannel(&PWMD4, FAN_CH, d);
 8002824:	9b01      	ldr	r3, [sp, #4]
 8002826:	4834      	ldr	r0, [pc, #208]	; (80028f8 <Thfuzzy.14568+0x198>)
 8002828:	4619      	mov	r1, r3
         int newSpeed = max_p();

         if(newSpeed != FanSpeed && newSpeed > 30 )
            if(FanSpeed == 0){
                FAN_SOFT_START();
                FanSpeed = newSpeed;
 800282a:	4b32      	ldr	r3, [pc, #200]	; (80028f4 <Thfuzzy.14568+0x194>)
void FAN_PER(int per){
    pwmEnableChannel(&PWMD4, FAN_CH, per);
}

void FAN_DRIVE(int d){
    pwmEnableChannel(&PWMD4, FAN_CH, d);
 800282c:	4632      	mov	r2, r6
         int newSpeed = max_p();

         if(newSpeed != FanSpeed && newSpeed > 30 )
            if(FanSpeed == 0){
                FAN_SOFT_START();
                FanSpeed = newSpeed;
 800282e:	601e      	str	r6, [r3, #0]
void FAN_PER(int per){
    pwmEnableChannel(&PWMD4, FAN_CH, per);
}

void FAN_DRIVE(int d){
    pwmEnableChannel(&PWMD4, FAN_CH, d);
 8002830:	f003 f816 	bl	8005860 <pwmEnableChannel>

    while (true) {

        getAllTemps();
        int s = 0;
        for(s ; s != 3; s++){
 8002834:	3401      	adds	r4, #1
 8002836:	2c03      	cmp	r4, #3
 8002838:	f105 0504 	add.w	r5, r5, #4
 800283c:	d1bd      	bne.n	80027ba <Thfuzzy.14568+0x5a>
 800283e:	e799      	b.n	8002774 <Thfuzzy.14568+0x14>
            else{
               FanSpeed = newSpeed;
               FAN_DRIVE(FanSpeed);
               }
         else
           if(FanSpeed != 0 && newSpeed < 10){
 8002840:	2b00      	cmp	r3, #0
 8002842:	d0f7      	beq.n	8002834 <Thfuzzy.14568+0xd4>
 8002844:	2e09      	cmp	r6, #9
 8002846:	dcf5      	bgt.n	8002834 <Thfuzzy.14568+0xd4>
void FAN_PER(int per){
    pwmEnableChannel(&PWMD4, FAN_CH, per);
}

void FAN_DRIVE(int d){
    pwmEnableChannel(&PWMD4, FAN_CH, d);
 8002848:	2100      	movs	r1, #0
               FanSpeed = newSpeed;
               FAN_DRIVE(FanSpeed);
               }
         else
           if(FanSpeed != 0 && newSpeed < 10){
            FanSpeed = 0;
 800284a:	4e2a      	ldr	r6, [pc, #168]	; (80028f4 <Thfuzzy.14568+0x194>)
void FAN_PER(int per){
    pwmEnableChannel(&PWMD4, FAN_CH, per);
}

void FAN_DRIVE(int d){
    pwmEnableChannel(&PWMD4, FAN_CH, d);
 800284c:	482a      	ldr	r0, [pc, #168]	; (80028f8 <Thfuzzy.14568+0x198>)
               FanSpeed = newSpeed;
               FAN_DRIVE(FanSpeed);
               }
         else
           if(FanSpeed != 0 && newSpeed < 10){
            FanSpeed = 0;
 800284e:	6031      	str	r1, [r6, #0]
void FAN_PER(int per){
    pwmEnableChannel(&PWMD4, FAN_CH, per);
}

void FAN_DRIVE(int d){
    pwmEnableChannel(&PWMD4, FAN_CH, d);
 8002850:	460a      	mov	r2, r1
 8002852:	f003 f805 	bl	8005860 <pwmEnableChannel>
 8002856:	e7ed      	b.n	8002834 <Thfuzzy.14568+0xd4>
            /** OFF **/

            SensorPry[s] = 0;
            }
        else
            if (currentTemp2[s] > TEMP[s] - DELTA[s] && currentTemp2[s] < TEMP[s]){
 8002858:	4b23      	ldr	r3, [pc, #140]	; (80028e8 <Thfuzzy.14568+0x188>)
 800285a:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 800285e:	f7fe fa21 	bl	8000ca4 <__aeabi_i2f>
 8002862:	4601      	mov	r1, r0
 8002864:	4640      	mov	r0, r8
 8002866:	f7fe fc11 	bl	800108c <__aeabi_fcmplt>
 800286a:	b318      	cbz	r0, 80028b4 <Thfuzzy.14568+0x154>
 800286c:	4b1e      	ldr	r3, [pc, #120]	; (80028e8 <Thfuzzy.14568+0x188>)
 800286e:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8002872:	f7fe fa17 	bl	8000ca4 <__aeabi_i2f>
 8002876:	4601      	mov	r1, r0
 8002878:	4630      	mov	r0, r6
 800287a:	f7fe fc25 	bl	80010c8 <__aeabi_fcmpgt>
 800287e:	b1c8      	cbz	r0, 80028b4 <Thfuzzy.14568+0x154>

            /** Fan  PER = 1 - (TEMP - AktTemp) /DELAT  == % /100 -->> full is 255 (PWM)
            Fan PER = ( 1- ((TEMP - AktTemp)/ DELAT)) * 255  **/

            per = ((1-((TEMP[s] - currentTemp2[s])/ DELTA[s])) * 255) ;
 8002880:	4b19      	ldr	r3, [pc, #100]	; (80028e8 <Thfuzzy.14568+0x188>)
 8002882:	f853 0024 	ldr.w	r0, [r3, r4, lsl #2]
 8002886:	f7fe fa0d 	bl	8000ca4 <__aeabi_i2f>
 800288a:	4601      	mov	r1, r0
 800288c:	4630      	mov	r0, r6
 800288e:	f7fe f953 	bl	8000b38 <__aeabi_fsub>
 8002892:	4649      	mov	r1, r9
 8002894:	f7fe fb10 	bl	8000eb8 <__aeabi_fdiv>
 8002898:	4601      	mov	r1, r0
 800289a:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 800289e:	f7fe f94b 	bl	8000b38 <__aeabi_fsub>
 80028a2:	4916      	ldr	r1, [pc, #88]	; (80028fc <Thfuzzy.14568+0x19c>)
 80028a4:	f7fe fa54 	bl	8000d50 <__aeabi_fmul>
 80028a8:	f7fe fc1a 	bl	80010e0 <__aeabi_f2iz>
            SensorPry[s] = per-20;
 80028ac:	3814      	subs	r0, #20
 80028ae:	f84a 0005 	str.w	r0, [sl, r5]
 80028b2:	e79b      	b.n	80027ec <Thfuzzy.14568+0x8c>
            }
            else{
                if(currentTemp2[s] >= TEMP[s]){
 80028b4:	f857 0024 	ldr.w	r0, [r7, r4, lsl #2]
 80028b8:	f7fe f9f4 	bl	8000ca4 <__aeabi_i2f>
 80028bc:	4601      	mov	r1, r0
 80028be:	4630      	mov	r0, r6
 80028c0:	f7fe fbee 	bl	80010a0 <__aeabi_fcmple>
 80028c4:	2800      	cmp	r0, #0
 80028c6:	d091      	beq.n	80027ec <Thfuzzy.14568+0x8c>
                 /**Full ON**/

                SensorPry[s] = 255;
 80028c8:	23ff      	movs	r3, #255	; 0xff
 80028ca:	f84a 3005 	str.w	r3, [sl, r5]
 80028ce:	e78d      	b.n	80027ec <Thfuzzy.14568+0x8c>
                FAN_SOFT_START();
                FanSpeed = newSpeed;
                FAN_DRIVE(FanSpeed);
                }
            else{
               FanSpeed = newSpeed;
 80028d0:	4b08      	ldr	r3, [pc, #32]	; (80028f4 <Thfuzzy.14568+0x194>)
void FAN_PER(int per){
    pwmEnableChannel(&PWMD4, FAN_CH, per);
}

void FAN_DRIVE(int d){
    pwmEnableChannel(&PWMD4, FAN_CH, d);
 80028d2:	4809      	ldr	r0, [pc, #36]	; (80028f8 <Thfuzzy.14568+0x198>)
                FAN_SOFT_START();
                FanSpeed = newSpeed;
                FAN_DRIVE(FanSpeed);
                }
            else{
               FanSpeed = newSpeed;
 80028d4:	601e      	str	r6, [r3, #0]
void FAN_PER(int per){
    pwmEnableChannel(&PWMD4, FAN_CH, per);
}

void FAN_DRIVE(int d){
    pwmEnableChannel(&PWMD4, FAN_CH, d);
 80028d6:	4632      	mov	r2, r6
 80028d8:	2100      	movs	r1, #0
 80028da:	f002 ffc1 	bl	8005860 <pwmEnableChannel>
 80028de:	e7a9      	b.n	8002834 <Thfuzzy.14568+0xd4>
 80028e0:	200016a8 	.word	0x200016a8
 80028e4:	08006d40 	.word	0x08006d40
 80028e8:	2000268c 	.word	0x2000268c
 80028ec:	200011a8 	.word	0x200011a8
 80028f0:	20001690 	.word	0x20001690
 80028f4:	20000d04 	.word	0x20000d04
 80028f8:	20001bec 	.word	0x20001bec
 80028fc:	437f0000 	.word	0x437f0000
 8002900:	20000d18 	.word	0x20000d18
	...

08002910 <txWrite.14252>:
    chSysUnlock();
// auto stop
}

static THD_FUNCTION(txWrite, arg)
{
 8002910:	b508      	push	{r3, lr}
 8002912:	4d0e      	ldr	r5, [pc, #56]	; (800294c <txWrite.14252+0x3c>)
 8002914:	4e0e      	ldr	r6, [pc, #56]	; (8002950 <txWrite.14252+0x40>)
 8002916:	2420      	movs	r4, #32
 8002918:	f384 8811 	msr	BASEPRI, r4
	(void)(arg);
	while(!0){
            chSysLock();
            tp_W = chThdGetSelfX();
            chSchGoSleepS(CH_STATE_SUSPENDED);
 800291c:	2003      	movs	r0, #3
static THD_FUNCTION(txWrite, arg)
{
	(void)(arg);
	while(!0){
            chSysLock();
            tp_W = chThdGetSelfX();
 800291e:	69b3      	ldr	r3, [r6, #24]
 8002920:	602b      	str	r3, [r5, #0]
            chSchGoSleepS(CH_STATE_SUSPENDED);
 8002922:	f7fe ff25 	bl	8001770 <chSchGoSleepS>
 8002926:	2300      	movs	r3, #0
 8002928:	f383 8811 	msr	BASEPRI, r3
            chSysUnlock();

            sdWrite(&SD3, &temda, strlen(temda));
 800292c:	4809      	ldr	r0, [pc, #36]	; (8002954 <txWrite.14252+0x44>)
 800292e:	f004 f87f 	bl	8006a30 <strlen>
 8002932:	4908      	ldr	r1, [pc, #32]	; (8002954 <txWrite.14252+0x44>)
 8002934:	4602      	mov	r2, r0
 8002936:	f04f 33ff 	mov.w	r3, #4294967295
 800293a:	4807      	ldr	r0, [pc, #28]	; (8002958 <txWrite.14252+0x48>)
 800293c:	f001 fb98 	bl	8004070 <chOQWriteTimeout>
			 * Type of arg2 should be (uint8_t *) otherwise only first 8 bit will be send.*/
		//	sdWrite(&SD3, &toSend,1);

		//}
		//wifiInit();
		chThdSleepMilliseconds(1000);
 8002940:	f242 7010 	movw	r0, #10000	; 0x2710
 8002944:	f001 fa74 	bl	8003e30 <chThdSleep>
 8002948:	e7e6      	b.n	8002918 <txWrite.14252+0x8>
 800294a:	bf00      	nop
 800294c:	20000d08 	.word	0x20000d08
 8002950:	200016a8 	.word	0x200016a8
 8002954:	20000d40 	.word	0x20000d40
 8002958:	20001398 	.word	0x20001398
 800295c:	00000000 	.word	0x00000000

08002960 <telnetReconfig.4423>:
uint8_t end[] = "\r\n";
uint8_t comATCIPMUX[] = "AT+CIPMUX=1\r\n";
uint8_t comATCIPSERVER[] = "AT+CIPSERVER=1,23\r\n";


void telnetReconfig(void){
 8002960:	b510      	push	{r4, lr}

 sdWrite(&SD3, &comATCIPMUX,strlen(comATCIPMUX));
 8002962:	4c08      	ldr	r4, [pc, #32]	; (8002984 <telnetReconfig.4423+0x24>)
 8002964:	4620      	mov	r0, r4
 8002966:	f004 f863 	bl	8006a30 <strlen>
 800296a:	4621      	mov	r1, r4
 800296c:	4602      	mov	r2, r0
 800296e:	f04f 33ff 	mov.w	r3, #4294967295
 8002972:	4805      	ldr	r0, [pc, #20]	; (8002988 <telnetReconfig.4423+0x28>)
 8002974:	f001 fb7c 	bl	8004070 <chOQWriteTimeout>
 chThdSleepMilliseconds(5000);
 8002978:	f24c 3050 	movw	r0, #50000	; 0xc350
}
 800297c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}


void telnetReconfig(void){

 sdWrite(&SD3, &comATCIPMUX,strlen(comATCIPMUX));
 chThdSleepMilliseconds(5000);
 8002980:	f001 ba56 	b.w	8003e30 <chThdSleep>
 8002984:	20000818 	.word	0x20000818
 8002988:	20001398 	.word	0x20001398
 800298c:	00000000 	.word	0x00000000

08002990 <cmd_telreconf.16074>:
            return 1;
    }
}


static void cmd_telreconf(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002990:	b510      	push	{r4, lr}
  (void)argv;

    chprintf(chp, "reconfig...\n\r");
 8002992:	4906      	ldr	r1, [pc, #24]	; (80029ac <cmd_telreconf.16074+0x1c>)
            return 1;
    }
}


static void cmd_telreconf(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002994:	4604      	mov	r4, r0
  (void)argv;

    chprintf(chp, "reconfig...\n\r");
 8002996:	f002 fd53 	bl	8005440 <chprintf.16065>
    telnetReconfig();
 800299a:	f7ff ffe1 	bl	8002960 <telnetReconfig.4423>
    chprintf(chp, "done:\n\r");
 800299e:	4620      	mov	r0, r4
 80029a0:	4903      	ldr	r1, [pc, #12]	; (80029b0 <cmd_telreconf.16074+0x20>)
    return 1;
}
 80029a2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static void cmd_telreconf(BaseSequentialStream *chp, int argc, char *argv[]) {
  (void)argv;

    chprintf(chp, "reconfig...\n\r");
    telnetReconfig();
    chprintf(chp, "done:\n\r");
 80029a6:	f002 bd4b 	b.w	8005440 <chprintf.16065>
 80029aa:	bf00      	nop
 80029ac:	08006d48 	.word	0x08006d48
 80029b0:	08006d58 	.word	0x08006d58
	...

080029c0 <ext_lld_start>:
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
  unsigned i;

  if (extp->state == EXT_STOP)
 80029c0:	7803      	ldrb	r3, [r0, #0]
 80029c2:	2b01      	cmp	r3, #1
 *
 * @param[in] extp      pointer to the @p EXTDriver object
 *
 * @notapi
 */
void ext_lld_start(EXTDriver *extp) {
 80029c4:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
  unsigned i;

  if (extp->state == EXT_STOP)
 80029c8:	d068      	beq.n	8002a9c <ext_lld_start+0xdc>
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
 80029ca:	2100      	movs	r1, #0
 80029cc:	6845      	ldr	r5, [r0, #4]
  (void)extp;

#if STM32_EXTI_NUM_CHANNELS > 32
  if (channel < 32) {
#endif
    EXTI->IMR   &= ~(1 << channel);
 80029ce:	4b65      	ldr	r3, [pc, #404]	; (8002b64 <ext_lld_start+0x1a4>)
  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
 80029d0:	460a      	mov	r2, r1
  (void)extp;

#if STM32_EXTI_NUM_CHANNELS > 32
  if (channel < 32) {
#endif
    EXTI->IMR   &= ~(1 << channel);
 80029d2:	2701      	movs	r7, #1
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
 80029d4:	f04f 0c0f 	mov.w	ip, #15
 80029d8:	e034      	b.n	8002a44 <ext_lld_start+0x84>
 * @notapi
 */
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
 80029da:	2a0f      	cmp	r2, #15
 80029dc:	d815      	bhi.n	8002a0a <ext_lld_start+0x4a>
 80029de:	f022 0403 	bic.w	r4, r2, #3
 80029e2:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
 80029e6:	f504 349c 	add.w	r4, r4, #79872	; 0x13800
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
 80029ea:	f002 0603 	and.w	r6, r2, #3
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);

#if defined(STM32F1XX)
    AFIO->EXTICR[n] = (AFIO->EXTICR[n] & mask) | port;
#else /* !defined(STM32F1XX) */
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
 80029ee:	f8d4 8008 	ldr.w	r8, [r4, #8]
void ext_lld_channel_enable(EXTDriver *extp, expchannel_t channel) {

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
 80029f2:	00b6      	lsls	r6, r6, #2
 80029f4:	fa0c fa06 	lsl.w	sl, ip, r6
    uint32_t port = ((extp->config->channels[channel].mode &
                      EXT_MODE_GPIO_MASK) >>
 80029f8:	f3c0 1903 	ubfx	r9, r0, #4, #4
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);

#if defined(STM32F1XX)
    AFIO->EXTICR[n] = (AFIO->EXTICR[n] & mask) | port;
#else /* !defined(STM32F1XX) */
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
 80029fc:	ea28 080a 	bic.w	r8, r8, sl

  /* Setting the associated GPIO for external channels.*/
  if (channel < 16) {
    uint32_t n = channel >> 2;
    uint32_t mask = ~(0xF << ((channel & 3) * 4));
    uint32_t port = ((extp->config->channels[channel].mode &
 8002a00:	fa09 f606 	lsl.w	r6, r9, r6
                     EXT_MODE_GPIO_OFF) << ((channel & 3) * 4);

#if defined(STM32F1XX)
    AFIO->EXTICR[n] = (AFIO->EXTICR[n] & mask) | port;
#else /* !defined(STM32F1XX) */
    SYSCFG->EXTICR[n] = (SYSCFG->EXTICR[n] & mask) | port;
 8002a04:	ea48 0606 	orr.w	r6, r8, r6
 8002a08:	60a6      	str	r6, [r4, #8]

#if STM32_EXTI_NUM_CHANNELS > 32
  if (channel < 32) {
#endif
    /* Programming edge registers.*/
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
 8002a0a:	07c4      	lsls	r4, r0, #31
 8002a0c:	d535      	bpl.n	8002a7a <ext_lld_start+0xba>
      EXTI->RTSR |= (1 << channel);
 8002a0e:	689e      	ldr	r6, [r3, #8]
 8002a10:	fa07 f402 	lsl.w	r4, r7, r2
 8002a14:	4326      	orrs	r6, r4
 8002a16:	609e      	str	r6, [r3, #8]
 8002a18:	43e6      	mvns	r6, r4
    else
      EXTI->RTSR &= ~(1 << channel);
    if (extp->config->channels[channel].mode & EXT_CH_MODE_FALLING_EDGE)
 8002a1a:	f010 0f02 	tst.w	r0, #2
      EXTI->FTSR |= (1 << channel);
 8002a1e:	68d8      	ldr	r0, [r3, #12]
 8002a20:	bf14      	ite	ne
 8002a22:	4320      	orrne	r0, r4
    else
      EXTI->FTSR &= ~(1 << channel);
 8002a24:	4030      	andeq	r0, r6
 8002a26:	60d8      	str	r0, [r3, #12]
 8002a28:	1868      	adds	r0, r5, r1

    /* Programming interrupt and event registers.*/
    if (extp->config->channels[channel].cb != NULL) {
 8002a2a:	6840      	ldr	r0, [r0, #4]
 8002a2c:	b378      	cbz	r0, 8002a8e <ext_lld_start+0xce>
      EXTI->IMR |= (1 << channel);
 8002a2e:	6818      	ldr	r0, [r3, #0]
 8002a30:	4304      	orrs	r4, r0
 8002a32:	601c      	str	r4, [r3, #0]
      EXTI->EMR &= ~(1 << channel);
 8002a34:	6858      	ldr	r0, [r3, #4]
 8002a36:	4006      	ands	r6, r0
 8002a38:	605e      	str	r6, [r3, #4]

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
 8002a3a:	3201      	adds	r2, #1
 8002a3c:	2a17      	cmp	r2, #23
 8002a3e:	f101 0108 	add.w	r1, r1, #8
 8002a42:	d017      	beq.n	8002a74 <ext_lld_start+0xb4>
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
 8002a44:	5868      	ldr	r0, [r5, r1]
 8002a46:	0746      	lsls	r6, r0, #29
 8002a48:	d4c7      	bmi.n	80029da <ext_lld_start+0x1a>
  (void)extp;

#if STM32_EXTI_NUM_CHANNELS > 32
  if (channel < 32) {
#endif
    EXTI->IMR   &= ~(1 << channel);
 8002a4a:	681e      	ldr	r6, [r3, #0]
 8002a4c:	fa07 f402 	lsl.w	r4, r7, r2
 8002a50:	43e0      	mvns	r0, r4
 8002a52:	4006      	ands	r6, r0
 8002a54:	601e      	str	r6, [r3, #0]
    EXTI->EMR   &= ~(1 << channel);
 8002a56:	685e      	ldr	r6, [r3, #4]
 8002a58:	4006      	ands	r6, r0
 8002a5a:	605e      	str	r6, [r3, #4]
    EXTI->RTSR  &= ~(1 << channel);
 8002a5c:	689e      	ldr	r6, [r3, #8]
 8002a5e:	4006      	ands	r6, r0
 8002a60:	609e      	str	r6, [r3, #8]
    EXTI->FTSR  &= ~(1 << channel);
 8002a62:	68de      	ldr	r6, [r3, #12]

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
 8002a64:	3201      	adds	r2, #1
  if (channel < 32) {
#endif
    EXTI->IMR   &= ~(1 << channel);
    EXTI->EMR   &= ~(1 << channel);
    EXTI->RTSR  &= ~(1 << channel);
    EXTI->FTSR  &= ~(1 << channel);
 8002a66:	4030      	ands	r0, r6

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
 8002a68:	2a17      	cmp	r2, #23
  if (channel < 32) {
#endif
    EXTI->IMR   &= ~(1 << channel);
    EXTI->EMR   &= ~(1 << channel);
    EXTI->RTSR  &= ~(1 << channel);
    EXTI->FTSR  &= ~(1 << channel);
 8002a6a:	60d8      	str	r0, [r3, #12]
 8002a6c:	f101 0108 	add.w	r1, r1, #8
    EXTI->PR     =  (1 << channel);
 8002a70:	615c      	str	r4, [r3, #20]

  if (extp->state == EXT_STOP)
    ext_lld_exti_irq_enable();

  /* Configuration of automatic channels.*/
  for (i = 0; i < EXT_MAX_CHANNELS; i++)
 8002a72:	d1e7      	bne.n	8002a44 <ext_lld_start+0x84>
    if (extp->config->channels[i].mode & EXT_CH_MODE_AUTOSTART)
      ext_lld_channel_enable(extp, i);
    else
      ext_lld_channel_disable(extp, i);
}
 8002a74:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8002a78:	4770      	bx	lr
#endif
    /* Programming edge registers.*/
    if (extp->config->channels[channel].mode & EXT_CH_MODE_RISING_EDGE)
      EXTI->RTSR |= (1 << channel);
    else
      EXTI->RTSR &= ~(1 << channel);
 8002a7a:	f8d3 8008 	ldr.w	r8, [r3, #8]
 8002a7e:	fa07 f402 	lsl.w	r4, r7, r2
 8002a82:	43e6      	mvns	r6, r4
 8002a84:	ea06 0808 	and.w	r8, r6, r8
 8002a88:	f8c3 8008 	str.w	r8, [r3, #8]
 8002a8c:	e7c5      	b.n	8002a1a <ext_lld_start+0x5a>
    if (extp->config->channels[channel].cb != NULL) {
      EXTI->IMR |= (1 << channel);
      EXTI->EMR &= ~(1 << channel);
    }
    else {
      EXTI->EMR |= (1 << channel);
 8002a8e:	6858      	ldr	r0, [r3, #4]
 8002a90:	4304      	orrs	r4, r0
 8002a92:	605c      	str	r4, [r3, #4]
      EXTI->IMR &= ~(1 << channel);
 8002a94:	6818      	ldr	r0, [r3, #0]
 8002a96:	4006      	ands	r6, r0
 8002a98:	601e      	str	r6, [r3, #0]
 8002a9a:	e7ce      	b.n	8002a3a <ext_lld_start+0x7a>

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002a9c:	4b32      	ldr	r3, [pc, #200]	; (8002b68 <ext_lld_start+0x1a8>)
 8002a9e:	2260      	movs	r2, #96	; 0x60
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002aa0:	f04f 0c40 	mov.w	ip, #64	; 0x40
 8002aa4:	2780      	movs	r7, #128	; 0x80

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002aa6:	f883 2306 	strb.w	r2, [r3, #774]	; 0x306
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002aaa:	f44f 7580 	mov.w	r5, #256	; 0x100
 8002aae:	f8c3 c180 	str.w	ip, [r3, #384]	; 0x180
 8002ab2:	f44f 7400 	mov.w	r4, #512	; 0x200
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002ab6:	f8c3 c000 	str.w	ip, [r3]
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002aba:	f44f 6180 	mov.w	r1, #1024	; 0x400

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002abe:	f883 2307 	strb.w	r2, [r3, #775]	; 0x307
 8002ac2:	26f0      	movs	r6, #240	; 0xf0
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002ac4:	f8c3 7180 	str.w	r7, [r3, #384]	; 0x180
 8002ac8:	f44f 0b00 	mov.w	fp, #8388608	; 0x800000
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002acc:	601f      	str	r7, [r3, #0]
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002ace:	f04f 0a02 	mov.w	sl, #2
 8002ad2:	f04f 4980 	mov.w	r9, #1073741824	; 0x40000000
 8002ad6:	f44f 5880 	mov.w	r8, #4096	; 0x1000
 8002ada:	f04f 0c04 	mov.w	ip, #4
 8002ade:	2708      	movs	r7, #8

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002ae0:	f883 2308 	strb.w	r2, [r3, #776]	; 0x308
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002ae4:	f8c3 5180 	str.w	r5, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002ae8:	601d      	str	r5, [r3, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002aea:	f883 2309 	strb.w	r2, [r3, #777]	; 0x309
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002aee:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002af2:	601c      	str	r4, [r3, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002af4:	f883 230a 	strb.w	r2, [r3, #778]	; 0x30a
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002af8:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002afc:	6019      	str	r1, [r3, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002afe:	f883 2317 	strb.w	r2, [r3, #791]	; 0x317
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b02:	f8c3 b180 	str.w	fp, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b06:	f8c3 b000 	str.w	fp, [r3]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b0a:	f883 2328 	strb.w	r2, [r3, #808]	; 0x328
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b0e:	f8c3 5184 	str.w	r5, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b12:	605d      	str	r5, [r3, #4]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b14:	f883 2301 	strb.w	r2, [r3, #769]	; 0x301
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b18:	f8c3 a180 	str.w	sl, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b1c:	f8c3 a000 	str.w	sl, [r3]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b20:	f883 6329 	strb.w	r6, [r3, #809]	; 0x329
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b24:	f8c3 4184 	str.w	r4, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b28:	605c      	str	r4, [r3, #4]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b2a:	f883 232a 	strb.w	r2, [r3, #810]	; 0x32a
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b2e:	f8c3 1184 	str.w	r1, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b32:	6059      	str	r1, [r3, #4]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b34:	f883 233e 	strb.w	r2, [r3, #830]	; 0x33e
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b38:	f8c3 9184 	str.w	r9, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b3c:	f8c3 9004 	str.w	r9, [r3, #4]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b40:	f883 234c 	strb.w	r2, [r3, #844]	; 0x34c
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b44:	f8c3 8188 	str.w	r8, [r3, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b48:	f8c3 8008 	str.w	r8, [r3, #8]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b4c:	f883 6302 	strb.w	r6, [r3, #770]	; 0x302
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b50:	f8c3 c180 	str.w	ip, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b54:	f8c3 c000 	str.w	ip, [r3]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002b58:	f883 6303 	strb.w	r6, [r3, #771]	; 0x303
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002b5c:	f8c3 7180 	str.w	r7, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002b60:	601f      	str	r7, [r3, #0]
 8002b62:	e732      	b.n	80029ca <ext_lld_start+0xa>
 8002b64:	40013c00 	.word	0x40013c00
 8002b68:	e000e100 	.word	0xe000e100
 8002b6c:	00000000 	.word	0x00000000

08002b70 <CanReadInt>:

// start can reading
// ellenorzes

}
int CanReadInt(uint16_t FROM, uint16_t PID){
 8002b70:	b500      	push	{lr}
 8002b72:	b087      	sub	sp, #28
 8002b74:	460a      	mov	r2, r1
CANRxFrameClone temprx;
uint32_t temp32 = 0;
float    tempf = 0;
int      tempi = 0;

 temprx = CanReadDATA(FROM, PID);
 8002b76:	4601      	mov	r1, r0
 8002b78:	a801      	add	r0, sp, #4
 8002b7a:	f7ff fad9 	bl	8002130 <CanReadDATA.4386>
 temp32 = ( temprx.data8[7]<< 24 ) | ( temprx.data8[8]<< 16 ) | ( temprx.data8[9])<<8 | ( temprx.data8[10] );
 8002b7e:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8002b82:	f89d 1013 	ldrb.w	r1, [sp, #19]
 8002b86:	f89d 2016 	ldrb.w	r2, [sp, #22]
 8002b8a:	f89d 0015 	ldrb.w	r0, [sp, #21]
 8002b8e:	041b      	lsls	r3, r3, #16
 8002b90:	ea43 6301 	orr.w	r3, r3, r1, lsl #24
 8002b94:	4313      	orrs	r3, r2
 tempf = *(float*)&temp32;
 tempi = tempf;
 8002b96:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
 8002b9a:	f7fe faa1 	bl	80010e0 <__aeabi_f2iz>

return tempi;
}
 8002b9e:	b007      	add	sp, #28
 8002ba0:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002bb0 <cmd_read.16084>:
               return f;
    }
}


static void cmd_read(BaseSequentialStream *chp, int argc, char *argv[]){
 8002bb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
(void)argv;
  if (argc > 0) {
 8002bb4:	2900      	cmp	r1, #0
               return f;
    }
}


static void cmd_read(BaseSequentialStream *chp, int argc, char *argv[]){
 8002bb6:	b08f      	sub	sp, #60	; 0x3c
 8002bb8:	4606      	mov	r6, r0
(void)argv;
  if (argc > 0) {
 8002bba:	dc5c      	bgt.n	8002c76 <cmd_read.16084+0xc6>
  }
  int i =0;
  uint32_t rxd;
  uint32_t rxd2;
   uint32_t rxidd;
   DEVICE_ID = 101;
 8002bbc:	4d31      	ldr	r5, [pc, #196]	; (8002c84 <cmd_read.16084+0xd4>)
 8002bbe:	2165      	movs	r1, #101	; 0x65
 8002bc0:	6029      	str	r1, [r5, #0]
 8002bc2:	2402      	movs	r4, #2
   CANRxFrameClone tempStack;
   //\id = 1107;

    while(i <=1 ){

               tempStack = CanReadDATA(DEVICE_ID,id);
 8002bc4:	4b30      	ldr	r3, [pc, #192]	; (8002c88 <cmd_read.16084+0xd8>)
 8002bc6:	b289      	uxth	r1, r1
 8002bc8:	881a      	ldrh	r2, [r3, #0]
 8002bca:	a809      	add	r0, sp, #36	; 0x24
 8002bcc:	461f      	mov	r7, r3
 8002bce:	f7ff faaf 	bl	8002130 <CanReadDATA.4386>
               rxd     = ( tempStack.data8[4]<< 16 ) | ( tempStack.data8[5]<< 8 ) | ( tempStack.data8[6]);// | (rxmsg.data8[5]<< 8 ) | (rxmsg.data8[6] );
               rxd2    = ( tempStack.data8[7]<< 24 ) | ( tempStack.data8[8]<< 16 ) | ( tempStack.data8[9])<<8 | ( tempStack.data8[10] );
 8002bd2:	f89d e036 	ldrb.w	lr, [sp, #54]	; 0x36
 8002bd6:	f8cd e010 	str.w	lr, [sp, #16]
   uint32_t rxidd;
   DEVICE_ID = 101;
   CANRxFrameClone tempStack;
   //\id = 1107;

    while(i <=1 ){
 8002bda:	3c01      	subs	r4, #1

               tempStack = CanReadDATA(DEVICE_ID,id);
               rxd     = ( tempStack.data8[4]<< 16 ) | ( tempStack.data8[5]<< 8 ) | ( tempStack.data8[6]);// | (rxmsg.data8[5]<< 8 ) | (rxmsg.data8[6] );
 8002bdc:	f89d 1030 	ldrb.w	r1, [sp, #48]	; 0x30
 8002be0:	f89d 2031 	ldrb.w	r2, [sp, #49]	; 0x31
 8002be4:	f89d 8032 	ldrb.w	r8, [sp, #50]	; 0x32
               rxd2    = ( tempStack.data8[7]<< 24 ) | ( tempStack.data8[8]<< 16 ) | ( tempStack.data8[9])<<8 | ( tempStack.data8[10] );
 8002be8:	f89d 3033 	ldrb.w	r3, [sp, #51]	; 0x33
 8002bec:	f89d c034 	ldrb.w	ip, [sp, #52]	; 0x34
 8002bf0:	f89d 0035 	ldrb.w	r0, [sp, #53]	; 0x35
               rxidd   = ( tempStack.data8[3]<< 24 ) | ( tempStack.data8[2]<< 16 ) | ( tempStack.data8[1])<<8 | ( tempStack.data8[0] );
 8002bf4:	f89d e02f 	ldrb.w	lr, [sp, #47]	; 0x2f
 8002bf8:	f89d b02e 	ldrb.w	fp, [sp, #46]	; 0x2e
 8002bfc:	f89d 902d 	ldrb.w	r9, [sp, #45]	; 0x2d
 8002c00:	f89d a02c 	ldrb.w	sl, [sp, #44]	; 0x2c
   uint32_t rxidd;
   DEVICE_ID = 101;
   CANRxFrameClone tempStack;
   //\id = 1107;

    while(i <=1 ){
 8002c04:	d001      	beq.n	8002c0a <cmd_read.16084+0x5a>
 8002c06:	6829      	ldr	r1, [r5, #0]
 8002c08:	e7dc      	b.n	8002bc4 <cmd_read.16084+0x14>
 8002c0a:	460c      	mov	r4, r1
 8002c0c:	9006      	str	r0, [sp, #24]
               rxidd   = ( tempStack.data8[3]<< 24 ) | ( tempStack.data8[2]<< 16 ) | ( tempStack.data8[1])<<8 | ( tempStack.data8[0] );

                i++;
    }
    i=0;
     chprintf(chp, "INT: %d\n\n\r", CanReadInt(DEVICE_ID,id));
 8002c0e:	8839      	ldrh	r1, [r7, #0]
 8002c10:	8828      	ldrh	r0, [r5, #0]
 8002c12:	f8cd e01c 	str.w	lr, [sp, #28]
 8002c16:	9302      	str	r3, [sp, #8]
 8002c18:	f8cd c00c 	str.w	ip, [sp, #12]
 8002c1c:	9205      	str	r2, [sp, #20]
 8002c1e:	f7ff ffa7 	bl	8002b70 <CanReadInt>
 8002c22:	491a      	ldr	r1, [pc, #104]	; (8002c8c <cmd_read.16084+0xdc>)
 8002c24:	4602      	mov	r2, r0
 8002c26:	4630      	mov	r0, r6
 8002c28:	f002 fc0a 	bl	8005440 <chprintf.16065>

    while(i <=1 ){

               tempStack = CanReadDATA(DEVICE_ID,id);
               rxd     = ( tempStack.data8[4]<< 16 ) | ( tempStack.data8[5]<< 8 ) | ( tempStack.data8[6]);// | (rxmsg.data8[5]<< 8 ) | (rxmsg.data8[6] );
               rxd2    = ( tempStack.data8[7]<< 24 ) | ( tempStack.data8[8]<< 16 ) | ( tempStack.data8[9])<<8 | ( tempStack.data8[10] );
 8002c2c:	f8dd c00c 	ldr.w	ip, [sp, #12]
 8002c30:	9b02      	ldr	r3, [sp, #8]
   //\id = 1107;

    while(i <=1 ){

               tempStack = CanReadDATA(DEVICE_ID,id);
               rxd     = ( tempStack.data8[4]<< 16 ) | ( tempStack.data8[5]<< 8 ) | ( tempStack.data8[6]);// | (rxmsg.data8[5]<< 8 ) | (rxmsg.data8[6] );
 8002c32:	f8dd e014 	ldr.w	lr, [sp, #20]
               rxd2    = ( tempStack.data8[7]<< 24 ) | ( tempStack.data8[8]<< 16 ) | ( tempStack.data8[9])<<8 | ( tempStack.data8[10] );
 8002c36:	9906      	ldr	r1, [sp, #24]
 8002c38:	ea4f 420c 	mov.w	r2, ip, lsl #16
 8002c3c:	ea42 6203 	orr.w	r2, r2, r3, lsl #24
 8002c40:	9b04      	ldr	r3, [sp, #16]
 8002c42:	431a      	orrs	r2, r3
               rxidd   = ( tempStack.data8[3]<< 24 ) | ( tempStack.data8[2]<< 16 ) | ( tempStack.data8[1])<<8 | ( tempStack.data8[0] );
 8002c44:	9b07      	ldr	r3, [sp, #28]
 8002c46:	ea4f 4b0b 	mov.w	fp, fp, lsl #16
 8002c4a:	ea4b 6b03 	orr.w	fp, fp, r3, lsl #24
   //\id = 1107;

    while(i <=1 ){

               tempStack = CanReadDATA(DEVICE_ID,id);
               rxd     = ( tempStack.data8[4]<< 16 ) | ( tempStack.data8[5]<< 8 ) | ( tempStack.data8[6]);// | (rxmsg.data8[5]<< 8 ) | (rxmsg.data8[6] );
 8002c4e:	ea4f 230e 	mov.w	r3, lr, lsl #8
               rxd2    = ( tempStack.data8[7]<< 24 ) | ( tempStack.data8[8]<< 16 ) | ( tempStack.data8[9])<<8 | ( tempStack.data8[10] );
 8002c52:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
               rxidd   = ( tempStack.data8[3]<< 24 ) | ( tempStack.data8[2]<< 16 ) | ( tempStack.data8[1])<<8 | ( tempStack.data8[0] );
 8002c56:	ea4b 0a0a 	orr.w	sl, fp, sl
   //\id = 1107;

    while(i <=1 ){

               tempStack = CanReadDATA(DEVICE_ID,id);
               rxd     = ( tempStack.data8[4]<< 16 ) | ( tempStack.data8[5]<< 8 ) | ( tempStack.data8[6]);// | (rxmsg.data8[5]<< 8 ) | (rxmsg.data8[6] );
 8002c5a:	ea43 4304 	orr.w	r3, r3, r4, lsl #16

                i++;
    }
    i=0;
     chprintf(chp, "INT: %d\n\n\r", CanReadInt(DEVICE_ID,id));
     chprintf(chp, "RX_CAN: %X %X %X\n\n\r",rxidd ,rxd,rxd2);
 8002c5e:	9200      	str	r2, [sp, #0]
 8002c60:	ea43 0308 	orr.w	r3, r3, r8
 8002c64:	ea4a 2209 	orr.w	r2, sl, r9, lsl #8
 8002c68:	4630      	mov	r0, r6
 8002c6a:	4909      	ldr	r1, [pc, #36]	; (8002c90 <cmd_read.16084+0xe0>)
 8002c6c:	f002 fbe8 	bl	8005440 <chprintf.16065>
    return f;
}
 8002c70:	b00f      	add	sp, #60	; 0x3c
 8002c72:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}


static void cmd_read(BaseSequentialStream *chp, int argc, char *argv[]){
(void)argv;
  if (argc > 0) {
    chprintf(chp, "temp\r\n");
 8002c76:	4907      	ldr	r1, [pc, #28]	; (8002c94 <cmd_read.16084+0xe4>)
    }
    i=0;
     chprintf(chp, "INT: %d\n\n\r", CanReadInt(DEVICE_ID,id));
     chprintf(chp, "RX_CAN: %X %X %X\n\n\r",rxidd ,rxd,rxd2);
    return f;
}
 8002c78:	b00f      	add	sp, #60	; 0x3c
 8002c7a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}


static void cmd_read(BaseSequentialStream *chp, int argc, char *argv[]){
(void)argv;
  if (argc > 0) {
    chprintf(chp, "temp\r\n");
 8002c7e:	f002 bbdf 	b.w	8005440 <chprintf.16065>
 8002c82:	bf00      	nop
 8002c84:	2000080c 	.word	0x2000080c
 8002c88:	20000d14 	.word	0x20000d14
 8002c8c:	08006d60 	.word	0x08006d60
 8002c90:	08006d6c 	.word	0x08006d6c
 8002c94:	08006cd8 	.word	0x08006cd8
	...

08002ca0 <shell_thread.13239>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 8002ca0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002ca4:	4b79      	ldr	r3, [pc, #484]	; (8002e8c <shell_thread.13239+0x1ec>)
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
 8002ca6:	6804      	ldr	r4, [r0, #0]
 8002ca8:	699b      	ldr	r3, [r3, #24]
 8002caa:	4a79      	ldr	r2, [pc, #484]	; (8002e90 <shell_thread.13239+0x1f0>)
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
 8002cac:	f8d0 8004 	ldr.w	r8, [r0, #4]
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 8002cb0:	4978      	ldr	r1, [pc, #480]	; (8002e94 <shell_thread.13239+0x1f4>)
 8002cb2:	619a      	str	r2, [r3, #24]
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 8002cb4:	b098      	sub	sp, #96	; 0x60
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 8002cb6:	4620      	mov	r0, r4
 8002cb8:	f002 fc6a 	bl	8005590 <chprintf.13255>
 8002cbc:	ae08      	add	r6, sp, #32
      *p = 0;
      return false;
    }
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 8002cbe:	f10d 075f 	add.w	r7, sp, #95	; 0x5f
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
  while (true) {
    chprintf(chp, "ch> ");
 8002cc2:	4620      	mov	r0, r4
 8002cc4:	4974      	ldr	r1, [pc, #464]	; (8002e98 <shell_thread.13239+0x1f8>)
 8002cc6:	f002 fc63 	bl	8005590 <chprintf.13255>
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
  char *p = line;
 8002cca:	4635      	mov	r5, r6

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
 8002ccc:	6823      	ldr	r3, [r4, #0]
 8002cce:	4620      	mov	r0, r4
 8002cd0:	685b      	ldr	r3, [r3, #4]
 8002cd2:	f10d 0107 	add.w	r1, sp, #7
 8002cd6:	2201      	movs	r2, #1
 8002cd8:	4798      	blx	r3
 8002cda:	b368      	cbz	r0, 8002d38 <shell_thread.13239+0x98>
      return true;
    if (c == 4) {
 8002cdc:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8002ce0:	2904      	cmp	r1, #4
 8002ce2:	d025      	beq.n	8002d30 <shell_thread.13239+0x90>
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
 8002ce4:	2908      	cmp	r1, #8
 8002ce6:	d010      	beq.n	8002d0a <shell_thread.13239+0x6a>
 8002ce8:	297f      	cmp	r1, #127	; 0x7f
 8002cea:	d00e      	beq.n	8002d0a <shell_thread.13239+0x6a>
        chSequentialStreamPut(chp, c);
        p--;
      }
      continue;
    }
    if (c == '\r') {
 8002cec:	290d      	cmp	r1, #13
 8002cee:	d034      	beq.n	8002d5a <shell_thread.13239+0xba>
      chprintf(chp, "\r\n");
      *p = 0;
      return false;
    }
    if (c < 0x20)
 8002cf0:	291f      	cmp	r1, #31
 8002cf2:	d9eb      	bls.n	8002ccc <shell_thread.13239+0x2c>
      continue;
    if (p < line + size - 1) {
 8002cf4:	42bd      	cmp	r5, r7
 8002cf6:	d2e9      	bcs.n	8002ccc <shell_thread.13239+0x2c>
      chSequentialStreamPut(chp, c);
 8002cf8:	6823      	ldr	r3, [r4, #0]
 8002cfa:	4620      	mov	r0, r4
 8002cfc:	689b      	ldr	r3, [r3, #8]
 8002cfe:	4798      	blx	r3
      *p++ = (char)c;
 8002d00:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8002d04:	702b      	strb	r3, [r5, #0]
 8002d06:	3501      	adds	r5, #1
 8002d08:	e7e0      	b.n	8002ccc <shell_thread.13239+0x2c>
    if (c == 4) {
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
 8002d0a:	42b5      	cmp	r5, r6
        chSequentialStreamPut(chp, c);
 8002d0c:	4620      	mov	r0, r4
    if (c == 4) {
      chprintf(chp, "^D");
      return true;
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
 8002d0e:	d0dd      	beq.n	8002ccc <shell_thread.13239+0x2c>
        chSequentialStreamPut(chp, c);
 8002d10:	6823      	ldr	r3, [r4, #0]
 8002d12:	689b      	ldr	r3, [r3, #8]
 8002d14:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x20);
 8002d16:	6823      	ldr	r3, [r4, #0]
 8002d18:	4620      	mov	r0, r4
 8002d1a:	689b      	ldr	r3, [r3, #8]
 8002d1c:	2120      	movs	r1, #32
 8002d1e:	4798      	blx	r3
        chSequentialStreamPut(chp, c);
 8002d20:	6823      	ldr	r3, [r4, #0]
 8002d22:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8002d26:	689b      	ldr	r3, [r3, #8]
 8002d28:	4620      	mov	r0, r4
        p--;
 8002d2a:	3d01      	subs	r5, #1
    }
    if ((c == 8) || (c == 127)) {
      if (p != line) {
        chSequentialStreamPut(chp, c);
        chSequentialStreamPut(chp, 0x20);
        chSequentialStreamPut(chp, c);
 8002d2c:	4798      	blx	r3
 8002d2e:	e7cd      	b.n	8002ccc <shell_thread.13239+0x2c>
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
      return true;
    if (c == 4) {
      chprintf(chp, "^D");
 8002d30:	4620      	mov	r0, r4
 8002d32:	495a      	ldr	r1, [pc, #360]	; (8002e9c <shell_thread.13239+0x1fc>)
 8002d34:	f002 fc2c 	bl	8005590 <chprintf.13255>
  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
  while (true) {
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
 8002d38:	4620      	mov	r0, r4
 8002d3a:	4959      	ldr	r1, [pc, #356]	; (8002ea0 <shell_thread.13239+0x200>)
 8002d3c:	f002 fc28 	bl	8005590 <chprintf.13255>
 8002d40:	2320      	movs	r3, #32
 8002d42:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8002d46:	2100      	movs	r1, #0
 8002d48:	4856      	ldr	r0, [pc, #344]	; (8002ea4 <shell_thread.13239+0x204>)
 8002d4a:	f7fe fd41 	bl	80017d0 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 8002d4e:	2000      	movs	r0, #0
 8002d50:	f7ff f95e 	bl	8002010 <chThdExitS>
        chprintf(chp, " ?\r\n");
      }
    }
  }
  shellExit(MSG_OK);
}
 8002d54:	b018      	add	sp, #96	; 0x60
 8002d56:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, "\r\n");
 8002d5a:	4953      	ldr	r1, [pc, #332]	; (8002ea8 <shell_thread.13239+0x208>)
 8002d5c:	4620      	mov	r0, r4
 8002d5e:	f002 fc17 	bl	8005590 <chprintf.13255>
      *p = 0;
 8002d62:	2300      	movs	r3, #0
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 8002d64:	a902      	add	r1, sp, #8
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, "\r\n");
      *p = 0;
 8002d66:	702b      	strb	r3, [r5, #0]
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 8002d68:	4630      	mov	r0, r6
    cmd = lp;
    n = 0;
 8002d6a:	461d      	mov	r5, r3
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 8002d6c:	f002 fb48 	bl	8005400 <_strtok.13250.constprop.5>
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8002d70:	a902      	add	r1, sp, #8
    chprintf(chp, "ch> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 8002d72:	4682      	mov	sl, r0
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8002d74:	2000      	movs	r0, #0
 8002d76:	f10d 0908 	add.w	r9, sp, #8
 8002d7a:	f002 fb41 	bl	8005400 <_strtok.13250.constprop.5>
 8002d7e:	b150      	cbz	r0, 8002d96 <shell_thread.13239+0xf6>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8002d80:	2d04      	cmp	r5, #4
 8002d82:	d01d      	beq.n	8002dc0 <shell_thread.13239+0x120>
        chprintf(chp, "too many arguments\r\n");
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 8002d84:	f849 0f04 	str.w	r0, [r9, #4]!
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8002d88:	a902      	add	r1, sp, #8
 8002d8a:	2000      	movs	r0, #0
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments\r\n");
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 8002d8c:	3501      	adds	r5, #1
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8002d8e:	f002 fb37 	bl	8005400 <_strtok.13250.constprop.5>
 8002d92:	2800      	cmp	r0, #0
 8002d94:	d1f4      	bne.n	8002d80 <shell_thread.13239+0xe0>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 8002d96:	aa18      	add	r2, sp, #96	; 0x60
 8002d98:	eb02 0385 	add.w	r3, r2, r5, lsl #2
 8002d9c:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
 8002da0:	f1ba 0f00 	cmp.w	sl, #0
 8002da4:	d08d      	beq.n	8002cc2 <shell_thread.13239+0x22>
      if (strcasecmp(cmd, "exit") == 0) {
 8002da6:	4650      	mov	r0, sl
 8002da8:	4940      	ldr	r1, [pc, #256]	; (8002eac <shell_thread.13239+0x20c>)
 8002daa:	f003 fe19 	bl	80069e0 <strcasecmp>
 8002dae:	b970      	cbnz	r0, 8002dce <shell_thread.13239+0x12e>
        if (n > 0) {
 8002db0:	2d00      	cmp	r5, #0
 8002db2:	d0c5      	beq.n	8002d40 <shell_thread.13239+0xa0>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8002db4:	4620      	mov	r0, r4
 8002db6:	493e      	ldr	r1, [pc, #248]	; (8002eb0 <shell_thread.13239+0x210>)
 8002db8:	4a3c      	ldr	r2, [pc, #240]	; (8002eac <shell_thread.13239+0x20c>)
 8002dba:	f002 fbe9 	bl	8005590 <chprintf.13255>
 8002dbe:	e780      	b.n	8002cc2 <shell_thread.13239+0x22>
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments\r\n");
 8002dc0:	4620      	mov	r0, r4
 8002dc2:	493c      	ldr	r1, [pc, #240]	; (8002eb4 <shell_thread.13239+0x214>)
 8002dc4:	f002 fbe4 	bl	8005590 <chprintf.13255>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 8002dc8:	2300      	movs	r3, #0
 8002dca:	9307      	str	r3, [sp, #28]
 8002dcc:	e779      	b.n	8002cc2 <shell_thread.13239+0x22>
          usage(chp, "exit");
          continue;
        }
        break;
      }
      else if (strcasecmp(cmd, "help") == 0) {
 8002dce:	4650      	mov	r0, sl
 8002dd0:	4939      	ldr	r1, [pc, #228]	; (8002eb8 <shell_thread.13239+0x218>)
 8002dd2:	f003 fe05 	bl	80069e0 <strcasecmp>
 8002dd6:	b930      	cbnz	r0, 8002de6 <shell_thread.13239+0x146>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8002dd8:	4620      	mov	r0, r4
          continue;
        }
        break;
      }
      else if (strcasecmp(cmd, "help") == 0) {
        if (n > 0) {
 8002dda:	b1cd      	cbz	r5, 8002e10 <shell_thread.13239+0x170>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8002ddc:	4934      	ldr	r1, [pc, #208]	; (8002eb0 <shell_thread.13239+0x210>)
 8002dde:	4a36      	ldr	r2, [pc, #216]	; (8002eb8 <shell_thread.13239+0x218>)
 8002de0:	f002 fbd6 	bl	8005590 <chprintf.13255>
 8002de4:	e76d      	b.n	8002cc2 <shell_thread.13239+0x22>
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8002de6:	4b35      	ldr	r3, [pc, #212]	; (8002ebc <shell_thread.13239+0x21c>)
 8002de8:	6818      	ldr	r0, [r3, #0]
 8002dea:	4699      	mov	r9, r3
 8002dec:	b920      	cbnz	r0, 8002df8 <shell_thread.13239+0x158>
 8002dee:	e032      	b.n	8002e56 <shell_thread.13239+0x1b6>
 8002df0:	f859 0f08 	ldr.w	r0, [r9, #8]!
 8002df4:	2800      	cmp	r0, #0
 8002df6:	d02e      	beq.n	8002e56 <shell_thread.13239+0x1b6>
    if (strcasecmp(scp->sc_name, name) == 0) {
 8002df8:	4651      	mov	r1, sl
 8002dfa:	f003 fdf1 	bl	80069e0 <strcasecmp>
 8002dfe:	2800      	cmp	r0, #0
 8002e00:	d1f6      	bne.n	8002df0 <shell_thread.13239+0x150>
      scp->sc_function(chp, argc, argv);
 8002e02:	f8d9 3004 	ldr.w	r3, [r9, #4]
 8002e06:	4629      	mov	r1, r5
 8002e08:	4620      	mov	r0, r4
 8002e0a:	aa03      	add	r2, sp, #12
 8002e0c:	4798      	blx	r3
 8002e0e:	e758      	b.n	8002cc2 <shell_thread.13239+0x22>
      else if (strcasecmp(cmd, "help") == 0) {
        if (n > 0) {
          usage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help exit ");
 8002e10:	492b      	ldr	r1, [pc, #172]	; (8002ec0 <shell_thread.13239+0x220>)
 8002e12:	f002 fbbd 	bl	8005590 <chprintf.13255>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8002e16:	4b29      	ldr	r3, [pc, #164]	; (8002ebc <shell_thread.13239+0x21c>)
 8002e18:	681a      	ldr	r2, [r3, #0]
 8002e1a:	461d      	mov	r5, r3
 8002e1c:	b13a      	cbz	r2, 8002e2e <shell_thread.13239+0x18e>
    chprintf(chp, "%s ", scp->sc_name);
 8002e1e:	4620      	mov	r0, r4
 8002e20:	4928      	ldr	r1, [pc, #160]	; (8002ec4 <shell_thread.13239+0x224>)
 8002e22:	f002 fbb5 	bl	8005590 <chprintf.13255>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8002e26:	f855 2f08 	ldr.w	r2, [r5, #8]!
 8002e2a:	2a00      	cmp	r2, #0
 8002e2c:	d1f7      	bne.n	8002e1e <shell_thread.13239+0x17e>
          usage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help exit ");
        list_commands(chp, local_commands);
        if (scp != NULL)
 8002e2e:	f1b8 0f00 	cmp.w	r8, #0
 8002e32:	d00b      	beq.n	8002e4c <shell_thread.13239+0x1ac>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8002e34:	f8d8 2000 	ldr.w	r2, [r8]
 8002e38:	b142      	cbz	r2, 8002e4c <shell_thread.13239+0x1ac>
 8002e3a:	4645      	mov	r5, r8
    chprintf(chp, "%s ", scp->sc_name);
 8002e3c:	4620      	mov	r0, r4
 8002e3e:	4921      	ldr	r1, [pc, #132]	; (8002ec4 <shell_thread.13239+0x224>)
 8002e40:	f002 fba6 	bl	8005590 <chprintf.13255>
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8002e44:	f855 2f08 	ldr.w	r2, [r5, #8]!
 8002e48:	2a00      	cmp	r2, #0
 8002e4a:	d1f7      	bne.n	8002e3c <shell_thread.13239+0x19c>
        }
        chprintf(chp, "Commands: help exit ");
        list_commands(chp, local_commands);
        if (scp != NULL)
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
 8002e4c:	4620      	mov	r0, r4
 8002e4e:	4916      	ldr	r1, [pc, #88]	; (8002ea8 <shell_thread.13239+0x208>)
 8002e50:	f002 fb9e 	bl	8005590 <chprintf.13255>
 8002e54:	e735      	b.n	8002cc2 <shell_thread.13239+0x22>
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 8002e56:	f1b8 0f00 	cmp.w	r8, #0
 8002e5a:	d00d      	beq.n	8002e78 <shell_thread.13239+0x1d8>
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8002e5c:	f8d8 0000 	ldr.w	r0, [r8]
 8002e60:	b150      	cbz	r0, 8002e78 <shell_thread.13239+0x1d8>
 8002e62:	46c1      	mov	r9, r8
 8002e64:	e002      	b.n	8002e6c <shell_thread.13239+0x1cc>
 8002e66:	f859 0f08 	ldr.w	r0, [r9, #8]!
 8002e6a:	b128      	cbz	r0, 8002e78 <shell_thread.13239+0x1d8>
    if (strcasecmp(scp->sc_name, name) == 0) {
 8002e6c:	4651      	mov	r1, sl
 8002e6e:	f003 fdb7 	bl	80069e0 <strcasecmp>
 8002e72:	2800      	cmp	r0, #0
 8002e74:	d1f7      	bne.n	8002e66 <shell_thread.13239+0x1c6>
 8002e76:	e7c4      	b.n	8002e02 <shell_thread.13239+0x162>
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
        chprintf(chp, "%s", cmd);
 8002e78:	4652      	mov	r2, sl
 8002e7a:	4620      	mov	r0, r4
 8002e7c:	4912      	ldr	r1, [pc, #72]	; (8002ec8 <shell_thread.13239+0x228>)
 8002e7e:	f002 fb87 	bl	8005590 <chprintf.13255>
        chprintf(chp, " ?\r\n");
 8002e82:	4620      	mov	r0, r4
 8002e84:	4911      	ldr	r1, [pc, #68]	; (8002ecc <shell_thread.13239+0x22c>)
 8002e86:	f002 fb83 	bl	8005590 <chprintf.13255>
 8002e8a:	e71a      	b.n	8002cc2 <shell_thread.13239+0x22>
 8002e8c:	200016a8 	.word	0x200016a8
 8002e90:	08006e00 	.word	0x08006e00
 8002e94:	08006e08 	.word	0x08006e08
 8002e98:	08006e20 	.word	0x08006e20
 8002e9c:	08006e28 	.word	0x08006e28
 8002ea0:	08006e88 	.word	0x08006e88
 8002ea4:	20001d7c 	.word	0x20001d7c
 8002ea8:	08007264 	.word	0x08007264
 8002eac:	08006e44 	.word	0x08006e44
 8002eb0:	08006e4c 	.word	0x08006e4c
 8002eb4:	08006e2c 	.word	0x08006e2c
 8002eb8:	08006e58 	.word	0x08006e58
 8002ebc:	20000834 	.word	0x20000834
 8002ec0:	08006e60 	.word	0x08006e60
 8002ec4:	08006e78 	.word	0x08006e78
 8002ec8:	08006e7c 	.word	0x08006e7c
 8002ecc:	08006e80 	.word	0x08006e80

08002ed0 <main>:
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8002ed0:	4bcc      	ldr	r3, [pc, #816]	; (8003204 <main+0x334>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002ed2:	48cd      	ldr	r0, [pc, #820]	; (8003208 <main+0x338>)
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
 8002ed4:	691a      	ldr	r2, [r3, #16]
 8002ed6:	f04f 31ff 	mov.w	r1, #4294967295
 8002eda:	2200      	movs	r2, #0

/*
 * Application entry point.
 */

int main(void) {
 8002edc:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8002ee0:	6119      	str	r1, [r3, #16]
 8002ee2:	611a      	str	r2, [r3, #16]
  rccResetAHB2(~0);
 8002ee4:	695c      	ldr	r4, [r3, #20]
 8002ee6:	6159      	str	r1, [r3, #20]
 8002ee8:	615a      	str	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8002eea:	6a1c      	ldr	r4, [r3, #32]
 8002eec:	f064 5480 	orn	r4, r4, #268435456	; 0x10000000
 8002ef0:	621c      	str	r4, [r3, #32]
 8002ef2:	621a      	str	r2, [r3, #32]
  rccResetAPB2(~0);
 8002ef4:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8002ef6:	6259      	str	r1, [r3, #36]	; 0x24
 8002ef8:	625a      	str	r2, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8002efa:	6c19      	ldr	r1, [r3, #64]	; 0x40
 8002efc:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8002f00:	6419      	str	r1, [r3, #64]	; 0x40
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002f02:	6801      	ldr	r1, [r0, #0]
 8002f04:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8002f08:	6001      	str	r1, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8002f0a:	6f19      	ldr	r1, [r3, #112]	; 0x70
 8002f0c:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8002f10:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8002f14:	b08b      	sub	sp, #44	; 0x2c
 8002f16:	d003      	beq.n	8002f20 <main+0x50>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8002f18:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8002f1c:	6719      	str	r1, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8002f1e:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8002f20:	4bb9      	ldr	r3, [pc, #740]	; (8003208 <main+0x338>)
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8002f22:	4ab8      	ldr	r2, [pc, #736]	; (8003204 <main+0x334>)
 8002f24:	6859      	ldr	r1, [r3, #4]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002f26:	48b9      	ldr	r0, [pc, #740]	; (800320c <main+0x33c>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8002f28:	f8df a318 	ldr.w	sl, [pc, #792]	; 8003244 <main+0x374>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002f2c:	f8df 9318 	ldr.w	r9, [pc, #792]	; 8003248 <main+0x378>
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8002f30:	4cb7      	ldr	r4, [pc, #732]	; (8003210 <main+0x340>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002f32:	f8df 8318 	ldr.w	r8, [pc, #792]	; 800324c <main+0x37c>
 8002f36:	f8df c318 	ldr.w	ip, [pc, #792]	; 8003250 <main+0x380>
 8002f3a:	4db6      	ldr	r5, [pc, #728]	; (8003214 <main+0x344>)
 8002f3c:	f8df e314 	ldr.w	lr, [pc, #788]	; 8003254 <main+0x384>
 8002f40:	4fb5      	ldr	r7, [pc, #724]	; (8003218 <main+0x348>)
 8002f42:	4eb6      	ldr	r6, [pc, #728]	; (800321c <main+0x34c>)
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {

  canp->state    = CAN_STOP;
 8002f44:	f8df b310 	ldr.w	fp, [pc, #784]	; 8003258 <main+0x388>
 8002f48:	f421 7100 	bic.w	r1, r1, #512	; 0x200
 8002f4c:	6059      	str	r1, [r3, #4]
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
 8002f4e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8002f50:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8002f54:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8002f58:	6313      	str	r3, [r2, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8002f5a:	6d11      	ldr	r1, [r2, #80]	; 0x50
 8002f5c:	ea6f 2151 	mvn.w	r1, r1, lsr #9
 8002f60:	ea6f 2141 	mvn.w	r1, r1, lsl #9
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002f64:	2300      	movs	r3, #0
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
 8002f66:	6511      	str	r1, [r2, #80]	; 0x50
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8002f68:	f46f 41a8 	mvn.w	r1, #21504	; 0x5400
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002f6c:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002f6e:	6081      	str	r1, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8002f70:	f8c0 a00c 	str.w	sl, [r0, #12]
  gpiop->ODR     = config->odr;
 8002f74:	f64f 71ff 	movw	r1, #65535	; 0xffff
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8002f78:	f8df a2e0 	ldr.w	sl, [pc, #736]	; 800325c <main+0x38c>
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8002f7c:	6141      	str	r1, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8002f7e:	6204      	str	r4, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8002f80:	f8c0 a024 	str.w	sl, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002f84:	4ca6      	ldr	r4, [pc, #664]	; (8003220 <main+0x350>)
 8002f86:	6004      	str	r4, [r0, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002f88:	f44f 7a10 	mov.w	sl, #576	; 0x240
 8002f8c:	f8c9 a004 	str.w	sl, [r9, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002f90:	f04f 30ff 	mov.w	r0, #4294967295
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8002f94:	f04f 6a80 	mov.w	sl, #67108864	; 0x4000000

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8002f98:	4ca2      	ldr	r4, [pc, #648]	; (8003224 <main+0x354>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8002f9a:	f8c9 0008 	str.w	r0, [r9, #8]
  gpiop->PUPDR   = config->pupdr;
 8002f9e:	f8c9 400c 	str.w	r4, [r9, #12]
  gpiop->ODR     = config->odr;
 8002fa2:	f8c9 1014 	str.w	r1, [r9, #20]
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8002fa6:	2440      	movs	r4, #64	; 0x40

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8002fa8:	f8c9 a020 	str.w	sl, [r9, #32]
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8002fac:	f8df a2b0 	ldr.w	sl, [pc, #688]	; 8003260 <main+0x390>
  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8002fb0:	f8c9 4024 	str.w	r4, [r9, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002fb4:	f8c9 a000 	str.w	sl, [r9]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8002fb8:	f109 59a2 	add.w	r9, r9, #339738624	; 0x14400000
 8002fbc:	f509 3944 	add.w	r9, r9, #200704	; 0x31000
 8002fc0:	f509 79aa 	add.w	r9, r9, #340	; 0x154
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002fc4:	f8c8 3004 	str.w	r3, [r8, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002fc8:	f8c8 0008 	str.w	r0, [r8, #8]
  gpiop->PUPDR   = config->pupdr;
 8002fcc:	f8c8 900c 	str.w	r9, [r8, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8002fd0:	f04f 49c0 	mov.w	r9, #1610612736	; 0x60000000
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8002fd4:	f8c8 1014 	str.w	r1, [r8, #20]
  gpiop->AFRL    = config->afrl;
 8002fd8:	f8c8 9020 	str.w	r9, [r8, #32]
  gpiop->AFRH    = config->afrh;
 8002fdc:	f8df 9284 	ldr.w	r9, [pc, #644]	; 8003264 <main+0x394>
 8002fe0:	f8c8 9024 	str.w	r9, [r8, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8002fe4:	f8df 9280 	ldr.w	r9, [pc, #640]	; 8003268 <main+0x398>
 8002fe8:	f8c8 9000 	str.w	r9, [r8]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8002fec:	f8df 827c 	ldr.w	r8, [pc, #636]	; 800326c <main+0x39c>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8002ff0:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8002ff4:	f8cc 0008 	str.w	r0, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
 8002ff8:	f8cc 800c 	str.w	r8, [ip, #12]
  gpiop->ODR     = config->odr;
 8002ffc:	f640 78ff 	movw	r8, #4095	; 0xfff
 8003000:	f8cc 8014 	str.w	r8, [ip, #20]
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8003004:	f8df 8268 	ldr.w	r8, [pc, #616]	; 8003270 <main+0x3a0>

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8003008:	f8cc 3020 	str.w	r3, [ip, #32]
  gpiop->AFRH    = config->afrh;
 800300c:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8003010:	f8cc 8000 	str.w	r8, [ip]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003014:	f8ce 3004 	str.w	r3, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8003018:	f8ce 0008 	str.w	r0, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 800301c:	f8ce 300c 	str.w	r3, [lr, #12]
  gpiop->ODR     = config->odr;
 8003020:	f8ce 1014 	str.w	r1, [lr, #20]
  gpiop->AFRL    = config->afrl;
 8003024:	f8ce 3020 	str.w	r3, [lr, #32]
  gpiop->AFRH    = config->afrh;
 8003028:	f8ce 3024 	str.w	r3, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800302c:	f8ce 4000 	str.w	r4, [lr]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8003030:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8003032:	60b8      	str	r0, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8003034:	60fb      	str	r3, [r7, #12]
  gpiop->ODR     = config->odr;
 8003036:	6179      	str	r1, [r7, #20]
  gpiop->AFRL    = config->afrl;
 8003038:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
 800303a:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800303c:	603b      	str	r3, [r7, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800303e:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8003040:	60b0      	str	r0, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8003042:	60f3      	str	r3, [r6, #12]
  gpiop->ODR     = config->odr;
 8003044:	6171      	str	r1, [r6, #20]
  gpiop->AFRL    = config->afrl;
 8003046:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
 8003048:	6273      	str	r3, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800304a:	6033      	str	r3, [r6, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800304c:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
 800304e:	60a8      	str	r0, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
 8003050:	60eb      	str	r3, [r5, #12]
  gpiop->ODR     = config->odr;
 8003052:	6169      	str	r1, [r5, #20]
  gpiop->AFRL    = config->afrl;
 8003054:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
 8003056:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8003058:	602b      	str	r3, [r5, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800305a:	f8c5 3404 	str.w	r3, [r5, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
 800305e:	f8c5 0408 	str.w	r0, [r5, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
 8003062:	f8c5 340c 	str.w	r3, [r5, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
 8003066:	f8c5 1414 	str.w	r1, [r5, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
 800306a:	f8c5 3420 	str.w	r3, [r5, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
 800306e:	f8c5 3424 	str.w	r3, [r5, #1060]	; 0x424
  gpiop->MODER   = config->moder;
 8003072:	f8c5 3400 	str.w	r3, [r5, #1024]	; 0x400
static void can_lld_set_filters(uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);
 8003076:	6c10      	ldr	r0, [r2, #64]	; 0x40
 8003078:	f8df a1f8 	ldr.w	sl, [pc, #504]	; 8003274 <main+0x3a4>
void can_lld_init(void) {

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
  CAND1.can = CAN1;
 800307c:	496a      	ldr	r1, [pc, #424]	; (8003228 <main+0x358>)
  canp->config   = NULL;
 800307e:	f8cb 3004 	str.w	r3, [fp, #4]
 *
 * @init
 */
void canObjectInit(CANDriver *canp) {

  canp->state    = CAN_STOP;
 8003082:	f04f 0c01 	mov.w	ip, #1
static void can_lld_set_filters(uint32_t can2sb,
                                uint32_t num,
                                const CANFilter *cfp) {

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);
 8003086:	f040 7000 	orr.w	r0, r0, #33554432	; 0x2000000
 800308a:	f88b c000 	strb.w	ip, [fp]
 800308e:	f88a c000 	strb.w	ip, [sl]
 8003092:	6410      	str	r0, [r2, #64]	; 0x40

  /* Filters initialization.*/
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
 8003094:	f8d1 0200 	ldr.w	r0, [r1, #512]	; 0x200
  canp->config   = NULL;
 8003098:	f8ca 3004 	str.w	r3, [sl, #4]
 800309c:	0c00      	lsrs	r0, r0, #16
 800309e:	0400      	lsls	r0, r0, #16
 80030a0:	f440 6060 	orr.w	r0, r0, #3584	; 0xe00
    CAN1->sFilterRegister[can2sb].FR2 = 0;
#endif
    CAN1->FM1R = 0;
    CAN1->FFA1R = 0;
#if STM32_HAS_CAN2
    CAN1->FS1R = 1 | (1 << can2sb);
 80030a4:	f244 0501 	movw	r5, #16385	; 0x4001

  /* Temporarily enabling CAN1 clock.*/
  rccEnableCAN1(FALSE);

  /* Filters initialization.*/
  CAN1->FMR = (CAN1->FMR & 0xFFFF0000) | (can2sb << 8) | CAN_FMR_FINIT;
 80030a8:	ea40 000c 	orr.w	r0, r0, ip
 80030ac:	f8c1 0200 	str.w	r0, [r1, #512]	; 0x200
    }
  }
  else {
    /* Setting up a single default filter that enables everything for both
       CANs.*/
    CAN1->sFilterRegister[0].FR1 = 0;
 80030b0:	f8c1 3240 	str.w	r3, [r1, #576]	; 0x240
    CAN1->sFilterRegister[0].FR2 = 0;
 80030b4:	f8c1 3244 	str.w	r3, [r1, #580]	; 0x244
#if STM32_HAS_CAN2
    CAN1->sFilterRegister[can2sb].FR1 = 0;
 80030b8:	f8c1 32b0 	str.w	r3, [r1, #688]	; 0x2b0
    CAN1->sFilterRegister[can2sb].FR2 = 0;
 80030bc:	f8c1 32b4 	str.w	r3, [r1, #692]	; 0x2b4
#endif
    CAN1->FM1R = 0;
 80030c0:	f8c1 3204 	str.w	r3, [r1, #516]	; 0x204
    CAN1->FFA1R = 0;
 80030c4:	f8c1 3214 	str.w	r3, [r1, #532]	; 0x214
#if STM32_HAS_CAN2
    CAN1->FS1R = 1 | (1 << can2sb);
 80030c8:	f8c1 520c 	str.w	r5, [r1, #524]	; 0x20c
    CAN1->FA1R = 1 | (1 << can2sb);
 80030cc:	f8c1 521c 	str.w	r5, [r1, #540]	; 0x21c
#else
    CAN1->FS1R = 1;
    CAN1->FA1R = 1;
#endif
  }
  CAN1->FMR &= ~CAN_FMR_FINIT;
 80030d0:	f8d1 e200 	ldr.w	lr, [r1, #512]	; 0x200
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 80030d4:	4c55      	ldr	r4, [pc, #340]	; (800322c <main+0x35c>)
void can_lld_init(void) {

#if STM32_CAN_USE_CAN1
  /* Driver initialization.*/
  canObjectInit(&CAND1);
  CAND1.can = CAN1;
 80030d6:	f8cb 1024 	str.w	r1, [fp, #36]	; 0x24
#endif
#if STM32_CAN_USE_CAN2
  /* Driver initialization.*/
  canObjectInit(&CAND2);
  CAND2.can = CAN2;
 80030da:	f5a6 36d8 	sub.w	r6, r6, #110592	; 0x1b000
 80030de:	f8ca 6024 	str.w	r6, [sl, #36]	; 0x24
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 80030e2:	f10b 0718 	add.w	r7, fp, #24
 80030e6:	f10b 061c 	add.w	r6, fp, #28
 80030ea:	f10b 0520 	add.w	r5, fp, #32
 80030ee:	f10a 0018 	add.w	r0, sl, #24
 80030f2:	f10a 091c 	add.w	r9, sl, #28
#else
    CAN1->FS1R = 1;
    CAN1->FA1R = 1;
#endif
  }
  CAN1->FMR &= ~CAN_FMR_FINIT;
 80030f6:	f02e 0e01 	bic.w	lr, lr, #1
 80030fa:	f10a 0820 	add.w	r8, sl, #32
 80030fe:	f8cb 7018 	str.w	r7, [fp, #24]
 8003102:	f8cb 601c 	str.w	r6, [fp, #28]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003106:	f10b 0708 	add.w	r7, fp, #8
 800310a:	f10b 0610 	add.w	r6, fp, #16
 800310e:	f8cb 5020 	str.w	r5, [fp, #32]
 8003112:	f8ca 0018 	str.w	r0, [sl, #24]
 8003116:	f10a 0508 	add.w	r5, sl, #8
 800311a:	f10a 0010 	add.w	r0, sl, #16
 800311e:	f8ca 901c 	str.w	r9, [sl, #28]
 8003122:	f8ca 8020 	str.w	r8, [sl, #32]
 8003126:	f8cb 7008 	str.w	r7, [fp, #8]
  tqp->p_prev = (thread_t *)tqp;
 800312a:	f8cb 700c 	str.w	r7, [fp, #12]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800312e:	f8cb 6010 	str.w	r6, [fp, #16]
  tqp->p_prev = (thread_t *)tqp;
 8003132:	f8cb 6014 	str.w	r6, [fp, #20]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003136:	f8ca 5008 	str.w	r5, [sl, #8]
  tqp->p_prev = (thread_t *)tqp;
 800313a:	f8ca 500c 	str.w	r5, [sl, #12]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800313e:	f8ca 0010 	str.w	r0, [sl, #16]
  tqp->p_prev = (thread_t *)tqp;
 8003142:	f8ca 0014 	str.w	r0, [sl, #20]
 8003146:	f8c1 e200 	str.w	lr, [r1, #512]	; 0x200

  /* Clock disabled, it will be enabled again in can_lld_start().*/
  rccDisableCAN1(FALSE);
 800314a:	f8d2 8040 	ldr.w	r8, [r2, #64]	; 0x40
 800314e:	4d38      	ldr	r5, [pc, #224]	; (8003230 <main+0x360>)
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 8003150:	4e38      	ldr	r6, [pc, #224]	; (8003234 <main+0x364>)
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8003152:	f884 c008 	strb.w	ip, [r4, #8]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8003156:	4620      	mov	r0, r4
 8003158:	f028 7800 	bic.w	r8, r8, #33554432	; 0x2000000
 800315c:	f8c2 8040 	str.w	r8, [r2, #64]	; 0x40
 8003160:	f840 5b04 	str.w	r5, [r0], #4
 8003164:	4f34      	ldr	r7, [pc, #208]	; (8003238 <main+0x368>)

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
  PWMD1.tim = STM32_TIM1;
 8003166:	f8df e110 	ldr.w	lr, [pc, #272]	; 8003278 <main+0x3a8>
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 800316a:	4934      	ldr	r1, [pc, #208]	; (800323c <main+0x36c>)
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 800316c:	6163      	str	r3, [r4, #20]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 800316e:	f04f 0820 	mov.w	r8, #32
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8003172:	f104 0294 	add.w	r2, r4, #148	; 0x94
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8003176:	2504      	movs	r5, #4
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8003178:	f8c4 8038 	str.w	r8, [r4, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 800317c:	6422      	str	r2, [r4, #64]	; 0x40

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
  PWMD4.channels = STM32_TIM4_CHANNELS;
  PWMD4.tim = STM32_TIM4;
 800317e:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 800327c <main+0x3ac>
 8003182:	6060      	str	r0, [r4, #4]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003184:	f104 020c 	add.w	r2, r4, #12
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8003188:	f104 0054 	add.w	r0, r4, #84	; 0x54
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {

  extp->state  = EXT_STOP;
 800318c:	f8df 90f0 	ldr.w	r9, [pc, #240]	; 8003280 <main+0x3b0>

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
  PWMD1.tim = STM32_TIM1;
 8003190:	f8c6 e018 	str.w	lr, [r6, #24]
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8003194:	f104 0e74 	add.w	lr, r4, #116	; 0x74
void pwm_lld_init(void) {

#if STM32_PWM_USE_TIM1
  /* Driver initialization.*/
  pwmObjectInit(&PWMD1);
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8003198:	7435      	strb	r5, [r6, #16]
#endif

#if STM32_PWM_USE_TIM4
  /* Driver initialization.*/
  pwmObjectInit(&PWMD4);
  PWMD4.channels = STM32_TIM4_CHANNELS;
 800319a:	743d      	strb	r5, [r7, #16]
  PWMD4.tim = STM32_TIM4;
 800319c:	f8c7 8018 	str.w	r8, [r7, #24]
 80031a0:	f104 0530 	add.w	r5, r4, #48	; 0x30
 80031a4:	60e2      	str	r2, [r4, #12]
  tqp->p_prev = (thread_t *)tqp;
 80031a6:	6122      	str	r2, [r4, #16]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 80031a8:	61a0      	str	r0, [r4, #24]
  iqp->q_rdptr   = bp;
 80031aa:	6260      	str	r0, [r4, #36]	; 0x24
  iqp->q_wrptr   = bp;
 80031ac:	6220      	str	r0, [r4, #32]
  iqp->q_top     = bp + size;
 80031ae:	f8c4 e01c 	str.w	lr, [r4, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 80031b2:	f8c4 e03c 	str.w	lr, [r4, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 80031b6:	f8c4 e048 	str.w	lr, [r4, #72]	; 0x48
  oqp->q_wrptr   = bp;
 80031ba:	f8c4 e044 	str.w	lr, [r4, #68]	; 0x44
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 80031be:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 8003284 <main+0x3b4>
  SD2.usart = USART2;
#endif

#if STM32_SERIAL_USE_USART3
  sdObjectInit(&SD3, NULL, notify3);
  SD3.usart = USART3;
 80031c2:	4a1f      	ldr	r2, [pc, #124]	; (8003240 <main+0x370>)
  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;
 80031c4:	f8df e0c0 	ldr.w	lr, [pc, #192]	; 8003288 <main+0x3b8>
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 80031c8:	62a3      	str	r3, [r4, #40]	; 0x28

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 80031ca:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
  extp->config = NULL;
 80031ce:	f8c9 3004 	str.w	r3, [r9, #4]
  pwmp->config   = NULL;
 80031d2:	6073      	str	r3, [r6, #4]
  pwmp->enabled  = 0;
 80031d4:	60f3      	str	r3, [r6, #12]
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
  pwmp->config   = NULL;
 80031d6:	607b      	str	r3, [r7, #4]
  pwmp->enabled  = 0;
 80031d8:	60fb      	str	r3, [r7, #12]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80031da:	6325      	str	r5, [r4, #48]	; 0x30
  iqp->q_link    = link;
 80031dc:	62e4      	str	r4, [r4, #44]	; 0x2c
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {

  extp->state  = EXT_STOP;
 80031de:	f889 c000 	strb.w	ip, [r9]
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 80031e2:	f886 c000 	strb.w	ip, [r6]
 80031e6:	f887 c000 	strb.w	ip, [r7]
  tqp->p_prev = (thread_t *)tqp;
 80031ea:	6365      	str	r5, [r4, #52]	; 0x34
  usbp->config       = NULL;
 80031ec:	604b      	str	r3, [r1, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 80031ee:	61cb      	str	r3, [r1, #28]
    usbp->out_params[i] = NULL;
 80031f0:	628b      	str	r3, [r1, #40]	; 0x28
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 80031f2:	620b      	str	r3, [r1, #32]
    usbp->out_params[i] = NULL;
 80031f4:	62cb      	str	r3, [r1, #44]	; 0x2c
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->in_params[i]  = NULL;
 80031f6:	624b      	str	r3, [r1, #36]	; 0x24
    usbp->out_params[i] = NULL;
 80031f8:	630b      	str	r3, [r1, #48]	; 0x30
  }
  usbp->transmitting = 0;
 80031fa:	810b      	strh	r3, [r1, #8]
  usbp->receiving    = 0;
 80031fc:	814b      	strh	r3, [r1, #10]
void usb_lld_init(void) {

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
 80031fe:	660b      	str	r3, [r1, #96]	; 0x60
 8003200:	e044      	b.n	800328c <main+0x3bc>
 8003202:	bf00      	nop
 8003204:	40023800 	.word	0x40023800
 8003208:	40007000 	.word	0x40007000
 800320c:	40020000 	.word	0x40020000
 8003210:	55560000 	.word	0x55560000
 8003214:	40021c00 	.word	0x40021c00
 8003218:	40021400 	.word	0x40021400
 800321c:	40021800 	.word	0x40021800
 8003220:	2aa0aa00 	.word	0x2aa0aa00
 8003224:	55514515 	.word	0x55514515
 8003228:	40006400 	.word	0x40006400
 800322c:	20001368 	.word	0x20001368
 8003230:	08006ec0 	.word	0x08006ec0
 8003234:	20001bd0 	.word	0x20001bd0
 8003238:	20001bec 	.word	0x20001bec
 800323c:	200011b8 	.word	0x200011b8
 8003240:	40004800 	.word	0x40004800
 8003244:	40010054 	.word	0x40010054
 8003248:	40020400 	.word	0x40020400
 800324c:	40020800 	.word	0x40020800
 8003250:	40020c00 	.word	0x40020c00
 8003254:	40021000 	.word	0x40021000
 8003258:	20000d58 	.word	0x20000d58
 800325c:	000aaa00 	.word	0x000aaa00
 8003260:	00082080 	.word	0x00082080
 8003264:	00060600 	.word	0x00060600
 8003268:	02208001 	.word	0x02208001
 800326c:	00555055 	.word	0x00555055
 8003270:	55000100 	.word	0x55000100
 8003274:	20000d80 	.word	0x20000d80
 8003278:	40010000 	.word	0x40010000
 800327c:	40000800 	.word	0x40000800
 8003280:	2000169c 	.word	0x2000169c
 8003284:	08005281 	.word	0x08005281
 8003288:	08006dc0 	.word	0x08006dc0
  USBD1.otg       = OTG_FS;
  USBD1.otgparams = &fsparams;

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 800328c:	664b      	str	r3, [r1, #100]	; 0x64
 800328e:	f101 0568 	add.w	r5, r1, #104	; 0x68
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
 8003292:	f881 c000 	strb.w	ip, [r1]

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
  USBD1.wait      = NULL;
  USBD1.otg       = OTG_FS;
 8003296:	6508      	str	r0, [r1, #80]	; 0x50
  USBD1.otgparams = &fsparams;
 8003298:	f8c1 e054 	str.w	lr, [r1, #84]	; 0x54
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 800329c:	f8c4 804c 	str.w	r8, [r4, #76]	; 0x4c
  oqp->q_link    = link;
 80032a0:	6524      	str	r4, [r4, #80]	; 0x50
 80032a2:	f8c4 2094 	str.w	r2, [r4, #148]	; 0x94
 80032a6:	31ac      	adds	r1, #172	; 0xac
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 80032a8:	23ff      	movs	r3, #255	; 0xff
 80032aa:	f805 3b01 	strb.w	r3, [r5], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80032ae:	428d      	cmp	r5, r1
 80032b0:	d3fb      	bcc.n	80032aa <main+0x3da>
 80032b2:	4bc4      	ldr	r3, [pc, #784]	; (80035c4 <main+0x6f4>)
    *startp++ = v;
 80032b4:	2155      	movs	r1, #85	; 0x55
 80032b6:	f503 7282 	add.w	r2, r3, #260	; 0x104
 80032ba:	f803 1b01 	strb.w	r1, [r3], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80032be:	4293      	cmp	r3, r2
 80032c0:	d3fb      	bcc.n	80032ba <main+0x3ea>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80032c2:	49c1      	ldr	r1, [pc, #772]	; (80035c8 <main+0x6f8>)
 80032c4:	4dc0      	ldr	r5, [pc, #768]	; (80035c8 <main+0x6f8>)
 80032c6:	6c0a      	ldr	r2, [r1, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80032c8:	48c0      	ldr	r0, [pc, #768]	; (80035cc <main+0x6fc>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80032ca:	4bc1      	ldr	r3, [pc, #772]	; (80035d0 <main+0x700>)
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80032cc:	49c1      	ldr	r1, [pc, #772]	; (80035d4 <main+0x704>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80032ce:	f8df c370 	ldr.w	ip, [pc, #880]	; 8003640 <main+0x770>
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
  reg_value  =  (reg_value                                 |
 80032d2:	f8df 9370 	ldr.w	r9, [pc, #880]	; 8003644 <main+0x774>

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80032d6:	f8df e370 	ldr.w	lr, [pc, #880]	; 8003648 <main+0x778>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80032da:	f042 0201 	orr.w	r2, r2, #1
 80032de:	642a      	str	r2, [r5, #64]	; 0x40

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80032e0:	6885      	ldr	r5, [r0, #8]
  tqp->p_prev = (thread_t *)tqp;
 80032e2:	605b      	str	r3, [r3, #4]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80032e4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80032e8:	f045 0801 	orr.w	r8, r5, #1
 80032ec:	f8c0 8008 	str.w	r8, [r0, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80032f0:	f242 00cf 	movw	r0, #8399	; 0x20cf
 80032f4:	6290      	str	r0, [r2, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80032f6:	f04f 30ff 	mov.w	r0, #4294967295
 80032fa:	62d0      	str	r0, [r2, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 80032fc:	2500      	movs	r5, #0
  STM32_ST_TIM->CCR[0] = 0;
  STM32_ST_TIM->DIER   = 0;
  STM32_ST_TIM->CR2    = 0;
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80032fe:	2001      	movs	r0, #1
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  STM32_ST_TIM->CCMR1  = 0;
 8003300:	6195      	str	r5, [r2, #24]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003302:	f04f 5880 	mov.w	r8, #268435456	; 0x10000000
  STM32_ST_TIM->CCR[0] = 0;
 8003306:	6355      	str	r5, [r2, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8003308:	60d5      	str	r5, [r2, #12]
  STM32_ST_TIM->CR2    = 0;
 800330a:	6055      	str	r5, [r2, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800330c:	6150      	str	r0, [r2, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 800330e:	6010      	str	r0, [r2, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8003310:	f06f 027f 	mvn.w	r2, #127	; 0x7f
 8003314:	f88c 231c 	strb.w	r2, [ip, #796]	; 0x31c
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8003318:	f8cc 8180 	str.w	r8, [ip, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800331c:	f8cc 8000 	str.w	r8, [ip]
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8003320:	608d      	str	r5, [r1, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003322:	68c8      	ldr	r0, [r1, #12]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8003324:	609d      	str	r5, [r3, #8]
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 8003326:	f64f 02ff 	movw	r2, #63743	; 0xf8ff
 800332a:	4002      	ands	r2, r0
  reg_value  =  (reg_value                                 |
 800332c:	ea42 0909 	orr.w	r9, r2, r9
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8003330:	f8c1 900c 	str.w	r9, [r1, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8003334:	f8de 200c 	ldr.w	r2, [lr, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8003338:	f8df 8310 	ldr.w	r8, [pc, #784]	; 800364c <main+0x77c>
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 800333c:	611b      	str	r3, [r3, #16]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800333e:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8003342:	f8ce 200c 	str.w	r2, [lr, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8003346:	f8d8 2000 	ldr.w	r2, [r8]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 800334a:	615b      	str	r3, [r3, #20]
 800334c:	f042 0201 	orr.w	r2, r2, #1
 8003350:	f8c8 2000 	str.w	r2, [r8]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 8003354:	f04f 0e10 	mov.w	lr, #16
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8003358:	f103 081c 	add.w	r8, r3, #28
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 800335c:	f04f 32ff 	mov.w	r2, #4294967295
 8003360:	f04f 0920 	mov.w	r9, #32
 8003364:	f881 e01f 	strb.w	lr, [r1, #31]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8003368:	eb0d 000e 	add.w	r0, sp, lr
 800336c:	625a      	str	r2, [r3, #36]	; 0x24
 800336e:	f881 9022 	strb.w	r9, [r1, #34]	; 0x22
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8003372:	f8c3 801c 	str.w	r8, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8003376:	f8c3 8020 	str.w	r8, [r3, #32]

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800337a:	f04f 0900 	mov.w	r9, #0
 800337e:	f04f 0800 	mov.w	r8, #0
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8003382:	629d      	str	r5, [r3, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003384:	601b      	str	r3, [r3, #0]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8003386:	675d      	str	r5, [r3, #116]	; 0x74
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8003388:	9204      	str	r2, [sp, #16]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800338a:	e9cd 8908 	strd	r8, r9, [sp, #32]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 800338e:	9302      	str	r3, [sp, #8]
 8003390:	f8cd c004 	str.w	ip, [sp, #4]
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8003394:	9505      	str	r5, [sp, #20]
  tmp->last       = (rtcnt_t)0;
 8003396:	9506      	str	r5, [sp, #24]
  tmp->n          = (ucnt_t)0;
 8003398:	9507      	str	r5, [sp, #28]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 800339a:	f002 f829 	bl	80053f0 <chTMStartMeasurementX.constprop.45>
  chTMStopMeasurementX(&tm);
 800339e:	a804      	add	r0, sp, #16
 80033a0:	f7fe f98e 	bl	80016c0 <chTMStopMeasurementX>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80033a4:	9b02      	ldr	r3, [sp, #8]
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 80033a6:	4a8c      	ldr	r2, [pc, #560]	; (80035d8 <main+0x708>)
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80033a8:	498c      	ldr	r1, [pc, #560]	; (80035dc <main+0x70c>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 80033aa:	f8df e2a4 	ldr.w	lr, [pc, #676]	; 8003650 <main+0x780>
 80033ae:	f8d3 8014 	ldr.w	r8, [r3, #20]
 80033b2:	f8df 92a0 	ldr.w	r9, [pc, #672]	; 8003654 <main+0x784>
 80033b6:	f8c3 8044 	str.w	r8, [r3, #68]	; 0x44
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80033ba:	f04f 0001 	mov.w	r0, #1
 80033be:	f883 004e 	strb.w	r0, [r3, #78]	; 0x4e
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80033c2:	f021 0107 	bic.w	r1, r1, #7
 80033c6:	f102 0010 	add.w	r0, r2, #16
 80033ca:	9103      	str	r1, [sp, #12]
 80033cc:	6110      	str	r0, [r2, #16]
  ch.tm.offset = tm.last;
 80033ce:	9906      	ldr	r1, [sp, #24]
  tqp->p_prev = (thread_t *)tqp;
 80033d0:	6150      	str	r0, [r2, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80033d2:	2040      	movs	r0, #64	; 0x40
 80033d4:	6759      	str	r1, [r3, #116]	; 0x74
 80033d6:	6398      	str	r0, [r3, #56]	; 0x38
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80033d8:	f103 0130 	add.w	r1, r3, #48	; 0x30
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80033dc:	66d8      	str	r0, [r3, #108]	; 0x6c
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 80033de:	f02e 0e07 	bic.w	lr, lr, #7
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80033e2:	f103 0054 	add.w	r0, r3, #84	; 0x54
 80033e6:	f8c9 e000 	str.w	lr, [r9]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80033ea:	f883 504d 	strb.w	r5, [r3, #77]	; 0x4d
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80033ee:	669d      	str	r5, [r3, #104]	; 0x68
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 80033f0:	665d      	str	r5, [r3, #100]	; 0x64
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80033f2:	649d      	str	r5, [r3, #72]	; 0x48
  REG_INSERT(tp);
 80033f4:	641b      	str	r3, [r3, #64]	; 0x40
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 80033f6:	6195      	str	r5, [r2, #24]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80033f8:	f8df e25c 	ldr.w	lr, [pc, #604]	; 8003658 <main+0x788>
 80033fc:	f8c8 1010 	str.w	r1, [r8, #16]
 8003400:	6558      	str	r0, [r3, #84]	; 0x54
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003402:	f103 0058 	add.w	r0, r3, #88	; 0x58
 8003406:	6159      	str	r1, [r3, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8003408:	6199      	str	r1, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 800340a:	f04f 0801 	mov.w	r8, #1
 800340e:	4974      	ldr	r1, [pc, #464]	; (80035e0 <main+0x710>)
 8003410:	6598      	str	r0, [r3, #88]	; 0x58
  tqp->p_prev = (thread_t *)tqp;
 8003412:	65d8      	str	r0, [r3, #92]	; 0x5c
 8003414:	9803      	ldr	r0, [sp, #12]
  default_heap.h_free.h.u.next = NULL;
 8003416:	6095      	str	r5, [r2, #8]
  default_heap.h_free.h.size = 0;
 8003418:	60d5      	str	r5, [r2, #12]
 800341a:	f883 804c 	strb.w	r8, [r3, #76]	; 0x4c
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 800341e:	6011      	str	r1, [r2, #0]
 8003420:	f8ce 0000 	str.w	r0, [lr]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8003424:	f04f 0902 	mov.w	r9, #2
 8003428:	f385 8811 	msr	BASEPRI, r5
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800342c:	b662      	cpsie	i
 800342e:	699a      	ldr	r2, [r3, #24]
 8003430:	496c      	ldr	r1, [pc, #432]	; (80035e4 <main+0x714>)
 8003432:	6191      	str	r1, [r2, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8003434:	f103 0078 	add.w	r0, r3, #120	; 0x78
 8003438:	2201      	movs	r2, #1
 800343a:	21d8      	movs	r1, #216	; 0xd8
 800343c:	4b6a      	ldr	r3, [pc, #424]	; (80035e8 <main+0x718>)
 800343e:	f000 ff87 	bl	8004350 <chThdCreateStatic.constprop.48>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8003442:	4b6a      	ldr	r3, [pc, #424]	; (80035ec <main+0x71c>)
 8003444:	6183      	str	r3, [r0, #24]
   * PA2(TX) and PA3(RX) are routed to USART2.
   */
  //sdStart(&SD2, NULL);
  //palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(7));
  //palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(7));
    palSetPadMode(GPIOC, 0, PAL_MODE_INPUT);
 8003446:	462a      	mov	r2, r5
 8003448:	2101      	movs	r1, #1
 800344a:	4869      	ldr	r0, [pc, #420]	; (80035f0 <main+0x720>)
 800344c:	f7fd ff08 	bl	8001260 <_pal_lld_setgroupmode>
    palSetPadMode(GPIOC, 1, PAL_MODE_INPUT);
 8003450:	4649      	mov	r1, r9
 8003452:	462a      	mov	r2, r5
 8003454:	4866      	ldr	r0, [pc, #408]	; (80035f0 <main+0x720>)
 8003456:	f7fd ff03 	bl	8001260 <_pal_lld_setgroupmode>
    palSetPadMode(GPIOC, 2, PAL_MODE_INPUT);
 800345a:	462a      	mov	r2, r5
 800345c:	4864      	ldr	r0, [pc, #400]	; (80035f0 <main+0x720>)
 800345e:	2104      	movs	r1, #4
 8003460:	f7fd fefe 	bl	8001260 <_pal_lld_setgroupmode>
    palSetPadMode(GPIOC, 3, PAL_MODE_INPUT);
 8003464:	462a      	mov	r2, r5
 8003466:	4862      	ldr	r0, [pc, #392]	; (80035f0 <main+0x720>)
 8003468:	2108      	movs	r1, #8
 800346a:	f7fd fef9 	bl	8001260 <_pal_lld_setgroupmode>
    palSetPadMode(GPIOE, 7, PAL_MODE_OUTPUT_PUSHPULL);
 800346e:	2180      	movs	r1, #128	; 0x80
 8003470:	2201      	movs	r2, #1
 8003472:	4860      	ldr	r0, [pc, #384]	; (80035f4 <main+0x724>)
 8003474:	f7fd fef4 	bl	8001260 <_pal_lld_setgroupmode>

  /*
   * Initializes the PWM driver 4, routes the TIM4 outputs to the board LEDs.
   */

    palSetPadMode(GPIOD, GPIOD_LED4, PAL_MODE_ALTERNATE(2));      /* Green.   */ //0
 8003478:	485f      	ldr	r0, [pc, #380]	; (80035f8 <main+0x728>)
 800347a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800347e:	f44f 7281 	mov.w	r2, #258	; 0x102
 8003482:	f7fd feed 	bl	8001260 <_pal_lld_setgroupmode>
    palSetPadMode(GPIOD, GPIOD_LED3, PAL_MODE_ALTERNATE(2));      /* Orange.  *///1/
 8003486:	485c      	ldr	r0, [pc, #368]	; (80035f8 <main+0x728>)
 8003488:	f44f 5100 	mov.w	r1, #8192	; 0x2000
 800348c:	f44f 7281 	mov.w	r2, #258	; 0x102
 8003490:	f7fd fee6 	bl	8001260 <_pal_lld_setgroupmode>
    palSetPadMode(GPIOD, GPIOD_LED5, PAL_MODE_ALTERNATE(2));      /* Red.     *///2
 8003494:	4858      	ldr	r0, [pc, #352]	; (80035f8 <main+0x728>)
 8003496:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 800349a:	f44f 7281 	mov.w	r2, #258	; 0x102
 800349e:	f7fd fedf 	bl	8001260 <_pal_lld_setgroupmode>
  //palSetPadMode(GPIOE, 1, PAL_MODE_ALTERNATE(2));      /* Red.     */
 // palSetPadMode(GPIOE, GPIOD_LED6, PAL_MODE_ALTERNATE(2));      /* Blue.    */
  //palSetPadMode(GPIOE,11, PAL_MODE_ALTERNATE(1));      /* Blue.    */
   palSetPadMode(GPIOE, GPIOE_PIN9, PAL_MODE_ALTERNATE(1));
 80034a2:	4854      	ldr	r0, [pc, #336]	; (80035f4 <main+0x724>)
 80034a4:	f44f 7100 	mov.w	r1, #512	; 0x200
 80034a8:	2282      	movs	r2, #130	; 0x82
 80034aa:	f7fd fed9 	bl	8001260 <_pal_lld_setgroupmode>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80034ae:	2120      	movs	r1, #32
 80034b0:	f381 8811 	msr	BASEPRI, r1
  osalDbgCheck((pwmp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
 80034b4:	4b51      	ldr	r3, [pc, #324]	; (80035fc <main+0x72c>)
 80034b6:	607b      	str	r3, [r7, #4]
  pwmp->period = config->period;
  pwm_lld_start(pwmp);
 80034b8:	4851      	ldr	r0, [pc, #324]	; (8003600 <main+0x730>)

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
  pwmp->period = config->period;
 80034ba:	f44f 7380 	mov.w	r3, #256	; 0x100
 80034be:	60bb      	str	r3, [r7, #8]
  pwm_lld_start(pwmp);
 80034c0:	9302      	str	r3, [sp, #8]
 80034c2:	f002 fe15 	bl	80060f0 <pwm_lld_start>
  pwmp->enabled = 0;
 80034c6:	60fd      	str	r5, [r7, #12]
  pwmp->state = PWM_READY;
 80034c8:	f887 9000 	strb.w	r9, [r7]
 80034cc:	f385 8811 	msr	BASEPRI, r5
 80034d0:	2220      	movs	r2, #32
 80034d2:	f382 8811 	msr	BASEPRI, r2
  osalDbgCheck((pwmp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
 80034d6:	4a4b      	ldr	r2, [pc, #300]	; (8003604 <main+0x734>)
  pwmp->period = config->period;
 80034d8:	9b02      	ldr	r3, [sp, #8]
  pwm_lld_start(pwmp);
 80034da:	484b      	ldr	r0, [pc, #300]	; (8003608 <main+0x738>)

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
  pwmp->period = config->period;
 80034dc:	60b3      	str	r3, [r6, #8]
  osalDbgCheck((pwmp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
                "invalid state");
  pwmp->config = config;
 80034de:	6072      	str	r2, [r6, #4]
  pwmp->period = config->period;
  pwm_lld_start(pwmp);
 80034e0:	f002 fe06 	bl	80060f0 <pwm_lld_start>
  pwmp->enabled = 0;
 80034e4:	60f5      	str	r5, [r6, #12]
  pwmp->state = PWM_READY;
 80034e6:	f886 9000 	strb.w	r9, [r6]
 80034ea:	f385 8811 	msr	BASEPRI, r5

  /** base port function init**/
    baseInit();

  /** Shell manager initialization. (USB terminal)*/
    shellInit();
 80034ee:	f002 f9af 	bl	8005850 <shellInit>

  /** USB terminal Shell function  init**/
    usbTermInit();
 80034f2:	f000 ff7d 	bl	80043f0 <usbTermInit>

  /** temperature sensor init */
    DS18B20_Init();
 80034f6:	f000 fc13 	bl	8003d20 <DS18B20_Init>
 80034fa:	2320      	movs	r3, #32
 80034fc:	f383 8811 	msr	BASEPRI, r3
  osalSysLock();
  osalDbgAssert(canp->state == CAN_STOP, "invalid state");

  /* Entering initialization mode. */
  canp->state = CAN_STARTING;
  canp->config = config;
 8003500:	4b42      	ldr	r3, [pc, #264]	; (800360c <main+0x73c>)

  /* Low level initialization, could be a slow process and sleeps could
     be performed inside.*/
  can_lld_start(canp);
 8003502:	4843      	ldr	r0, [pc, #268]	; (8003610 <main+0x740>)

  osalSysLock();
  osalDbgAssert(canp->state == CAN_STOP, "invalid state");

  /* Entering initialization mode. */
  canp->state = CAN_STARTING;
 8003504:	f88b 9000 	strb.w	r9, [fp]
  /* Low level initialization, could be a slow process and sleeps could
     be performed inside.*/
  can_lld_start(canp);

  /* The driver finally goes into the ready state.*/
  canp->state = CAN_READY;
 8003508:	2603      	movs	r6, #3
  osalSysLock();
  osalDbgAssert(canp->state == CAN_STOP, "invalid state");

  /* Entering initialization mode. */
  canp->state = CAN_STARTING;
  canp->config = config;
 800350a:	f8cb 3004 	str.w	r3, [fp, #4]

  /* Low level initialization, could be a slow process and sleeps could
     be performed inside.*/
  can_lld_start(canp);
 800350e:	f002 fd7f 	bl	8006010 <can_lld_start.constprop.24>

  /* The driver finally goes into the ready state.*/
  canp->state = CAN_READY;
 8003512:	f88b 6000 	strb.w	r6, [fp]
 8003516:	f385 8811 	msr	BASEPRI, r5
 800351a:	f04f 0820 	mov.w	r8, #32
 800351e:	f388 8811 	msr	BASEPRI, r8
  osalSysLock();
  osalDbgAssert(canp->state == CAN_STOP, "invalid state");

  /* Entering initialization mode. */
  canp->state = CAN_STARTING;
  canp->config = config;
 8003522:	4b3c      	ldr	r3, [pc, #240]	; (8003614 <main+0x744>)

  /* Low level initialization, could be a slow process and sleeps could
     be performed inside.*/
  can_lld_start(canp);
 8003524:	483c      	ldr	r0, [pc, #240]	; (8003618 <main+0x748>)

  osalSysLock();
  osalDbgAssert(canp->state == CAN_STOP, "invalid state");

  /* Entering initialization mode. */
  canp->state = CAN_STARTING;
 8003526:	f88a 9000 	strb.w	r9, [sl]
  canp->config = config;
 800352a:	f8ca 3004 	str.w	r3, [sl, #4]

  /* Low level initialization, could be a slow process and sleeps could
     be performed inside.*/
  can_lld_start(canp);
 800352e:	f002 fd6f 	bl	8006010 <can_lld_start.constprop.24>

  /* The driver finally goes into the ready state.*/
  canp->state = CAN_READY;
 8003532:	f88a 6000 	strb.w	r6, [sl]
 8003536:	f385 8811 	msr	BASEPRI, r5
  // Activates CAN driver.
  canStart(&CAND1, &cancfg);
  canStart(&CAND2, &cancfg2);


   palSetPadMode(GPIOD, 0, PAL_MODE_ALTERNATE(9) | PAL_STM32_OSPEED_HIGHEST /*|PAL_STM32_OTYPE_OPENDRAIN*/);
 800353a:	482f      	ldr	r0, [pc, #188]	; (80035f8 <main+0x728>)

        TEMP[0] = TEMP_LIMIT_1;
        TEMP[1] = TEMP_LIMIT_2;
        TEMP[2] = TEMP_LIMIT_3;

        DELTA[0] = DELTA_1;
 800353c:	4e37      	ldr	r6, [pc, #220]	; (800361c <main+0x74c>)
        chThdSleep(500);
}

void fuzzy_variables_inint(void){

        TEMP[0] = TEMP_LIMIT_1;
 800353e:	f8df a11c 	ldr.w	sl, [pc, #284]	; 800365c <main+0x78c>
 8003542:	2101      	movs	r1, #1
 8003544:	f240 429a 	movw	r2, #1178	; 0x49a
 8003548:	f7fd fe8a 	bl	8001260 <_pal_lld_setgroupmode>
   palSetPadMode(GPIOD, 1, PAL_MODE_ALTERNATE(9) | PAL_STM32_OSPEED_HIGHEST /*|PAL_STM32_OTYPE_OPENDRAIN*/);
 800354c:	4649      	mov	r1, r9
 800354e:	482a      	ldr	r0, [pc, #168]	; (80035f8 <main+0x728>)
 8003550:	f240 429a 	movw	r2, #1178	; 0x49a
 8003554:	f7fd fe84 	bl	8001260 <_pal_lld_setgroupmode>

   //palSetPadMode(GPIOB, 13, PAL_MODE_ALTERNATE(9) | PAL_STM32_OSPEED_HIGHEST /*|PAL_STM32_OTYPE_OPENDRAIN*/);
   //palSetPadMode(GPIOB, 12, PAL_MODE_ALTERNATE(9) | PAL_STM32_OSPEED_HIGHEST /*|PAL_STM32_OTYPE_OPENDRAIN*/);
   palSetPadMode(GPIOB, 6, PAL_MODE_ALTERNATE(9) | PAL_STM32_OSPEED_HIGHEST /*|PAL_STM32_OTYPE_OPENDRAIN*/);
 8003558:	2140      	movs	r1, #64	; 0x40
 800355a:	4831      	ldr	r0, [pc, #196]	; (8003620 <main+0x750>)
 800355c:	f240 429a 	movw	r2, #1178	; 0x49a
 8003560:	f7fd fe7e 	bl	8001260 <_pal_lld_setgroupmode>
   palSetPadMode(GPIOB, 5, PAL_MODE_ALTERNATE(9) | PAL_STM32_OSPEED_HIGHEST /*|PAL_STM32_OTYPE_OPENDRAIN*/);
 8003564:	4641      	mov	r1, r8
 8003566:	482e      	ldr	r0, [pc, #184]	; (8003620 <main+0x750>)
 8003568:	f240 429a 	movw	r2, #1178	; 0x49a
 800356c:	f7fd fe78 	bl	8001260 <_pal_lld_setgroupmode>
  //GPIOB->AFRL = (GPIOB->AFRL & ~(0xFF << 4*5)) | (0x99 << 4*5);
  // set PB5 and PB6 to alternate function mode
  //GPIOB->MODER = (GPIOB->MODER & ~(0b1111 << 2*5)) | (0b1010 << 2*5);

  /**Can send task start **/
   chThdCreateStatic(waThCanSend, sizeof(waThCanSend), NORMALPRIO + 3,
 8003570:	4b2c      	ldr	r3, [pc, #176]	; (8003624 <main+0x754>)
 8003572:	482d      	ldr	r0, [pc, #180]	; (8003628 <main+0x758>)
 8003574:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 8003578:	2243      	movs	r2, #67	; 0x43
 800357a:	f000 fee9 	bl	8004350 <chThdCreateStatic.constprop.48>
                    ThCanSend, NULL);
  /**Can receve task start **/
   chThdCreateStatic(can_rx1_wa, sizeof(can_rx1_wa), NORMALPRIO + 7,
 800357e:	4b2b      	ldr	r3, [pc, #172]	; (800362c <main+0x75c>)
 8003580:	482b      	ldr	r0, [pc, #172]	; (8003630 <main+0x760>)
 8003582:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 8003586:	2247      	movs	r2, #71	; 0x47
 8003588:	f000 fee2 	bl	8004350 <chThdCreateStatic.constprop.48>
 800358c:	f8df e0d0 	ldr.w	lr, [pc, #208]	; 8003660 <main+0x790>

// start fuzzy regulation task
void fuzzyInit(void){
fuzzy_variables_inint();

chThdCreateStatic(waThfuzzy, sizeof(waThfuzzy),
 8003590:	4b28      	ldr	r3, [pc, #160]	; (8003634 <main+0x764>)
 8003592:	4829      	ldr	r0, [pc, #164]	; (8003638 <main+0x768>)
        chThdSleep(500);
}

void fuzzy_variables_inint(void){

        TEMP[0] = TEMP_LIMIT_1;
 8003594:	f8ce a000 	str.w	sl, [lr]
        TEMP[1] = TEMP_LIMIT_2;
        TEMP[2] = TEMP_LIMIT_3;

        DELTA[0] = DELTA_1;
 8003598:	270a      	movs	r7, #10

// start fuzzy regulation task
void fuzzyInit(void){
fuzzy_variables_inint();

chThdCreateStatic(waThfuzzy, sizeof(waThfuzzy),
 800359a:	224a      	movs	r2, #74	; 0x4a
 800359c:	f44f 71a4 	mov.w	r1, #328	; 0x148
}

void fuzzy_variables_inint(void){

        TEMP[0] = TEMP_LIMIT_1;
        TEMP[1] = TEMP_LIMIT_2;
 80035a0:	f8ce a004 	str.w	sl, [lr, #4]
        TEMP[2] = TEMP_LIMIT_3;
 80035a4:	f8ce a008 	str.w	sl, [lr, #8]

        DELTA[0] = DELTA_1;
 80035a8:	6037      	str	r7, [r6, #0]
        DELTA[1] = DELTA_2;
 80035aa:	6077      	str	r7, [r6, #4]
        DELTA[2] = DELAT_3;
 80035ac:	60b7      	str	r7, [r6, #8]

// start fuzzy regulation task
void fuzzyInit(void){
fuzzy_variables_inint();

chThdCreateStatic(waThfuzzy, sizeof(waThfuzzy),
 80035ae:	f000 fecf 	bl	8004350 <chThdCreateStatic.constprop.48>
                    NORMALPRIO + 10, Thfuzzy, NULL);

                    originCurrent = CanReadInt(currentLimitDeviceID, currentLimitUserRef);
 80035b2:	f240 4153 	movw	r1, #1107	; 0x453
 80035b6:	2065      	movs	r0, #101	; 0x65
 80035b8:	f7ff fada 	bl	8002b70 <CanReadInt>
 80035bc:	4b1f      	ldr	r3, [pc, #124]	; (800363c <main+0x76c>)
 80035be:	6018      	str	r0, [r3, #0]
 80035c0:	e050      	b.n	8003664 <main+0x794>
 80035c2:	bf00      	nop
 80035c4:	20001264 	.word	0x20001264
 80035c8:	40023800 	.word	0x40023800
 80035cc:	e0042000 	.word	0xe0042000
 80035d0:	200016a8 	.word	0x200016a8
 80035d4:	e000ed00 	.word	0xe000ed00
 80035d8:	20001d80 	.word	0x20001d80
 80035dc:	20020000 	.word	0x20020000
 80035e0:	080011a1 	.word	0x080011a1
 80035e4:	08006de0 	.word	0x08006de0
 80035e8:	08001251 	.word	0x08001251
 80035ec:	08006e94 	.word	0x08006e94
 80035f0:	40020800 	.word	0x40020800
 80035f4:	40021000 	.word	0x40021000
 80035f8:	40020c00 	.word	0x40020c00
 80035fc:	08006d80 	.word	0x08006d80
 8003600:	20001bec 	.word	0x20001bec
 8003604:	08006ef0 	.word	0x08006ef0
 8003608:	20001bd0 	.word	0x20001bd0
 800360c:	08006ee0 	.word	0x08006ee0
 8003610:	20000d58 	.word	0x20000d58
 8003614:	08006eb0 	.word	0x08006eb0
 8003618:	20000d80 	.word	0x20000d80
 800361c:	200011a8 	.word	0x200011a8
 8003620:	40020400 	.word	0x40020400
 8003624:	08002531 	.word	0x08002531
 8003628:	200020b8 	.word	0x200020b8
 800362c:	080021a1 	.word	0x080021a1
 8003630:	20001da0 	.word	0x20001da0
 8003634:	08002761 	.word	0x08002761
 8003638:	20001f70 	.word	0x20001f70
 800363c:	2000084c 	.word	0x2000084c
 8003640:	e000e100 	.word	0xe000e100
 8003644:	05fa0300 	.word	0x05fa0300
 8003648:	e000edf0 	.word	0xe000edf0
 800364c:	e0001000 	.word	0xe0001000
 8003650:	200026b3 	.word	0x200026b3
 8003654:	20001d78 	.word	0x20001d78
 8003658:	20001f68 	.word	0x20001f68
 800365c:	42100000 	.word	0x42100000
 8003660:	20001690 	.word	0x20001690

  chThdSleep(10000);
 8003664:	f242 7010 	movw	r0, #10000	; 0x2710
 8003668:	f000 fbe2 	bl	8003e30 <chThdSleep>


chThdCreateStatic(waThCurrentLimiter, sizeof(waThCurrentLimiter),
 800366c:	4b50      	ldr	r3, [pc, #320]	; (80037b0 <main+0x8e0>)
 800366e:	4851      	ldr	r0, [pc, #324]	; (80037b4 <main+0x8e4>)
 8003670:	f44f 7124 	mov.w	r1, #656	; 0x290
 8003674:	224a      	movs	r2, #74	; 0x4a
 8003676:	f000 fe6b 	bl	8004350 <chThdCreateStatic.constprop.48>
 800367a:	f388 8811 	msr	BASEPRI, r8

  osalSysLock();
  osalDbgAssert((extp->state == EXT_STOP) || (extp->state == EXT_ACTIVE),
                "invalid state");
  extp->config = config;
  ext_lld_start(extp);
 800367e:	484e      	ldr	r0, [pc, #312]	; (80037b8 <main+0x8e8>)
  osalDbgCheck((extp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((extp->state == EXT_STOP) || (extp->state == EXT_ACTIVE),
                "invalid state");
  extp->config = config;
 8003680:	4b4e      	ldr	r3, [pc, #312]	; (80037bc <main+0x8ec>)
 8003682:	6043      	str	r3, [r0, #4]
  ext_lld_start(extp);
 8003684:	f7ff f99c 	bl	80029c0 <ext_lld_start>
  extp->state = EXT_ACTIVE;
 8003688:	484b      	ldr	r0, [pc, #300]	; (80037b8 <main+0x8e8>)
 800368a:	f880 9000 	strb.w	r9, [r0]
 800368e:	f385 8811 	msr	BASEPRI, r5
};

void buttonInit(){

    extStart(&EXTD1, &extcfg);
    chThdCreateStatic(waThreadButton, sizeof(waThreadButton),
 8003692:	4b4b      	ldr	r3, [pc, #300]	; (80037c0 <main+0x8f0>)
 8003694:	484b      	ldr	r0, [pc, #300]	; (80037c4 <main+0x8f4>)
 8003696:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800369a:	224a      	movs	r2, #74	; 0x4a
 800369c:	f000 fe58 	bl	8004350 <chThdCreateStatic.constprop.48>

int wconfInit(void)
{
	thread_t *listener;

	palSetPadMode(GPIOB, 10, PAL_MODE_ALTERNATE(7)); // used function : USART3_TX
 80036a0:	4849      	ldr	r0, [pc, #292]	; (80037c8 <main+0x8f8>)
 80036a2:	f44f 6180 	mov.w	r1, #1024	; 0x400
 80036a6:	f240 3282 	movw	r2, #898	; 0x382
 80036aa:	f7fd fdd9 	bl	8001260 <_pal_lld_setgroupmode>
	palSetPadMode(GPIOB, 11, PAL_MODE_ALTERNATE(7)); // used function : USART3_RX
 80036ae:	4846      	ldr	r0, [pc, #280]	; (80037c8 <main+0x8f8>)
 80036b0:	f44f 6100 	mov.w	r1, #2048	; 0x800
 80036b4:	f240 3282 	movw	r2, #898	; 0x382
 80036b8:	f7fd fdd2 	bl	8001260 <_pal_lld_setgroupmode>
 80036bc:	f388 8811 	msr	BASEPRI, r8
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 80036c0:	7a23      	ldrb	r3, [r4, #8]
 80036c2:	f8dd c004 	ldr.w	ip, [sp, #4]
 80036c6:	2b01      	cmp	r3, #1
 80036c8:	d059      	beq.n	800377e <main+0x8ae>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 80036ca:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 80036ce:	4a3f      	ldr	r2, [pc, #252]	; (80037cc <main+0x8fc>)
 80036d0:	4293      	cmp	r3, r2
 80036d2:	d066      	beq.n	80037a2 <main+0x8d2>
 80036d4:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 80036d8:	4293      	cmp	r3, r2
 80036da:	d062      	beq.n	80037a2 <main+0x8d2>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;
 80036dc:	4a3c      	ldr	r2, [pc, #240]	; (80037d0 <main+0x900>)
 80036de:	483d      	ldr	r0, [pc, #244]	; (80037d4 <main+0x904>)
 80036e0:	6811      	ldr	r1, [r2, #0]
 80036e2:	fbb0 f1f1 	udiv	r1, r0, r1
 80036e6:	6099      	str	r1, [r3, #8]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 80036e8:	8891      	ldrh	r1, [r2, #4]
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80036ea:	88d5      	ldrh	r5, [r2, #6]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80036ec:	8910      	ldrh	r0, [r2, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 80036ee:	f441 5204 	orr.w	r2, r1, #8448	; 0x2100
 80036f2:	f042 022c 	orr.w	r2, r2, #44	; 0x2c
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 80036f6:	f045 0540 	orr.w	r5, r5, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 80036fa:	f040 0001 	orr.w	r0, r0, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 80036fe:	b291      	uxth	r1, r2
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8003700:	b2ad      	uxth	r5, r5
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8003702:	b280      	uxth	r0, r0
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8003704:	2200      	movs	r2, #0
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8003706:	611d      	str	r5, [r3, #16]

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8003708:	2602      	movs	r6, #2
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800370a:	6158      	str	r0, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800370c:	60d9      	str	r1, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 800370e:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8003710:	6819      	ldr	r1, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8003712:	685b      	ldr	r3, [r3, #4]
 8003714:	7226      	strb	r6, [r4, #8]
 8003716:	f382 8811 	msr	BASEPRI, r2
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
 800371a:	4c2f      	ldr	r4, [pc, #188]	; (80037d8 <main+0x908>)
 800371c:	4d2f      	ldr	r5, [pc, #188]	; (80037dc <main+0x90c>)

	/* Create a thread uses arg2 of area arg1 with priority of
	 * arg3(LOWPRIO,NORMALPRIO,HIGHPRIO or any value between 0-255), thread function is arg4
	 *
	 * Returns pointer to thread object*/
    listener = chThdCreateStatic(serialListen, sizeof(serialListen), LOWPRIO, rxListen, NULL);
 800371e:	4b30      	ldr	r3, [pc, #192]	; (80037e0 <main+0x910>)
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
  sp->s_cnt = n;
 8003720:	61a2      	str	r2, [r4, #24]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003722:	f104 0e1c 	add.w	lr, r4, #28
 8003726:	f44f 7c80 	mov.w	ip, #256	; 0x100
 800372a:	f104 0710 	add.w	r7, r4, #16
 800372e:	4632      	mov	r2, r6
 8003730:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003734:	f8c4 c024 	str.w	ip, [r4, #36]	; 0x24
 8003738:	f8c4 e01c 	str.w	lr, [r4, #28]
  tqp->p_prev = (thread_t *)tqp;
 800373c:	f8c4 e020 	str.w	lr, [r4, #32]
 8003740:	4828      	ldr	r0, [pc, #160]	; (80037e4 <main+0x914>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003742:	6127      	str	r7, [r4, #16]
  mbp->mb_rdptr = buf;
  mbp->mb_wrptr = buf;
  mbp->mb_top = &buf[n];
 8003744:	f505 6880 	add.w	r8, r5, #1024	; 0x400
  tqp->p_prev = (thread_t *)tqp;
 8003748:	6167      	str	r7, [r4, #20]
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
 800374a:	6025      	str	r5, [r4, #0]
  mbp->mb_rdptr = buf;
 800374c:	60e5      	str	r5, [r4, #12]
  mbp->mb_wrptr = buf;
 800374e:	60a5      	str	r5, [r4, #8]
  mbp->mb_top = &buf[n];
 8003750:	f8c4 8004 	str.w	r8, [r4, #4]
 8003754:	f000 fdfc 	bl	8004350 <chThdCreateStatic.constprop.48>

    chThdCreateStatic(serialTalk, sizeof(serialTalk), LOWPRIO, txWrite, NULL);
 8003758:	4632      	mov	r2, r6
 800375a:	4b23      	ldr	r3, [pc, #140]	; (80037e8 <main+0x918>)
 800375c:	4823      	ldr	r0, [pc, #140]	; (80037ec <main+0x91c>)
 800375e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8003762:	f000 fdf5 	bl	8004350 <chThdCreateStatic.constprop.48>

  /** Wifi 3G communication */
    wconfInit();

  /** Creates the hello word ledblinking thread.*/
    chThdCreateStatic(waThread1, sizeof(waThread1),
 8003766:	4822      	ldr	r0, [pc, #136]	; (80037f0 <main+0x920>)
 8003768:	4b22      	ldr	r3, [pc, #136]	; (80037f4 <main+0x924>)
 800376a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800376e:	224a      	movs	r2, #74	; 0x4a
 8003770:	f000 fdee 	bl	8004350 <chThdCreateStatic.constprop.48>
 /** task 2 **/
    /*chThdCreateStatic(waThread2, sizeof(waThread2),
                    NORMALPRIO + 10, Thread2, NULL); */

  while (true) {
     chThdSleepMilliseconds(1000);//500);
 8003774:	f242 7010 	movw	r0, #10000	; 0x2710
 8003778:	f000 fb5a 	bl	8003e30 <chThdSleep>
 800377c:	e7fa      	b.n	8003774 <main+0x8a4>
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART3
    if (&SD3 == sdp) {
      rccEnableUSART3(FALSE);
 800377e:	491e      	ldr	r1, [pc, #120]	; (80037f8 <main+0x928>)
 8003780:	6c0a      	ldr	r2, [r1, #64]	; 0x40

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8003782:	23c0      	movs	r3, #192	; 0xc0
 8003784:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8003788:	640a      	str	r2, [r1, #64]	; 0x40
 800378a:	f88c 3327 	strb.w	r3, [ip, #807]	; 0x327
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800378e:	2280      	movs	r2, #128	; 0x80
 8003790:	f8cc 2184 	str.w	r2, [ip, #388]	; 0x184
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8003794:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8003798:	f8cc 2004 	str.w	r2, [ip, #4]

  /* Baud rate setting.*/
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 800379c:	4a0b      	ldr	r2, [pc, #44]	; (80037cc <main+0x8fc>)
 800379e:	4293      	cmp	r3, r2
 80037a0:	d198      	bne.n	80036d4 <main+0x804>
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 80037a2:	4a0b      	ldr	r2, [pc, #44]	; (80037d0 <main+0x900>)
 80037a4:	4815      	ldr	r0, [pc, #84]	; (80037fc <main+0x92c>)
 80037a6:	6811      	ldr	r1, [r2, #0]
 80037a8:	fbb0 f1f1 	udiv	r1, r0, r1
 80037ac:	6099      	str	r1, [r3, #8]
 80037ae:	e79b      	b.n	80036e8 <main+0x818>
 80037b0:	08006241 	.word	0x08006241
 80037b4:	200017f8 	.word	0x200017f8
 80037b8:	2000169c 	.word	0x2000169c
 80037bc:	08006f30 	.word	0x08006f30
 80037c0:	08005d01 	.word	0x08005d01
 80037c4:	20001548 	.word	0x20001548
 80037c8:	40020400 	.word	0x40020400
 80037cc:	40011000 	.word	0x40011000
 80037d0:	20000828 	.word	0x20000828
 80037d4:	0280de80 	.word	0x0280de80
 80037d8:	20001c08 	.word	0x20001c08
 80037dc:	20000da8 	.word	0x20000da8
 80037e0:	08005c81 	.word	0x08005c81
 80037e4:	20001c30 	.word	0x20001c30
 80037e8:	08002911 	.word	0x08002911
 80037ec:	20001a88 	.word	0x20001a88
 80037f0:	20001400 	.word	0x20001400
 80037f4:	08002341 	.word	0x08002341
 80037f8:	40023800 	.word	0x40023800
 80037fc:	0501bd00 	.word	0x0501bd00

08003800 <__early_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8003800:	492c      	ldr	r1, [pc, #176]	; (80038b4 <__early_init+0xb4>)

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8003802:	4b2d      	ldr	r3, [pc, #180]	; (80038b8 <__early_init+0xb8>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8003804:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8003808:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 800380c:	6408      	str	r0, [r1, #64]	; 0x40

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 800380e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8003810:	680b      	ldr	r3, [r1, #0]
 8003812:	f043 0301 	orr.w	r3, r3, #1
 8003816:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8003818:	680b      	ldr	r3, [r1, #0]
 800381a:	4a26      	ldr	r2, [pc, #152]	; (80038b4 <__early_init+0xb4>)
 800381c:	0798      	lsls	r0, r3, #30
 800381e:	d5fb      	bpl.n	8003818 <__early_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8003820:	6893      	ldr	r3, [r2, #8]
 8003822:	f023 0303 	bic.w	r3, r3, #3
 8003826:	6093      	str	r3, [r2, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8003828:	6893      	ldr	r3, [r2, #8]
 800382a:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800382c:	4611      	mov	r1, r2
 800382e:	688b      	ldr	r3, [r1, #8]
 8003830:	4a20      	ldr	r2, [pc, #128]	; (80038b4 <__early_init+0xb4>)
 8003832:	f013 030c 	ands.w	r3, r3, #12
 8003836:	d1fa      	bne.n	800382e <__early_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8003838:	6811      	ldr	r1, [r2, #0]
 800383a:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 800383e:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8003840:	6093      	str	r3, [r2, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8003842:	6813      	ldr	r3, [r2, #0]
 8003844:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8003848:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800384a:	6813      	ldr	r3, [r2, #0]
 800384c:	4919      	ldr	r1, [pc, #100]	; (80038b4 <__early_init+0xb4>)
 800384e:	039b      	lsls	r3, r3, #14
 8003850:	d5fb      	bpl.n	800384a <__early_init+0x4a>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8003852:	6f4b      	ldr	r3, [r1, #116]	; 0x74
 8003854:	f043 0301 	orr.w	r3, r3, #1
 8003858:	674b      	str	r3, [r1, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800385a:	6f4b      	ldr	r3, [r1, #116]	; 0x74
 800385c:	4a15      	ldr	r2, [pc, #84]	; (80038b4 <__early_init+0xb4>)
 800385e:	0798      	lsls	r0, r3, #30
 8003860:	d5fb      	bpl.n	800385a <__early_init+0x5a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 8003862:	4b16      	ldr	r3, [pc, #88]	; (80038bc <__early_init+0xbc>)
 8003864:	6053      	str	r3, [r2, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8003866:	6813      	ldr	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8003868:	4913      	ldr	r1, [pc, #76]	; (80038b8 <__early_init+0xb8>)

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 800386a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800386e:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8003870:	684b      	ldr	r3, [r1, #4]
 8003872:	045a      	lsls	r2, r3, #17
 8003874:	d5fc      	bpl.n	8003870 <__early_init+0x70>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8003876:	490f      	ldr	r1, [pc, #60]	; (80038b4 <__early_init+0xb4>)
 8003878:	680b      	ldr	r3, [r1, #0]
 800387a:	4a0e      	ldr	r2, [pc, #56]	; (80038b4 <__early_init+0xb4>)
 800387c:	019b      	lsls	r3, r3, #6
 800387e:	d5fb      	bpl.n	8003878 <__early_init+0x78>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8003880:	4b0f      	ldr	r3, [pc, #60]	; (80038c0 <__early_init+0xc0>)
  while (!(RCC->CR & RCC_CR_PLLSAIRDY))
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 8003882:	4910      	ldr	r1, [pc, #64]	; (80038c4 <__early_init+0xc4>)
 8003884:	6091      	str	r1, [r2, #8]
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 8003886:	f240 7105 	movw	r1, #1797	; 0x705
 800388a:	6019      	str	r1, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 800388c:	6893      	ldr	r3, [r2, #8]
 800388e:	f043 0302 	orr.w	r3, r3, #2
 8003892:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8003894:	4611      	mov	r1, r2
 8003896:	688b      	ldr	r3, [r1, #8]
 8003898:	4a06      	ldr	r2, [pc, #24]	; (80038b4 <__early_init+0xb4>)
 800389a:	f003 030c 	and.w	r3, r3, #12
 800389e:	2b08      	cmp	r3, #8
 80038a0:	d1f9      	bne.n	8003896 <__early_init+0x96>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80038a2:	6c53      	ldr	r3, [r2, #68]	; 0x44
 80038a4:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80038a8:	6453      	str	r3, [r2, #68]	; 0x44
 80038aa:	6e53      	ldr	r3, [r2, #100]	; 0x64
 80038ac:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80038b0:	6653      	str	r3, [r2, #100]	; 0x64
 80038b2:	4770      	bx	lr
 80038b4:	40023800 	.word	0x40023800
 80038b8:	40007000 	.word	0x40007000
 80038bc:	07405408 	.word	0x07405408
 80038c0:	40023c00 	.word	0x40023c00
 80038c4:	38889400 	.word	0x38889400
	...

080038d0 <chThdExit>:
 80038d0:	2320      	movs	r3, #32
 80038d2:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 80038d6:	f7fe bb9b 	b.w	8002010 <chThdExitS>
 80038da:	bf00      	nop
 80038dc:	0000      	movs	r0, r0
	...

080038e0 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 80038e0:	f7fd bf16 	b.w	8001710 <chSchDoRescheduleAhead>
	...

080038f0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 80038f0:	e7fe      	b.n	80038f0 <__default_exit>
 80038f2:	bf00      	nop
	...

08003900 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8003900:	4770      	bx	lr
 8003902:	bf00      	nop
	...

08003910 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 8003910:	4770      	bx	lr
 8003912:	bf00      	nop
	...

08003920 <OneWire_ReadBit.4294>:
}
}


uint8_t OneWire_ReadBit(void)
{
 8003920:	b510      	push	{r4, lr}
	uint8_t bit = 0;

	OneWire_SetBusLine(0,SEN_ID);
 8003922:	4c16      	ldr	r4, [pc, #88]	; (800397c <OneWire_ReadBit.4294+0x5c>)
 8003924:	2000      	movs	r0, #0
 8003926:	7821      	ldrb	r1, [r4, #0]
 8003928:	f001 ff62 	bl	80057f0 <OneWire_SetBusLine>
 800392c:	2320      	movs	r3, #32
 800392e:	f383 8811 	msr	BASEPRI, r3
 8003932:	2354      	movs	r3, #84	; 0x54
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
    asm("nop");
 8003934:	bf00      	nop
{
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
 8003936:	3b01      	subs	r3, #1
 8003938:	d1fc      	bne.n	8003934 <OneWire_ReadBit.4294+0x14>
 800393a:	f383 8811 	msr	BASEPRI, r3
 800393e:	7820      	ldrb	r0, [r4, #0]
 8003940:	f001 ff2e 	bl	80057a0 <OneWire_SetBusLine.part.2.14391>
 8003944:	2320      	movs	r3, #32
 8003946:	f383 8811 	msr	BASEPRI, r3
 800394a:	f240 2376 	movw	r3, #630	; 0x276
    asm("nop");
 800394e:	bf00      	nop
{
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
 8003950:	3b01      	subs	r3, #1
 8003952:	d1fc      	bne.n	800394e <OneWire_ReadBit.4294+0x2e>
 8003954:	f383 8811 	msr	BASEPRI, r3

	OneWire_SetBusLine(0,SEN_ID);
	Delay_us(2);
	OneWire_SetBusLine(1,SEN_ID);
	Delay_us(15);
	if(OneWire_GetBusLine(SEN_ID))
 8003958:	7820      	ldrb	r0, [r4, #0]
 800395a:	f001 fef1 	bl	8005740 <OneWire_GetBusLine>
}


uint8_t OneWire_ReadBit(void)
{
	uint8_t bit = 0;
 800395e:	3000      	adds	r0, #0
 8003960:	f04f 0320 	mov.w	r3, #32
 8003964:	bf18      	it	ne
 8003966:	2001      	movne	r0, #1
 8003968:	f383 8811 	msr	BASEPRI, r3
 800396c:	f240 633c 	movw	r3, #1596	; 0x63c
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
    asm("nop");
 8003970:	bf00      	nop
{
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
 8003972:	3b01      	subs	r3, #1
 8003974:	d1fc      	bne.n	8003970 <OneWire_ReadBit.4294+0x50>
 8003976:	f383 8811 	msr	BASEPRI, r3
	if(OneWire_GetBusLine(SEN_ID))
		bit = 1;
	Delay_us(38);

	return bit;
}
 800397a:	bd10      	pop	{r4, pc}
 800397c:	20000d3c 	.word	0x20000d3c

08003980 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8003980:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8003984:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8003988:	692b      	ldr	r3, [r5, #16]
 800398a:	079b      	lsls	r3, r3, #30
 800398c:	d403      	bmi.n	8003996 <VectorB0+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 800398e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8003992:	f7fd bccd 	b.w	8001330 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8003996:	2700      	movs	r7, #0
 8003998:	612f      	str	r7, [r5, #16]
 800399a:	2620      	movs	r6, #32
 800399c:	f386 8811 	msr	BASEPRI, r6
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 80039a0:	4c1d      	ldr	r4, [pc, #116]	; (8003a18 <VectorB0+0x98>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80039a2:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80039a4:	69e3      	ldr	r3, [r4, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80039a6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80039a8:	6899      	ldr	r1, [r3, #8]
 80039aa:	ebc0 0c02 	rsb	ip, r0, r2
 80039ae:	458c      	cmp	ip, r1
 80039b0:	bf38      	it	cc
 80039b2:	f104 071c 	addcc.w	r7, r4, #28
 80039b6:	d31d      	bcc.n	80039f4 <VectorB0+0x74>
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 80039b8:	46b8      	mov	r8, r7
 80039ba:	f104 071c 	add.w	r7, r4, #28
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80039be:	681a      	ldr	r2, [r3, #0]
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 80039c0:	f8d3 c00c 	ldr.w	ip, [r3, #12]
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 80039c4:	4401      	add	r1, r0
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80039c6:	42ba      	cmp	r2, r7
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 80039c8:	62a1      	str	r1, [r4, #40]	; 0x28

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80039ca:	6057      	str	r7, [r2, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 80039cc:	61e2      	str	r2, [r4, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 80039ce:	f8c3 800c 	str.w	r8, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80039d2:	bf08      	it	eq
 80039d4:	f8c5 800c 	streq.w	r8, [r5, #12]
 80039d8:	f388 8811 	msr	BASEPRI, r8
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 80039dc:	6918      	ldr	r0, [r3, #16]
 80039de:	47e0      	blx	ip
 80039e0:	f386 8811 	msr	BASEPRI, r6
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 80039e4:	69e3      	ldr	r3, [r4, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80039e6:	6a6a      	ldr	r2, [r5, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80039e8:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80039ea:	6899      	ldr	r1, [r3, #8]
 80039ec:	ebc0 0c02 	rsb	ip, r0, r2
 80039f0:	4561      	cmp	r1, ip
 80039f2:	d9e4      	bls.n	80039be <VectorB0+0x3e>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80039f4:	42bb      	cmp	r3, r7
 80039f6:	d008      	beq.n	8003a0a <VectorB0+0x8a>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 80039f8:	4401      	add	r1, r0
 80039fa:	1a89      	subs	r1, r1, r2
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80039fc:	2901      	cmp	r1, #1
 80039fe:	bf98      	it	ls
 8003a00:	2102      	movls	r1, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003a02:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  }
  port_timer_set_alarm(now + delta);
 8003a06:	440a      	add	r2, r1
 8003a08:	635a      	str	r2, [r3, #52]	; 0x34
 8003a0a:	2300      	movs	r3, #0
 8003a0c:	f383 8811 	msr	BASEPRI, r3
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8003a10:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8003a14:	f7fd bc8c 	b.w	8001330 <_port_irq_epilogue>
 8003a18:	200016a8 	.word	0x200016a8
 8003a1c:	00000000 	.word	0x00000000

08003a20 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8003a20:	4a1a      	ldr	r2, [pc, #104]	; (8003a8c <chVTDoResetI+0x6c>)
 8003a22:	69d3      	ldr	r3, [r2, #28]
 8003a24:	4283      	cmp	r3, r0
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8003a26:	b410      	push	{r4}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8003a28:	d010      	beq.n	8003a4c <chVTDoResetI+0x2c>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8003a2a:	6841      	ldr	r1, [r0, #4]
 8003a2c:	6803      	ldr	r3, [r0, #0]
 8003a2e:	600b      	str	r3, [r1, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8003a30:	6803      	ldr	r3, [r0, #0]
    vtp->vt_func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8003a32:	321c      	adds	r2, #28
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;
 8003a34:	2400      	movs	r4, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8003a36:	4293      	cmp	r3, r2
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8003a38:	6059      	str	r1, [r3, #4]
    vtp->vt_func = NULL;
 8003a3a:	60c4      	str	r4, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8003a3c:	d003      	beq.n	8003a46 <chVTDoResetI+0x26>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 8003a3e:	6881      	ldr	r1, [r0, #8]
 8003a40:	689a      	ldr	r2, [r3, #8]
 8003a42:	440a      	add	r2, r1
 8003a44:	609a      	str	r2, [r3, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003a46:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003a4a:	4770      	bx	lr

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 8003a4c:	4610      	mov	r0, r2
 8003a4e:	6819      	ldr	r1, [r3, #0]
 8003a50:	f840 1f1c 	str.w	r1, [r0, #28]!
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
  vtp->vt_func = NULL;
 8003a54:	2400      	movs	r4, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8003a56:	4281      	cmp	r1, r0
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8003a58:	6048      	str	r0, [r1, #4]
  vtp->vt_func = NULL;
 8003a5a:	60dc      	str	r4, [r3, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8003a5c:	d011      	beq.n	8003a82 <chVTDoResetI+0x62>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8003a5e:	688c      	ldr	r4, [r1, #8]
 8003a60:	689b      	ldr	r3, [r3, #8]
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8003a62:	6a90      	ldr	r0, [r2, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 8003a64:	4423      	add	r3, r4
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003a66:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8003a6a:	608b      	str	r3, [r1, #8]
 8003a6c:	6a51      	ldr	r1, [r2, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 8003a6e:	1a08      	subs	r0, r1, r0

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 8003a70:	4283      	cmp	r3, r0
 8003a72:	d9e8      	bls.n	8003a46 <chVTDoResetI+0x26>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 8003a74:	1a1b      	subs	r3, r3, r0

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8003a76:	2b01      	cmp	r3, #1
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8003a78:	bf98      	it	ls
 8003a7a:	2302      	movls	r3, #2
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
 8003a7c:	440b      	add	r3, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003a7e:	6353      	str	r3, [r2, #52]	; 0x34
 8003a80:	e7e1      	b.n	8003a46 <chVTDoResetI+0x26>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8003a82:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003a86:	60dc      	str	r4, [r3, #12]
 8003a88:	e7dd      	b.n	8003a46 <chVTDoResetI+0x26>
 8003a8a:	bf00      	nop
 8003a8c:	200016a8 	.word	0x200016a8

08003a90 <OneWire_Reset>:

	return data;
}

uint8_t OneWire_Reset( int RID)
{
 8003a90:	b538      	push	{r3, r4, r5, lr}
	OneWire_SetBusLine(0,RID); // out
 8003a92:	b2c4      	uxtb	r4, r0

	return data;
}

uint8_t OneWire_Reset( int RID)
{
 8003a94:	4605      	mov	r5, r0
	OneWire_SetBusLine(0,RID); // out
 8003a96:	4621      	mov	r1, r4
 8003a98:	2000      	movs	r0, #0
 8003a9a:	f001 fea9 	bl	80057f0 <OneWire_SetBusLine>
 8003a9e:	2320      	movs	r3, #32
 8003aa0:	f383 8811 	msr	BASEPRI, r3
 8003aa4:	f644 63c0 	movw	r3, #20160	; 0x4ec0
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
    asm("nop");
 8003aa8:	bf00      	nop
{
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
 8003aaa:	3b01      	subs	r3, #1
 8003aac:	d1fc      	bne.n	8003aa8 <OneWire_Reset+0x18>
 8003aae:	f383 8811 	msr	BASEPRI, r3
 8003ab2:	4620      	mov	r0, r4
 8003ab4:	f001 fe74 	bl	80057a0 <OneWire_SetBusLine.part.2.14391>
 8003ab8:	2320      	movs	r3, #32
 8003aba:	f383 8811 	msr	BASEPRI, r3
 8003abe:	f640 14d8 	movw	r4, #2520	; 0x9d8
    asm("nop");
 8003ac2:	bf00      	nop
{
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
 8003ac4:	3c01      	subs	r4, #1
 8003ac6:	d1fc      	bne.n	8003ac2 <OneWire_Reset+0x32>
 8003ac8:	f384 8811 	msr	BASEPRI, r4
	Delay_us(480);

	OneWire_SetBusLine(1,RID); // read Presence

	Delay_us(60);
	if(!OneWire_GetBusLine(RID))
 8003acc:	4628      	mov	r0, r5
 8003ace:	f001 fe37 	bl	8005740 <OneWire_GetBusLine>
 8003ad2:	b958      	cbnz	r0, 8003aec <OneWire_Reset+0x5c>
 8003ad4:	2320      	movs	r3, #32
 8003ad6:	f383 8811 	msr	BASEPRI, r3
 8003ada:	f244 43e8 	movw	r3, #17640	; 0x44e8
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
    asm("nop");
 8003ade:	bf00      	nop
{
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
 8003ae0:	3b01      	subs	r3, #1
 8003ae2:	d1fc      	bne.n	8003ade <OneWire_Reset+0x4e>
 8003ae4:	f383 8811 	msr	BASEPRI, r3
 8003ae8:	2001      	movs	r0, #1
 8003aea:	bd38      	pop	{r3, r4, r5, pc}
	if(!OneWire_GetBusLine(RID))
	{
		Delay_us(420);
		return 1;
	}
    else return 0;
 8003aec:	4620      	mov	r0, r4
}
 8003aee:	bd38      	pop	{r3, r4, r5, pc}

08003af0 <OneWire_WriteBit>:

	return bit;
}

void OneWire_WriteBit(uint8_t bit)
{
 8003af0:	b538      	push	{r3, r4, r5, lr}
	OneWire_SetBusLine(0,SEN_ID);
 8003af2:	4c24      	ldr	r4, [pc, #144]	; (8003b84 <OneWire_WriteBit+0x94>)

	return bit;
}

void OneWire_WriteBit(uint8_t bit)
{
 8003af4:	4605      	mov	r5, r0
	OneWire_SetBusLine(0,SEN_ID);
 8003af6:	7821      	ldrb	r1, [r4, #0]
 8003af8:	2000      	movs	r0, #0
 8003afa:	f001 fe79 	bl	80057f0 <OneWire_SetBusLine>
 8003afe:	2320      	movs	r3, #32
 8003b00:	f383 8811 	msr	BASEPRI, r3
 8003b04:	237e      	movs	r3, #126	; 0x7e
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
    asm("nop");
 8003b06:	bf00      	nop
{
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
 8003b08:	3b01      	subs	r3, #1
 8003b0a:	d1fc      	bne.n	8003b06 <OneWire_WriteBit+0x16>
 8003b0c:	f383 8811 	msr	BASEPRI, r3

void OneWire_WriteBit(uint8_t bit)
{
	OneWire_SetBusLine(0,SEN_ID);
	Delay_us(3);
	if(bit)
 8003b10:	b1c5      	cbz	r5, 8003b44 <OneWire_WriteBit+0x54>
 8003b12:	7820      	ldrb	r0, [r4, #0]
 8003b14:	f001 fe44 	bl	80057a0 <OneWire_SetBusLine.part.2.14391>
 8003b18:	2320      	movs	r3, #32
 8003b1a:	f383 8811 	msr	BASEPRI, r3
 8003b1e:	f640 12d8 	movw	r2, #2520	; 0x9d8
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
    asm("nop");
 8003b22:	bf00      	nop
{
    chSysLock();
    int r = 0;
    int u = 42;
    uint32_t t = u * us;
    for (r ; r< t; r++){
 8003b24:	3a01      	subs	r2, #1
 8003b26:	d1fc      	bne.n	8003b22 <OneWire_WriteBit+0x32>
 8003b28:	f382 8811 	msr	BASEPRI, r2
	if(bit)
		OneWire_SetBusLine(1,SEN_ID);
	else
		OneWire_SetBusLine(0,SEN_ID);
	Delay_us(60);
	OneWire_DataPinInput(SEN_ID);
 8003b2c:	7820      	ldrb	r0, [r4, #0]
 8003b2e:	4c15      	ldr	r4, [pc, #84]	; (8003b84 <OneWire_WriteBit+0x94>)
uint8_t ROM_ADRESS_3[8]; // dinamic rom address  PIN 3
uint8_t SEN_ID;  // sensor cal back ID -1 in switch cases 1 is the first

void OneWire_DataPinInput(int c)
{
switch(c-1){
 8003b30:	1e43      	subs	r3, r0, #1
 8003b32:	2b01      	cmp	r3, #1
 8003b34:	d01d      	beq.n	8003b72 <OneWire_WriteBit+0x82>
 8003b36:	2b02      	cmp	r3, #2
 8003b38:	d012      	beq.n	8003b60 <OneWire_WriteBit+0x70>
 8003b3a:	b143      	cbz	r3, 8003b4e <OneWire_WriteBit+0x5e>
	else
		OneWire_SetBusLine(0,SEN_ID);
	Delay_us(60);
	OneWire_DataPinInput(SEN_ID);
	OneWire_SetBusLine(1,SEN_ID);
}
 8003b3c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8003b40:	f001 be2e 	b.w	80057a0 <OneWire_SetBusLine.part.2.14391>
	OneWire_SetBusLine(0,SEN_ID);
	Delay_us(3);
	if(bit)
		OneWire_SetBusLine(1,SEN_ID);
	else
		OneWire_SetBusLine(0,SEN_ID);
 8003b44:	4628      	mov	r0, r5
 8003b46:	7821      	ldrb	r1, [r4, #0]
 8003b48:	f001 fe52 	bl	80057f0 <OneWire_SetBusLine>
 8003b4c:	e7e4      	b.n	8003b18 <OneWire_WriteBit+0x28>

void OneWire_DataPinInput(int c)
{
switch(c-1){
    case 0 :
        palSetPadMode(DS18B20_1_GPIO, DS18B20_1_DATAPIN, PAL_MODE_INPUT);
 8003b4e:	480e      	ldr	r0, [pc, #56]	; (8003b88 <OneWire_WriteBit+0x98>)
 8003b50:	2104      	movs	r1, #4
 8003b52:	f7fd fb85 	bl	8001260 <_pal_lld_setgroupmode>
 8003b56:	7820      	ldrb	r0, [r4, #0]
	else
		OneWire_SetBusLine(0,SEN_ID);
	Delay_us(60);
	OneWire_DataPinInput(SEN_ID);
	OneWire_SetBusLine(1,SEN_ID);
}
 8003b58:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8003b5c:	f001 be20 	b.w	80057a0 <OneWire_SetBusLine.part.2.14391>
    case 1 :
        palSetPadMode(DS18B20_2_GPIO, DS18B20_2_DATAPIN, PAL_MODE_INPUT);
    break;

    case 2 :
        palSetPadMode(DS18B20_3_GPIO, DS18B20_3_DATAPIN, PAL_MODE_INPUT);
 8003b60:	4809      	ldr	r0, [pc, #36]	; (8003b88 <OneWire_WriteBit+0x98>)
 8003b62:	2110      	movs	r1, #16
 8003b64:	f7fd fb7c 	bl	8001260 <_pal_lld_setgroupmode>
 8003b68:	7820      	ldrb	r0, [r4, #0]
	else
		OneWire_SetBusLine(0,SEN_ID);
	Delay_us(60);
	OneWire_DataPinInput(SEN_ID);
	OneWire_SetBusLine(1,SEN_ID);
}
 8003b6a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8003b6e:	f001 be17 	b.w	80057a0 <OneWire_SetBusLine.part.2.14391>
    case 0 :
        palSetPadMode(DS18B20_1_GPIO, DS18B20_1_DATAPIN, PAL_MODE_INPUT);
    break;

    case 1 :
        palSetPadMode(DS18B20_2_GPIO, DS18B20_2_DATAPIN, PAL_MODE_INPUT);
 8003b72:	4805      	ldr	r0, [pc, #20]	; (8003b88 <OneWire_WriteBit+0x98>)
 8003b74:	2108      	movs	r1, #8
 8003b76:	f7fd fb73 	bl	8001260 <_pal_lld_setgroupmode>
 8003b7a:	7820      	ldrb	r0, [r4, #0]
	else
		OneWire_SetBusLine(0,SEN_ID);
	Delay_us(60);
	OneWire_DataPinInput(SEN_ID);
	OneWire_SetBusLine(1,SEN_ID);
}
 8003b7c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8003b80:	f001 be0e 	b.w	80057a0 <OneWire_SetBusLine.part.2.14391>
 8003b84:	20000d3c 	.word	0x20000d3c
 8003b88:	40021000 	.word	0x40021000
 8003b8c:	00000000 	.word	0x00000000

08003b90 <writeRomCode>:
	ROM_CodeSearcher(2);
    ROM_CodeSearcher(3);

}

void writeRomCode(int d){
 8003b90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
        case 1:
            OneWire_WriteByte(a[i]);
        break;

        case 2:
            OneWire_WriteByte(b[i]);
 8003b94:	f8df a070 	ldr.w	sl, [pc, #112]	; 8003c08 <writeRomCode+0x78>
        break;

        case 3:
            OneWire_WriteByte(c[i]);
 8003b98:	f8df 9070 	ldr.w	r9, [pc, #112]	; 8003c0c <writeRomCode+0x7c>


    for(i = 0; i < 8; i++){
    switch (d) {
        case 1:
            OneWire_WriteByte(a[i]);
 8003b9c:	f8df 8070 	ldr.w	r8, [pc, #112]	; 8003c10 <writeRomCode+0x80>
	ROM_CodeSearcher(2);
    ROM_CodeSearcher(3);

}

void writeRomCode(int d){
 8003ba0:	4607      	mov	r7, r0
uint8_t *a = ROM_ADRESS_1; //{0x28, 0xC9, 0x30, 0x01, 0x07, 0x00, 0x00, 0x66 };
uint8_t *b = ROM_ADRESS_2;//{0x28, 0xC1, 0x29, 0x01, 0x07, 0x00, 0x00, 0x48 };
uint8_t *c = ROM_ADRESS_3;


    for(i = 0; i < 8; i++){
 8003ba2:	2600      	movs	r6, #0
 8003ba4:	e006      	b.n	8003bb4 <writeRomCode+0x24>
    switch (d) {
 8003ba6:	2f03      	cmp	r7, #3
 8003ba8:	d022      	beq.n	8003bf0 <writeRomCode+0x60>
 8003baa:	2f01      	cmp	r7, #1
 8003bac:	d014      	beq.n	8003bd8 <writeRomCode+0x48>
uint8_t *a = ROM_ADRESS_1; //{0x28, 0xC9, 0x30, 0x01, 0x07, 0x00, 0x00, 0x66 };
uint8_t *b = ROM_ADRESS_2;//{0x28, 0xC1, 0x29, 0x01, 0x07, 0x00, 0x00, 0x48 };
uint8_t *c = ROM_ADRESS_3;


    for(i = 0; i < 8; i++){
 8003bae:	3601      	adds	r6, #1
 8003bb0:	2e08      	cmp	r6, #8
 8003bb2:	d00f      	beq.n	8003bd4 <writeRomCode+0x44>
    switch (d) {
 8003bb4:	2f02      	cmp	r7, #2
 8003bb6:	d1f6      	bne.n	8003ba6 <writeRomCode+0x16>
        case 1:
            OneWire_WriteByte(a[i]);
        break;

        case 2:
            OneWire_WriteByte(b[i]);
 8003bb8:	f816 500a 	ldrb.w	r5, [r6, sl]
 8003bbc:	2408      	movs	r4, #8
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
	{
		OneWire_WriteBit(_data & 0x01);
 8003bbe:	f005 0001 	and.w	r0, r5, #1
 8003bc2:	f7ff ff95 	bl	8003af0 <OneWire_WriteBit>

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8003bc6:	3c01      	subs	r4, #1
	{
		OneWire_WriteBit(_data & 0x01);
		_data>>= 1;
 8003bc8:	ea4f 0555 	mov.w	r5, r5, lsr #1

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8003bcc:	d1f7      	bne.n	8003bbe <writeRomCode+0x2e>
uint8_t *a = ROM_ADRESS_1; //{0x28, 0xC9, 0x30, 0x01, 0x07, 0x00, 0x00, 0x66 };
uint8_t *b = ROM_ADRESS_2;//{0x28, 0xC1, 0x29, 0x01, 0x07, 0x00, 0x00, 0x48 };
uint8_t *c = ROM_ADRESS_3;


    for(i = 0; i < 8; i++){
 8003bce:	3601      	adds	r6, #1
 8003bd0:	2e08      	cmp	r6, #8
 8003bd2:	d1ef      	bne.n	8003bb4 <writeRomCode+0x24>
        case 3:
            OneWire_WriteByte(c[i]);
        break;
        }
    }
}
 8003bd4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}


    for(i = 0; i < 8; i++){
    switch (d) {
        case 1:
            OneWire_WriteByte(a[i]);
 8003bd8:	f816 5008 	ldrb.w	r5, [r6, r8]
 8003bdc:	2408      	movs	r4, #8
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
	{
		OneWire_WriteBit(_data & 0x01);
 8003bde:	f005 0001 	and.w	r0, r5, #1
 8003be2:	f7ff ff85 	bl	8003af0 <OneWire_WriteBit>

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8003be6:	3c01      	subs	r4, #1
	{
		OneWire_WriteBit(_data & 0x01);
		_data>>= 1;
 8003be8:	ea4f 0555 	mov.w	r5, r5, lsr #1

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8003bec:	d1f7      	bne.n	8003bde <writeRomCode+0x4e>
 8003bee:	e7de      	b.n	8003bae <writeRomCode+0x1e>
        case 2:
            OneWire_WriteByte(b[i]);
        break;

        case 3:
            OneWire_WriteByte(c[i]);
 8003bf0:	f816 5009 	ldrb.w	r5, [r6, r9]
 8003bf4:	2408      	movs	r4, #8
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
	{
		OneWire_WriteBit(_data & 0x01);
 8003bf6:	f005 0001 	and.w	r0, r5, #1
 8003bfa:	f7ff ff79 	bl	8003af0 <OneWire_WriteBit>

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8003bfe:	3c01      	subs	r4, #1
	{
		OneWire_WriteBit(_data & 0x01);
		_data>>= 1;
 8003c00:	ea4f 0555 	mov.w	r5, r5, lsr #1

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8003c04:	d1f7      	bne.n	8003bf6 <writeRomCode+0x66>
 8003c06:	e7d2      	b.n	8003bae <writeRomCode+0x1e>
 8003c08:	20002280 	.word	0x20002280
 8003c0c:	200023d8 	.word	0x200023d8
 8003c10:	200023d0 	.word	0x200023d0
	...

08003c20 <OneWire_ReadByte>:
		_data>>= 1;
	}
	}

uint8_t OneWire_ReadByte(void)
{
 8003c20:	b538      	push	{r3, r4, r5, lr}
 8003c22:	2507      	movs	r5, #7
	uint8_t data = 0;
 8003c24:	2400      	movs	r4, #0
    int i = 0;
	for( i; i<7; i++)
	{
		if(OneWire_ReadBit())
 8003c26:	f7ff fe7b 	bl	8003920 <OneWire_ReadBit.4294>
 8003c2a:	b108      	cbz	r0, 8003c30 <OneWire_ReadByte+0x10>
			data|= 0x80;
 8003c2c:	f044 0480 	orr.w	r4, r4, #128	; 0x80

uint8_t OneWire_ReadByte(void)
{
	uint8_t data = 0;
    int i = 0;
	for( i; i<7; i++)
 8003c30:	3d01      	subs	r5, #1
	{
		if(OneWire_ReadBit())
			data|= 0x80;
		data>>= 1;
 8003c32:	ea4f 0454 	mov.w	r4, r4, lsr #1

uint8_t OneWire_ReadByte(void)
{
	uint8_t data = 0;
    int i = 0;
	for( i; i<7; i++)
 8003c36:	d1f6      	bne.n	8003c26 <OneWire_ReadByte+0x6>
	{
		if(OneWire_ReadBit())
			data|= 0x80;
		data>>= 1;
	}
	if(OneWire_ReadBit())
 8003c38:	f7ff fe72 	bl	8003920 <OneWire_ReadBit.4294>
 8003c3c:	b110      	cbz	r0, 8003c44 <OneWire_ReadByte+0x24>
		data|= 0x80;
 8003c3e:	f064 047f 	orn	r4, r4, #127	; 0x7f
 8003c42:	b2e4      	uxtb	r4, r4

	return data;
}
 8003c44:	4620      	mov	r0, r4
 8003c46:	bd38      	pop	{r3, r4, r5, pc}
	...

08003c50 <ROM_CodeSearcher>:

}

/**read sensor rom code **/
void ROM_CodeSearcher(int id){
    switch(id-1){
 8003c50:	3801      	subs	r0, #1
 8003c52:	2801      	cmp	r0, #1
	return Temp;

}

/**read sensor rom code **/
void ROM_CodeSearcher(int id){
 8003c54:	b538      	push	{r3, r4, r5, lr}
    switch(id-1){
 8003c56:	d039      	beq.n	8003ccc <ROM_CodeSearcher+0x7c>
 8003c58:	2802      	cmp	r0, #2
 8003c5a:	d01c      	beq.n	8003c96 <ROM_CodeSearcher+0x46>
 8003c5c:	b100      	cbz	r0, 8003c60 <ROM_CodeSearcher+0x10>
 8003c5e:	bd38      	pop	{r3, r4, r5, pc}
    case 0:{
        int i;
        OneWire_Reset(SEN_ID);
 8003c60:	4b28      	ldr	r3, [pc, #160]	; (8003d04 <ROM_CodeSearcher+0xb4>)
 8003c62:	7818      	ldrb	r0, [r3, #0]
 8003c64:	f7ff ff14 	bl	8003a90 <OneWire_Reset>
 8003c68:	2508      	movs	r5, #8
	OneWire_SetBusLine(1,SEN_ID);
}

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
 8003c6a:	2433      	movs	r4, #51	; 0x33
    int i = 0;
	for(i; i<8; i++)
	{
		OneWire_WriteBit(_data & 0x01);
 8003c6c:	f004 0001 	and.w	r0, r4, #1
 8003c70:	f7ff ff3e 	bl	8003af0 <OneWire_WriteBit>

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8003c74:	3d01      	subs	r5, #1
	{
		OneWire_WriteBit(_data & 0x01);
		_data>>= 1;
 8003c76:	ea4f 0454 	mov.w	r4, r4, lsr #1

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8003c7a:	d1f7      	bne.n	8003c6c <ROM_CodeSearcher+0x1c>
 8003c7c:	2001      	movs	r0, #1
 8003c7e:	4c22      	ldr	r4, [pc, #136]	; (8003d08 <ROM_CodeSearcher+0xb8>)
 8003c80:	f001 fd8e 	bl	80057a0 <OneWire_SetBusLine.part.2.14391>
 8003c84:	f104 0508 	add.w	r5, r4, #8
        int i;
        OneWire_Reset(SEN_ID);
        OneWire_WriteByte(0x33);
        OneWire_SetBusLine(1,1);
        for(i = 0 ; i < 8 ; i++){
        ROM_ADRESS_1[i] = OneWire_ReadByte();
 8003c88:	f7ff ffca 	bl	8003c20 <OneWire_ReadByte>
 8003c8c:	f804 0f01 	strb.w	r0, [r4, #1]!
    case 0:{
        int i;
        OneWire_Reset(SEN_ID);
        OneWire_WriteByte(0x33);
        OneWire_SetBusLine(1,1);
        for(i = 0 ; i < 8 ; i++){
 8003c90:	42ac      	cmp	r4, r5
 8003c92:	d1f9      	bne.n	8003c88 <ROM_CodeSearcher+0x38>
 8003c94:	bd38      	pop	{r3, r4, r5, pc}
        }
    }
    break;
    case 2:{
        int k;
        OneWire_Reset(SEN_ID);
 8003c96:	4b1b      	ldr	r3, [pc, #108]	; (8003d04 <ROM_CodeSearcher+0xb4>)
 8003c98:	7818      	ldrb	r0, [r3, #0]
 8003c9a:	f7ff fef9 	bl	8003a90 <OneWire_Reset>
 8003c9e:	2508      	movs	r5, #8
	OneWire_SetBusLine(1,SEN_ID);
}

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
 8003ca0:	2433      	movs	r4, #51	; 0x33
    int i = 0;
	for(i; i<8; i++)
	{
		OneWire_WriteBit(_data & 0x01);
 8003ca2:	f004 0001 	and.w	r0, r4, #1
 8003ca6:	f7ff ff23 	bl	8003af0 <OneWire_WriteBit>

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8003caa:	3d01      	subs	r5, #1
	{
		OneWire_WriteBit(_data & 0x01);
		_data>>= 1;
 8003cac:	ea4f 0454 	mov.w	r4, r4, lsr #1

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8003cb0:	d1f7      	bne.n	8003ca2 <ROM_CodeSearcher+0x52>
 8003cb2:	2003      	movs	r0, #3
 8003cb4:	4c15      	ldr	r4, [pc, #84]	; (8003d0c <ROM_CodeSearcher+0xbc>)
 8003cb6:	f001 fd73 	bl	80057a0 <OneWire_SetBusLine.part.2.14391>
 8003cba:	f104 0508 	add.w	r5, r4, #8
        int k;
        OneWire_Reset(SEN_ID);
        OneWire_WriteByte(0x33);
        OneWire_SetBusLine(1,3);
        for(k = 0 ; k < 8 ; k++){
        ROM_ADRESS_3[k] = OneWire_ReadByte();
 8003cbe:	f7ff ffaf 	bl	8003c20 <OneWire_ReadByte>
 8003cc2:	f804 0f01 	strb.w	r0, [r4, #1]!
    case 2:{
        int k;
        OneWire_Reset(SEN_ID);
        OneWire_WriteByte(0x33);
        OneWire_SetBusLine(1,3);
        for(k = 0 ; k < 8 ; k++){
 8003cc6:	42ac      	cmp	r4, r5
 8003cc8:	d1f9      	bne.n	8003cbe <ROM_CodeSearcher+0x6e>
 8003cca:	bd38      	pop	{r3, r4, r5, pc}
        }
    }
    break;
    case 1:{
        int j;
        OneWire_Reset(SEN_ID);
 8003ccc:	4b0d      	ldr	r3, [pc, #52]	; (8003d04 <ROM_CodeSearcher+0xb4>)
 8003cce:	7818      	ldrb	r0, [r3, #0]
 8003cd0:	f7ff fede 	bl	8003a90 <OneWire_Reset>
 8003cd4:	2508      	movs	r5, #8
	OneWire_SetBusLine(1,SEN_ID);
}

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
 8003cd6:	2433      	movs	r4, #51	; 0x33
    int i = 0;
	for(i; i<8; i++)
	{
		OneWire_WriteBit(_data & 0x01);
 8003cd8:	f004 0001 	and.w	r0, r4, #1
 8003cdc:	f7ff ff08 	bl	8003af0 <OneWire_WriteBit>

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8003ce0:	3d01      	subs	r5, #1
	{
		OneWire_WriteBit(_data & 0x01);
		_data>>= 1;
 8003ce2:	ea4f 0454 	mov.w	r4, r4, lsr #1

void OneWire_WriteByte(uint8_t data)
{
	uint8_t _data = data;
    int i = 0;
	for(i; i<8; i++)
 8003ce6:	d1f7      	bne.n	8003cd8 <ROM_CodeSearcher+0x88>
 8003ce8:	2002      	movs	r0, #2
 8003cea:	4c09      	ldr	r4, [pc, #36]	; (8003d10 <ROM_CodeSearcher+0xc0>)
 8003cec:	f001 fd58 	bl	80057a0 <OneWire_SetBusLine.part.2.14391>
 8003cf0:	f104 0508 	add.w	r5, r4, #8
        int j;
        OneWire_Reset(SEN_ID);
        OneWire_WriteByte(0x33);
        OneWire_SetBusLine(1,2);
        for(j = 0 ; j < 8 ; j++){
        ROM_ADRESS_2[j] = OneWire_ReadByte();
 8003cf4:	f7ff ff94 	bl	8003c20 <OneWire_ReadByte>
 8003cf8:	f804 0f01 	strb.w	r0, [r4, #1]!
    case 1:{
        int j;
        OneWire_Reset(SEN_ID);
        OneWire_WriteByte(0x33);
        OneWire_SetBusLine(1,2);
        for(j = 0 ; j < 8 ; j++){
 8003cfc:	42ac      	cmp	r4, r5
 8003cfe:	d1f9      	bne.n	8003cf4 <ROM_CodeSearcher+0xa4>
 8003d00:	bd38      	pop	{r3, r4, r5, pc}
 8003d02:	bf00      	nop
 8003d04:	20000d3c 	.word	0x20000d3c
 8003d08:	200023cf 	.word	0x200023cf
 8003d0c:	200023d7 	.word	0x200023d7
 8003d10:	2000227f 	.word	0x2000227f
	...

08003d20 <DS18B20_Init>:
	}
    else return 0;
}

void DS18B20_Init(void)
{
 8003d20:	b508      	push	{r3, lr}
    OneWire_DataPinOutput(1);
 8003d22:	2001      	movs	r0, #1
 8003d24:	f001 fd24 	bl	8005770 <OneWire_DataPinOutput>
    OneWire_DataPinOutput(2);
 8003d28:	2002      	movs	r0, #2
 8003d2a:	f001 fd21 	bl	8005770 <OneWire_DataPinOutput>
    OneWire_DataPinOutput(3);
 8003d2e:	2003      	movs	r0, #3
 8003d30:	f001 fd1e 	bl	8005770 <OneWire_DataPinOutput>
	OneWire_Reset(1);
 8003d34:	2001      	movs	r0, #1
 8003d36:	f7ff feab 	bl	8003a90 <OneWire_Reset>
	OneWire_Reset(2);
 8003d3a:	2002      	movs	r0, #2
 8003d3c:	f7ff fea8 	bl	8003a90 <OneWire_Reset>
	OneWire_Reset(3);
 8003d40:	2003      	movs	r0, #3
 8003d42:	f7ff fea5 	bl	8003a90 <OneWire_Reset>
	ROM_CodeSearcher(1);
 8003d46:	2001      	movs	r0, #1
 8003d48:	f7ff ff82 	bl	8003c50 <ROM_CodeSearcher>
	ROM_CodeSearcher(2);
 8003d4c:	2002      	movs	r0, #2
 8003d4e:	f7ff ff7f 	bl	8003c50 <ROM_CodeSearcher>
    ROM_CodeSearcher(3);
 8003d52:	2003      	movs	r0, #3

}
 8003d54:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	OneWire_Reset(1);
	OneWire_Reset(2);
	OneWire_Reset(3);
	ROM_CodeSearcher(1);
	ROM_CodeSearcher(2);
    ROM_CodeSearcher(3);
 8003d58:	f7ff bf7a 	b.w	8003c50 <ROM_CodeSearcher>
 8003d5c:	0000      	movs	r0, r0
	...

08003d60 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8003d60:	b4f0      	push	{r4, r5, r6, r7}
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8003d62:	4d1c      	ldr	r5, [pc, #112]	; (8003dd4 <chVTDoSetI+0x74>)
 8003d64:	462e      	mov	r6, r5
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003d66:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 8003d6a:	f856 4f1c 	ldr.w	r4, [r6, #28]!
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8003d6e:	6103      	str	r3, [r0, #16]
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8003d70:	2901      	cmp	r1, #1
 8003d72:	bf98      	it	ls
 8003d74:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8003d76:	42b4      	cmp	r4, r6

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 8003d78:	60c2      	str	r2, [r0, #12]
 8003d7a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8003d7c:	d01b      	beq.n	8003db6 <chVTDoSetI+0x56>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8003d7e:	6aae      	ldr	r6, [r5, #40]	; 0x28
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8003d80:	68a2      	ldr	r2, [r4, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8003d82:	4419      	add	r1, r3
 8003d84:	1b8b      	subs	r3, r1, r6
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8003d86:	4293      	cmp	r3, r2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003d88:	bf38      	it	cc
 8003d8a:	6379      	strcc	r1, [r7, #52]	; 0x34
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8003d8c:	4293      	cmp	r3, r2
 8003d8e:	d904      	bls.n	8003d9a <chVTDoSetI+0x3a>
    delta -= p->vt_delta;
    p = p->vt_next;
 8003d90:	6824      	ldr	r4, [r4, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 8003d92:	1a9b      	subs	r3, r3, r2
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8003d94:	68a2      	ldr	r2, [r4, #8]
 8003d96:	429a      	cmp	r2, r3
 8003d98:	d3fa      	bcc.n	8003d90 <chVTDoSetI+0x30>
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8003d9a:	6862      	ldr	r2, [r4, #4]
 8003d9c:	6042      	str	r2, [r0, #4]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8003d9e:	6004      	str	r4, [r0, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 8003da0:	6010      	str	r0, [r2, #0]
  p->vt_prev = vtp;
 8003da2:	6060      	str	r0, [r4, #4]
  vtp->vt_delta = delta
 8003da4:	6083      	str	r3, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8003da6:	68a2      	ldr	r2, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8003da8:	f04f 31ff 	mov.w	r1, #4294967295
  p->vt_prev = vtp;
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8003dac:	1ad3      	subs	r3, r2, r3
 8003dae:	60a3      	str	r3, [r4, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8003db0:	6269      	str	r1, [r5, #36]	; 0x24
}
 8003db2:	bcf0      	pop	{r4, r5, r6, r7}
 8003db4:	4770      	bx	lr
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
      vtp->vt_delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.vt_lasttime + delay);
 8003db6:	eb01 0c03 	add.w	ip, r1, r3
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
 8003dba:	2600      	movs	r6, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003dbc:	2202      	movs	r2, #2
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 8003dbe:	62ab      	str	r3, [r5, #40]	; 0x28
      ch.vtlist.vt_next = vtp;
 8003dc0:	61e8      	str	r0, [r5, #28]
      ch.vtlist.vt_prev = vtp;
 8003dc2:	6228      	str	r0, [r5, #32]
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 8003dc4:	6004      	str	r4, [r0, #0]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8003dc6:	6044      	str	r4, [r0, #4]
      vtp->vt_delta = delay;
 8003dc8:	6081      	str	r1, [r0, #8]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003dca:	f8c7 c034 	str.w	ip, [r7, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8003dce:	613e      	str	r6, [r7, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003dd0:	60fa      	str	r2, [r7, #12]
 8003dd2:	e7ee      	b.n	8003db2 <chVTDoSetI+0x52>
 8003dd4:	200016a8 	.word	0x200016a8
	...

08003de0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8003de0:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8003de2:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8003de4:	b087      	sub	sp, #28
 8003de6:	4605      	mov	r5, r0

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8003de8:	d011      	beq.n	8003e0e <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8003dea:	4c0c      	ldr	r4, [pc, #48]	; (8003e1c <chSchGoSleepTimeoutS+0x3c>)
 8003dec:	4a0c      	ldr	r2, [pc, #48]	; (8003e20 <chSchGoSleepTimeoutS+0x40>)
 8003dee:	69a3      	ldr	r3, [r4, #24]
 8003df0:	a801      	add	r0, sp, #4
 8003df2:	f7ff ffb5 	bl	8003d60 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8003df6:	4628      	mov	r0, r5
 8003df8:	f7fd fcba 	bl	8001770 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8003dfc:	9b04      	ldr	r3, [sp, #16]
 8003dfe:	b113      	cbz	r3, 8003e06 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 8003e00:	a801      	add	r0, sp, #4
 8003e02:	f7ff fe0d 	bl	8003a20 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 8003e06:	69a3      	ldr	r3, [r4, #24]
}
 8003e08:	6a18      	ldr	r0, [r3, #32]
 8003e0a:	b007      	add	sp, #28
 8003e0c:	bd30      	pop	{r4, r5, pc}
 8003e0e:	4c03      	ldr	r4, [pc, #12]	; (8003e1c <chSchGoSleepTimeoutS+0x3c>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8003e10:	f7fd fcae 	bl	8001770 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8003e14:	69a3      	ldr	r3, [r4, #24]
}
 8003e16:	6a18      	ldr	r0, [r3, #32]
 8003e18:	b007      	add	sp, #28
 8003e1a:	bd30      	pop	{r4, r5, pc}
 8003e1c:	200016a8 	.word	0x200016a8
 8003e20:	080011e1 	.word	0x080011e1
	...

08003e30 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8003e30:	b508      	push	{r3, lr}
 8003e32:	4601      	mov	r1, r0
 8003e34:	2320      	movs	r3, #32
 8003e36:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8003e3a:	2008      	movs	r0, #8
 8003e3c:	f7ff ffd0 	bl	8003de0 <chSchGoSleepTimeoutS>
 8003e40:	2300      	movs	r3, #0
 8003e42:	f383 8811 	msr	BASEPRI, r3
 8003e46:	bd08      	pop	{r3, pc}
	...

08003e50 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8003e50:	b410      	push	{r4}
 8003e52:	4602      	mov	r2, r0

  if (TIME_IMMEDIATE == timeout) {
 8003e54:	b159      	cbz	r1, 8003e6e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8003e56:	4b08      	ldr	r3, [pc, #32]	; (8003e78 <chThdEnqueueTimeoutS+0x28>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8003e58:	6844      	ldr	r4, [r0, #4]
 8003e5a:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8003e5c:	2004      	movs	r0, #4
 8003e5e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
 8003e62:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
 8003e64:	6053      	str	r3, [r2, #4]
}
 8003e66:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8003e6a:	f7ff bfb9 	b.w	8003de0 <chSchGoSleepTimeoutS>
}
 8003e6e:	f04f 30ff 	mov.w	r0, #4294967295
 8003e72:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003e76:	4770      	bx	lr
 8003e78:	200016a8 	.word	0x200016a8
 8003e7c:	00000000 	.word	0x00000000

08003e80 <chIQGetTimeout.4065>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8003e80:	b570      	push	{r4, r5, r6, lr}
 8003e82:	2320      	movs	r3, #32
 8003e84:	460e      	mov	r6, r1
 8003e86:	4604      	mov	r4, r0
 8003e88:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 8003e8c:	69c3      	ldr	r3, [r0, #28]
 8003e8e:	b12b      	cbz	r3, 8003e9c <chIQGetTimeout.4065+0x1c>
    iqp->q_notify(iqp);
 8003e90:	4798      	blx	r3
 8003e92:	e003      	b.n	8003e9c <chIQGetTimeout.4065+0x1c>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8003e94:	f7ff ffdc 	bl	8003e50 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8003e98:	2800      	cmp	r0, #0
 8003e9a:	db16      	blt.n	8003eca <chIQGetTimeout.4065+0x4a>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8003e9c:	68a5      	ldr	r5, [r4, #8]
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8003e9e:	4620      	mov	r0, r4
 8003ea0:	4631      	mov	r1, r6
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8003ea2:	2d00      	cmp	r5, #0
 8003ea4:	d0f6      	beq.n	8003e94 <chIQGetTimeout.4065+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8003ea6:	69a2      	ldr	r2, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8003ea8:	68a0      	ldr	r0, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8003eaa:	6921      	ldr	r1, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8003eac:	1c53      	adds	r3, r2, #1
  if (iqp->q_rdptr >= iqp->q_top) {
 8003eae:	428b      	cmp	r3, r1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8003eb0:	f100 30ff 	add.w	r0, r0, #4294967295
  b = *iqp->q_rdptr++;
 8003eb4:	61a3      	str	r3, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8003eb6:	60a0      	str	r0, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8003eb8:	bf28      	it	cs
 8003eba:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8003ebc:	7810      	ldrb	r0, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8003ebe:	bf28      	it	cs
 8003ec0:	61a3      	strcs	r3, [r4, #24]
 8003ec2:	2300      	movs	r3, #0
 8003ec4:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return (msg_t)b;
}
 8003ec8:	bd70      	pop	{r4, r5, r6, pc}
 8003eca:	f385 8811 	msr	BASEPRI, r5
 8003ece:	bd70      	pop	{r4, r5, r6, pc}

08003ed0 <gett.8168>:
  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, timeout);
 8003ed0:	300c      	adds	r0, #12
 8003ed2:	f7ff bfd5 	b.w	8003e80 <chIQGetTimeout.4065>
 8003ed6:	bf00      	nop
	...

08003ee0 <get.8172>:
  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, TIME_INFINITE);
 8003ee0:	300c      	adds	r0, #12
 8003ee2:	f04f 31ff 	mov.w	r1, #4294967295
 8003ee6:	f7ff bfcb 	b.w	8003e80 <chIQGetTimeout.4065>
 8003eea:	bf00      	nop
 8003eec:	0000      	movs	r0, r0
	...

08003ef0 <gett.7907>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8003ef0:	300c      	adds	r0, #12
 8003ef2:	f7ff bfc5 	b.w	8003e80 <chIQGetTimeout.4065>
 8003ef6:	bf00      	nop
	...

08003f00 <get.7911>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8003f00:	300c      	adds	r0, #12
 8003f02:	f04f 31ff 	mov.w	r1, #4294967295
 8003f06:	f7ff bfbb 	b.w	8003e80 <chIQGetTimeout.4065>
 8003f0a:	bf00      	nop
 8003f0c:	0000      	movs	r0, r0
	...

08003f10 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8003f10:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003f14:	4604      	mov	r4, r0
 8003f16:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 8003f18:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8003f1c:	f04f 0b20 	mov.w	fp, #32
 8003f20:	f38b 8811 	msr	BASEPRI, fp
  size_t r = 0;
 8003f24:	2600      	movs	r6, #0
 8003f26:	eb01 0a02 	add.w	sl, r1, r2
 8003f2a:	f101 0901 	add.w	r9, r1, #1

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 8003f2e:	f1b8 0f00 	cmp.w	r8, #0
 8003f32:	d005      	beq.n	8003f40 <chIQReadTimeout+0x30>
      nfy(iqp);
 8003f34:	4620      	mov	r0, r4
 8003f36:	47c0      	blx	r8
 8003f38:	e002      	b.n	8003f40 <chIQReadTimeout+0x30>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8003f3a:	f7ff ff89 	bl	8003e50 <chThdEnqueueTimeoutS>
 8003f3e:	b9f8      	cbnz	r0, 8003f80 <chIQReadTimeout+0x70>
 8003f40:	68a7      	ldr	r7, [r4, #8]
 8003f42:	4620      	mov	r0, r4
 8003f44:	4629      	mov	r1, r5
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8003f46:	2f00      	cmp	r7, #0
 8003f48:	d0f7      	beq.n	8003f3a <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8003f4a:	69a3      	ldr	r3, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8003f4c:	68a1      	ldr	r1, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8003f4e:	1c5a      	adds	r2, r3, #1
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8003f50:	3901      	subs	r1, #1
    *bp++ = *iqp->q_rdptr++;
 8003f52:	61a2      	str	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8003f54:	60a1      	str	r1, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8003f56:	781b      	ldrb	r3, [r3, #0]
 8003f58:	f809 3c01 	strb.w	r3, [r9, #-1]
    if (iqp->q_rdptr >= iqp->q_top) {
 8003f5c:	6923      	ldr	r3, [r4, #16]
 8003f5e:	69a2      	ldr	r2, [r4, #24]
 8003f60:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8003f62:	bf24      	itt	cs
 8003f64:	68e3      	ldrcs	r3, [r4, #12]
 8003f66:	61a3      	strcs	r3, [r4, #24]
 8003f68:	2300      	movs	r3, #0
 8003f6a:	f383 8811 	msr	BASEPRI, r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
    if (--n == 0U) {
 8003f6e:	45d1      	cmp	r9, sl
    if (iqp->q_rdptr >= iqp->q_top) {
      iqp->q_rdptr = iqp->q_buffer;
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 8003f70:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 8003f74:	d006      	beq.n	8003f84 <chIQReadTimeout+0x74>
 8003f76:	f38b 8811 	msr	BASEPRI, fp
 8003f7a:	f109 0901 	add.w	r9, r9, #1
 8003f7e:	e7d6      	b.n	8003f2e <chIQReadTimeout+0x1e>
 8003f80:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 8003f84:	4630      	mov	r0, r6
 8003f86:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003f8a:	bf00      	nop
 8003f8c:	0000      	movs	r0, r0
	...

08003f90 <readt.8145>:
  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialUSBDriver *)ip)->iqueue, bp, n, timeout);
 8003f90:	300c      	adds	r0, #12
 8003f92:	f7ff bfbd 	b.w	8003f10 <chIQReadTimeout>
 8003f96:	bf00      	nop
	...

08003fa0 <read.8152>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialUSBDriver *)ip)->iqueue, bp,
 8003fa0:	300c      	adds	r0, #12
 8003fa2:	f04f 33ff 	mov.w	r3, #4294967295
 8003fa6:	f7ff bfb3 	b.w	8003f10 <chIQReadTimeout>
 8003faa:	bf00      	nop
 8003fac:	0000      	movs	r0, r0
	...

08003fb0 <readt.7884>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8003fb0:	300c      	adds	r0, #12
 8003fb2:	f7ff bfad 	b.w	8003f10 <chIQReadTimeout>
 8003fb6:	bf00      	nop
	...

08003fc0 <read.7891>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8003fc0:	300c      	adds	r0, #12
 8003fc2:	f04f 33ff 	mov.w	r3, #4294967295
 8003fc6:	f7ff bfa3 	b.w	8003f10 <chIQReadTimeout>
 8003fca:	bf00      	nop
 8003fcc:	0000      	movs	r0, r0
	...

08003fd0 <chOQPutTimeout.4195>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8003fd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003fd2:	4604      	mov	r4, r0
 8003fd4:	460f      	mov	r7, r1
 8003fd6:	4616      	mov	r6, r2
 8003fd8:	2320      	movs	r3, #32
 8003fda:	f383 8811 	msr	BASEPRI, r3
 8003fde:	e003      	b.n	8003fe8 <chOQPutTimeout.4195+0x18>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8003fe0:	f7ff ff36 	bl	8003e50 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8003fe4:	2800      	cmp	r0, #0
 8003fe6:	db19      	blt.n	800401c <chOQPutTimeout.4195+0x4c>
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8003fe8:	68a5      	ldr	r5, [r4, #8]
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8003fea:	4620      	mov	r0, r4
 8003fec:	4631      	mov	r1, r6
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8003fee:	2d00      	cmp	r5, #0
 8003ff0:	d0f6      	beq.n	8003fe0 <chOQPutTimeout.4195+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8003ff2:	6963      	ldr	r3, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8003ff4:	68a1      	ldr	r1, [r4, #8]
  *oqp->q_wrptr++ = b;
 8003ff6:	1c5a      	adds	r2, r3, #1
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8003ff8:	3901      	subs	r1, #1
  *oqp->q_wrptr++ = b;
 8003ffa:	6162      	str	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8003ffc:	60a1      	str	r1, [r4, #8]
  *oqp->q_wrptr++ = b;
 8003ffe:	701f      	strb	r7, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8004000:	6923      	ldr	r3, [r4, #16]
 8004002:	6962      	ldr	r2, [r4, #20]
 8004004:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8004006:	bf24      	itt	cs
 8004008:	68e3      	ldrcs	r3, [r4, #12]
 800400a:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 800400c:	69e3      	ldr	r3, [r4, #28]
 800400e:	b10b      	cbz	r3, 8004014 <chOQPutTimeout.4195+0x44>
    oqp->q_notify(oqp);
 8004010:	4620      	mov	r0, r4
 8004012:	4798      	blx	r3
 8004014:	2000      	movs	r0, #0
 8004016:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 800401a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800401c:	f385 8811 	msr	BASEPRI, r5
 8004020:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004022:	bf00      	nop
	...

08004030 <putt.8175>:
  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, timeout);
 8004030:	3030      	adds	r0, #48	; 0x30
 8004032:	f7ff bfcd 	b.w	8003fd0 <chOQPutTimeout.4195>
 8004036:	bf00      	nop
	...

08004040 <put.8180>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialUSBDriver *)ip)->oqueue, b, TIME_INFINITE);
 8004040:	3030      	adds	r0, #48	; 0x30
 8004042:	f04f 32ff 	mov.w	r2, #4294967295
 8004046:	f7ff bfc3 	b.w	8003fd0 <chOQPutTimeout.4195>
 800404a:	bf00      	nop
 800404c:	0000      	movs	r0, r0
	...

08004050 <putt.7914>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8004050:	3030      	adds	r0, #48	; 0x30
 8004052:	f7ff bfbd 	b.w	8003fd0 <chOQPutTimeout.4195>
 8004056:	bf00      	nop
	...

08004060 <put.7919>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8004060:	3030      	adds	r0, #48	; 0x30
 8004062:	f04f 32ff 	mov.w	r2, #4294967295
 8004066:	f7ff bfb3 	b.w	8003fd0 <chOQPutTimeout.4195>
 800406a:	bf00      	nop
 800406c:	0000      	movs	r0, r0
	...

08004070 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8004070:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004074:	b083      	sub	sp, #12
 8004076:	4604      	mov	r4, r0
 8004078:	460d      	mov	r5, r1
 800407a:	4616      	mov	r6, r2
 800407c:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 800407e:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8004082:	f04f 0a20 	mov.w	sl, #32
 8004086:	f38a 8811 	msr	BASEPRI, sl
  size_t w = 0;
 800408a:	2700      	movs	r7, #0
 800408c:	46b9      	mov	r9, r7
 800408e:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8004090:	f105 0b01 	add.w	fp, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 8004094:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8004096:	b303      	cbz	r3, 80040da <chOQWriteTimeout+0x6a>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8004098:	6963      	ldr	r3, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800409a:	68a1      	ldr	r1, [r4, #8]
 800409c:	1e4a      	subs	r2, r1, #1
    *oqp->q_wrptr++ = *bp++;
 800409e:	1c59      	adds	r1, r3, #1
 80040a0:	6161      	str	r1, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 80040a2:	60a2      	str	r2, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 80040a4:	7829      	ldrb	r1, [r5, #0]
 80040a6:	7019      	strb	r1, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 80040a8:	6923      	ldr	r3, [r4, #16]
 80040aa:	6961      	ldr	r1, [r4, #20]
 80040ac:	4299      	cmp	r1, r3
      oqp->q_wrptr = oqp->q_buffer;
 80040ae:	bf24      	itt	cs
 80040b0:	68e3      	ldrcs	r3, [r4, #12]
 80040b2:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
 80040b4:	f1b8 0f00 	cmp.w	r8, #0
 80040b8:	d000      	beq.n	80040bc <chOQWriteTimeout+0x4c>
      nfy(oqp);
 80040ba:	47c0      	blx	r8
 80040bc:	f389 8811 	msr	BASEPRI, r9
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 80040c0:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 80040c2:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
 80040c6:	d012      	beq.n	80040ee <chOQWriteTimeout+0x7e>
 80040c8:	f38a 8811 	msr	BASEPRI, sl
 80040cc:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80040ce:	465d      	mov	r5, fp
 80040d0:	f105 0b01 	add.w	fp, r5, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
      nfy(oqp);
 80040d4:	4620      	mov	r0, r4

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80040d6:	2b00      	cmp	r3, #0
 80040d8:	d1de      	bne.n	8004098 <chOQWriteTimeout+0x28>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 80040da:	4620      	mov	r0, r4
 80040dc:	9901      	ldr	r1, [sp, #4]
 80040de:	9300      	str	r3, [sp, #0]
 80040e0:	f7ff feb6 	bl	8003e50 <chThdEnqueueTimeoutS>
 80040e4:	9b00      	ldr	r3, [sp, #0]
 80040e6:	2800      	cmp	r0, #0
 80040e8:	d0d1      	beq.n	800408e <chOQWriteTimeout+0x1e>
 80040ea:	f383 8811 	msr	BASEPRI, r3
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 80040ee:	4638      	mov	r0, r7
 80040f0:	b003      	add	sp, #12
 80040f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80040f6:	bf00      	nop
	...

08004100 <cmd_wifi.16079>:
               return 1;
    }
}


static void cmd_wifi(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004100:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 chThdSleepMilliseconds(5000);
}

int wifiInit(void){

 sdWrite(&SD3, &comAT,strlen(comAT));
 8004104:	f8df b1a0 	ldr.w	fp, [pc, #416]	; 80042a8 <cmd_wifi.16079+0x1a8>
  uint8_t *u;
  (void)argv;

    while(true){
               //palSetPad(RELAY_PORT, RELAY_PIN);
               chprintf(chp, "wifi: Processing...\n\r");
 8004108:	495d      	ldr	r1, [pc, #372]	; (8004280 <cmd_wifi.16079+0x180>)
 800410a:	4c5e      	ldr	r4, [pc, #376]	; (8004284 <cmd_wifi.16079+0x184>)

 chThdSleepMilliseconds(10000);
 800410c:	4d5e      	ldr	r5, [pc, #376]	; (8004288 <cmd_wifi.16079+0x188>)

 sdWrite(&SD3, &comATCWMODE,strlen(comATCWMODE));
 800410e:	4e5f      	ldr	r6, [pc, #380]	; (800428c <cmd_wifi.16079+0x18c>)
 chThdSleepMilliseconds(10000);

 //sdWrite(&SD3, &comATCWLAP,strlen(comATCWLAP));
 //chThdSleepMilliseconds(10000);

 sdWrite(&SD3, &comATCWJAP,strlen(comATCWJAP));
 8004110:	f8df a198 	ldr.w	sl, [pc, #408]	; 80042ac <cmd_wifi.16079+0x1ac>
 sdWrite(&SD3, &sep,strlen(1));
 8004114:	4f5e      	ldr	r7, [pc, #376]	; (8004290 <cmd_wifi.16079+0x190>)
 sdWrite(&SD3, &SSID,strlen(SSID));
 8004116:	f8df 9198 	ldr.w	r9, [pc, #408]	; 80042b0 <cmd_wifi.16079+0x1b0>
 sdWrite(&SD3, &sep,strlen(1));
 sdWrite(&SD3, &dot,strlen(dot));
 800411a:	f8df 8198 	ldr.w	r8, [pc, #408]	; 80042b4 <cmd_wifi.16079+0x1b4>
               return 1;
    }
}


static void cmd_wifi(BaseSequentialStream *chp, int argc, char *argv[]) {
 800411e:	b081      	sub	sp, #4
  uint8_t *u;
  (void)argv;

    while(true){
               //palSetPad(RELAY_PORT, RELAY_PIN);
               chprintf(chp, "wifi: Processing...\n\r");
 8004120:	f001 f98e 	bl	8005440 <chprintf.16065>
 chThdSleepMilliseconds(5000);
}

int wifiInit(void){

 sdWrite(&SD3, &comAT,strlen(comAT));
 8004124:	4658      	mov	r0, fp
 8004126:	f002 fc83 	bl	8006a30 <strlen>
 800412a:	4659      	mov	r1, fp
 800412c:	4602      	mov	r2, r0
 800412e:	f04f 33ff 	mov.w	r3, #4294967295
 8004132:	4620      	mov	r0, r4
 8004134:	f7ff ff9c 	bl	8004070 <chOQWriteTimeout>

 chThdSleepMilliseconds(10000);
 8004138:	4628      	mov	r0, r5
 800413a:	f7ff fe79 	bl	8003e30 <chThdSleep>

 sdWrite(&SD3, &comATCWMODE,strlen(comATCWMODE));
 800413e:	4630      	mov	r0, r6
 8004140:	f002 fc76 	bl	8006a30 <strlen>
 8004144:	4631      	mov	r1, r6
 8004146:	4602      	mov	r2, r0
 8004148:	f04f 33ff 	mov.w	r3, #4294967295
 800414c:	4620      	mov	r0, r4
 800414e:	f7ff ff8f 	bl	8004070 <chOQWriteTimeout>
 chThdSleepMilliseconds(10000);
 8004152:	4628      	mov	r0, r5
 8004154:	f7ff fe6c 	bl	8003e30 <chThdSleep>

 //sdWrite(&SD3, &comATCWLAP,strlen(comATCWLAP));
 //chThdSleepMilliseconds(10000);

 sdWrite(&SD3, &comATCWJAP,strlen(comATCWJAP));
 8004158:	4650      	mov	r0, sl
 800415a:	f002 fc69 	bl	8006a30 <strlen>
 800415e:	4651      	mov	r1, sl
 8004160:	4602      	mov	r2, r0
 8004162:	f04f 33ff 	mov.w	r3, #4294967295
 8004166:	4620      	mov	r0, r4
 8004168:	f7ff ff82 	bl	8004070 <chOQWriteTimeout>
 sdWrite(&SD3, &sep,strlen(1));
 800416c:	2001      	movs	r0, #1
 800416e:	f002 fc5f 	bl	8006a30 <strlen>
 8004172:	4639      	mov	r1, r7
 8004174:	4602      	mov	r2, r0
 8004176:	f04f 33ff 	mov.w	r3, #4294967295
 800417a:	4620      	mov	r0, r4
 800417c:	f7ff ff78 	bl	8004070 <chOQWriteTimeout>
 sdWrite(&SD3, &SSID,strlen(SSID));
 8004180:	4648      	mov	r0, r9
 8004182:	f002 fc55 	bl	8006a30 <strlen>
 8004186:	4649      	mov	r1, r9
 8004188:	4602      	mov	r2, r0
 800418a:	f04f 33ff 	mov.w	r3, #4294967295
 800418e:	4620      	mov	r0, r4
 8004190:	f7ff ff6e 	bl	8004070 <chOQWriteTimeout>
 sdWrite(&SD3, &sep,strlen(1));
 8004194:	2001      	movs	r0, #1
 8004196:	f002 fc4b 	bl	8006a30 <strlen>
 800419a:	4639      	mov	r1, r7
 800419c:	4602      	mov	r2, r0
 800419e:	f04f 33ff 	mov.w	r3, #4294967295
 80041a2:	4620      	mov	r0, r4
 80041a4:	f7ff ff64 	bl	8004070 <chOQWriteTimeout>
 sdWrite(&SD3, &dot,strlen(dot));
 80041a8:	4640      	mov	r0, r8
 80041aa:	f002 fc41 	bl	8006a30 <strlen>
 80041ae:	4641      	mov	r1, r8
 80041b0:	4602      	mov	r2, r0
 80041b2:	f04f 33ff 	mov.w	r3, #4294967295
 80041b6:	4620      	mov	r0, r4
 80041b8:	f7ff ff5a 	bl	8004070 <chOQWriteTimeout>
 sdWrite(&SD3, &sep,strlen(1));
 80041bc:	2001      	movs	r0, #1
 80041be:	f002 fc37 	bl	8006a30 <strlen>
 80041c2:	4639      	mov	r1, r7
 80041c4:	4602      	mov	r2, r0
 80041c6:	f04f 33ff 	mov.w	r3, #4294967295
 80041ca:	4620      	mov	r0, r4
 80041cc:	f7ff ff50 	bl	8004070 <chOQWriteTimeout>
 sdWrite(&SD3, &password,strlen(password));
 80041d0:	4830      	ldr	r0, [pc, #192]	; (8004294 <cmd_wifi.16079+0x194>)
 80041d2:	f002 fc2d 	bl	8006a30 <strlen>
 80041d6:	492f      	ldr	r1, [pc, #188]	; (8004294 <cmd_wifi.16079+0x194>)
 80041d8:	4602      	mov	r2, r0
 80041da:	f04f 33ff 	mov.w	r3, #4294967295
 80041de:	4620      	mov	r0, r4
 80041e0:	f7ff ff46 	bl	8004070 <chOQWriteTimeout>
 sdWrite(&SD3, &sep,strlen(1));
 80041e4:	2001      	movs	r0, #1
 80041e6:	f002 fc23 	bl	8006a30 <strlen>
 80041ea:	4639      	mov	r1, r7
 80041ec:	4602      	mov	r2, r0
 80041ee:	f04f 33ff 	mov.w	r3, #4294967295
 80041f2:	4620      	mov	r0, r4
 80041f4:	f7ff ff3c 	bl	8004070 <chOQWriteTimeout>
 sdWrite(&SD3, &end,strlen(end));
 80041f8:	4827      	ldr	r0, [pc, #156]	; (8004298 <cmd_wifi.16079+0x198>)
 chThdSleepMilliseconds(10000);

 sdWrite(&SD3, &comATCIPMUX,strlen(comATCIPMUX));
 chThdSleepMilliseconds(10000);

 sdWrite(&SD3, &comATCIPSERVER,strlen(comATCIPSERVER));
 80041fa:	4f28      	ldr	r7, [pc, #160]	; (800429c <cmd_wifi.16079+0x19c>)
 sdWrite(&SD3, &sep,strlen(1));
 sdWrite(&SD3, &dot,strlen(dot));
 sdWrite(&SD3, &sep,strlen(1));
 sdWrite(&SD3, &password,strlen(password));
 sdWrite(&SD3, &sep,strlen(1));
 sdWrite(&SD3, &end,strlen(end));
 80041fc:	f002 fc18 	bl	8006a30 <strlen>
 8004200:	4925      	ldr	r1, [pc, #148]	; (8004298 <cmd_wifi.16079+0x198>)
 8004202:	4602      	mov	r2, r0
 8004204:	f04f 33ff 	mov.w	r3, #4294967295
 8004208:	4620      	mov	r0, r4
 800420a:	f7ff ff31 	bl	8004070 <chOQWriteTimeout>
  chThdSleepMilliseconds(10000);
 800420e:	4628      	mov	r0, r5
 8004210:	f7ff fe0e 	bl	8003e30 <chThdSleep>


 sdWrite(&SD3, &comATCWMODE,strlen(comATCWMODE));
 8004214:	4630      	mov	r0, r6
 8004216:	f002 fc0b 	bl	8006a30 <strlen>
 800421a:	4631      	mov	r1, r6
 800421c:	4602      	mov	r2, r0
 800421e:	f04f 33ff 	mov.w	r3, #4294967295
 8004222:	4620      	mov	r0, r4
 8004224:	f7ff ff24 	bl	8004070 <chOQWriteTimeout>
 chThdSleepMilliseconds(10000);
 8004228:	4628      	mov	r0, r5
 800422a:	f7ff fe01 	bl	8003e30 <chThdSleep>

 sdWrite(&SD3, &comATCIPMUX,strlen(comATCIPMUX));
 800422e:	481c      	ldr	r0, [pc, #112]	; (80042a0 <cmd_wifi.16079+0x1a0>)
 chThdSleepMilliseconds(10000);

 sdWrite(&SD3, &comATCIPSERVER,strlen(comATCIPSERVER));
 chThdSleepMilliseconds(10000);

 sdWrite(&SD3, &comAtCIFSR,strlen(comAtCIFSR));
 8004230:	4e1c      	ldr	r6, [pc, #112]	; (80042a4 <cmd_wifi.16079+0x1a4>)


 sdWrite(&SD3, &comATCWMODE,strlen(comATCWMODE));
 chThdSleepMilliseconds(10000);

 sdWrite(&SD3, &comATCIPMUX,strlen(comATCIPMUX));
 8004232:	f002 fbfd 	bl	8006a30 <strlen>
 8004236:	491a      	ldr	r1, [pc, #104]	; (80042a0 <cmd_wifi.16079+0x1a0>)
 8004238:	4602      	mov	r2, r0
 800423a:	f04f 33ff 	mov.w	r3, #4294967295
 800423e:	4620      	mov	r0, r4
 8004240:	f7ff ff16 	bl	8004070 <chOQWriteTimeout>
 chThdSleepMilliseconds(10000);
 8004244:	4628      	mov	r0, r5
 8004246:	f7ff fdf3 	bl	8003e30 <chThdSleep>

 sdWrite(&SD3, &comATCIPSERVER,strlen(comATCIPSERVER));
 800424a:	4638      	mov	r0, r7
 800424c:	f002 fbf0 	bl	8006a30 <strlen>
 8004250:	4639      	mov	r1, r7
 8004252:	4602      	mov	r2, r0
 8004254:	f04f 33ff 	mov.w	r3, #4294967295
 8004258:	4620      	mov	r0, r4
 800425a:	f7ff ff09 	bl	8004070 <chOQWriteTimeout>
 chThdSleepMilliseconds(10000);
 800425e:	4628      	mov	r0, r5
 8004260:	f7ff fde6 	bl	8003e30 <chThdSleep>

 sdWrite(&SD3, &comAtCIFSR,strlen(comAtCIFSR));
 8004264:	4630      	mov	r0, r6
 8004266:	f002 fbe3 	bl	8006a30 <strlen>
 800426a:	4631      	mov	r1, r6
 800426c:	4602      	mov	r2, r0
 800426e:	f04f 33ff 	mov.w	r3, #4294967295
 8004272:	4620      	mov	r0, r4
               //chSequentialStreamRead(serial,&u,3);
                wifiInit();
            return 1;
    }
}
 8004274:	b001      	add	sp, #4
 8004276:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800427a:	f7ff bef9 	b.w	8004070 <chOQWriteTimeout>
 800427e:	bf00      	nop
 8004280:	08006ff0 	.word	0x08006ff0
 8004284:	20001398 	.word	0x20001398
 8004288:	000186a0 	.word	0x000186a0
 800428c:	20000860 	.word	0x20000860
 8004290:	20000884 	.word	0x20000884
 8004294:	20000888 	.word	0x20000888
 8004298:	20000850 	.word	0x20000850
 800429c:	20000870 	.word	0x20000870
 80042a0:	20000818 	.word	0x20000818
 80042a4:	20000854 	.word	0x20000854
 80042a8:	20000898 	.word	0x20000898
 80042ac:	200008a0 	.word	0x200008a0
 80042b0:	200008ac 	.word	0x200008ac
 80042b4:	200008c0 	.word	0x200008c0
	...

080042c0 <writet.8157>:
  return iqGetTimeout(&((SerialUSBDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp, n, timeout);
 80042c0:	3030      	adds	r0, #48	; 0x30
 80042c2:	f7ff bed5 	b.w	8004070 <chOQWriteTimeout>
 80042c6:	bf00      	nop
	...

080042d0 <write.8163>:
 * Interface implementation.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialUSBDriver *)ip)->oqueue, bp,
 80042d0:	3030      	adds	r0, #48	; 0x30
 80042d2:	f04f 33ff 	mov.w	r3, #4294967295
 80042d6:	f7ff becb 	b.w	8004070 <chOQWriteTimeout>
 80042da:	bf00      	nop
 80042dc:	0000      	movs	r0, r0
	...

080042e0 <writet.7896>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 80042e0:	3030      	adds	r0, #48	; 0x30
 80042e2:	f7ff bec5 	b.w	8004070 <chOQWriteTimeout>
 80042e6:	bf00      	nop
	...

080042f0 <write.7902>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 80042f0:	3030      	adds	r0, #48	; 0x30
 80042f2:	f04f 33ff 	mov.w	r3, #4294967295
 80042f6:	f7ff bebb 	b.w	8004070 <chOQWriteTimeout>
 80042fa:	bf00      	nop
 80042fc:	0000      	movs	r0, r0
	...

08004300 <CanWriteDATA>:
  /*.btr = */ CAN_BTR_SJW(0) | CAN_BTR_TS2(1)  | CAN_BTR_LBKM
  | CAN_BTR_TS1(8) | CAN_BTR_BRP(6)
};


void CanWriteDATA(uint32_t TO, uint32_t PID,  uint32_t PDATA ){
 8004300:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

// config write mode
 SERVICES_ID_S = 0x2;
 DATA_LENGHT_RW_S = 7;

 DEVICE_ID_S = TO;
 8004302:	4f0d      	ldr	r7, [pc, #52]	; (8004338 <CanWriteDATA+0x38>)
 id_S = PID;
 STdata_S = PDATA;
 8004304:	4e0d      	ldr	r6, [pc, #52]	; (800433c <CanWriteDATA+0x3c>)


void CanWriteDATA(uint32_t TO, uint32_t PID,  uint32_t PDATA ){

// config write mode
 SERVICES_ID_S = 0x2;
 8004306:	4d0e      	ldr	r5, [pc, #56]	; (8004340 <CanWriteDATA+0x40>)
 DATA_LENGHT_RW_S = 7;
 8004308:	4c0e      	ldr	r4, [pc, #56]	; (8004344 <CanWriteDATA+0x44>)

 DEVICE_ID_S = TO;
 id_S = PID;
 800430a:	4b0f      	ldr	r3, [pc, #60]	; (8004348 <CanWriteDATA+0x48>)

// config write mode
 SERVICES_ID_S = 0x2;
 DATA_LENGHT_RW_S = 7;

 DEVICE_ID_S = TO;
 800430c:	6038      	str	r0, [r7, #0]


void CanWriteDATA(uint32_t TO, uint32_t PID,  uint32_t PDATA ){

// config write mode
 SERVICES_ID_S = 0x2;
 800430e:	2702      	movs	r7, #2
 DATA_LENGHT_RW_S = 7;
 8004310:	2007      	movs	r0, #7

 DEVICE_ID_S = TO;
 id_S = PID;
 8004312:	8019      	strh	r1, [r3, #0]
 STdata_S = PDATA;
 8004314:	6032      	str	r2, [r6, #0]


void CanWriteDATA(uint32_t TO, uint32_t PID,  uint32_t PDATA ){

// config write mode
 SERVICES_ID_S = 0x2;
 8004316:	602f      	str	r7, [r5, #0]
 DATA_LENGHT_RW_S = 7;
 8004318:	6020      	str	r0, [r4, #0]
 800431a:	2320      	movs	r3, #32
 800431c:	f383 8811 	msr	BASEPRI, r3
 id_S = PID;
 STdata_S = PDATA;

 // run send can
 chSysLock();
    thread_t *ntp = tp_S;
 8004320:	4b0a      	ldr	r3, [pc, #40]	; (800434c <CanWriteDATA+0x4c>)
 8004322:	6818      	ldr	r0, [r3, #0]
    if(ntp){
 8004324:	b118      	cbz	r0, 800432e <CanWriteDATA+0x2e>
        tp_S = NULL;
 8004326:	2200      	movs	r2, #0
 8004328:	601a      	str	r2, [r3, #0]
        chSchWakeupS(ntp, MSG_OK);
 800432a:	f001 f831 	bl	8005390 <chSchWakeupS.constprop.49>
 800432e:	2300      	movs	r3, #0
 8004330:	f383 8811 	msr	BASEPRI, r3
 8004334:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004336:	bf00      	nop
 8004338:	20000810 	.word	0x20000810
 800433c:	20000d38 	.word	0x20000d38
 8004340:	20000d00 	.word	0x20000d00
 8004344:	20000808 	.word	0x20000808
 8004348:	20000d0c 	.word	0x20000d0c
 800434c:	20000d10 	.word	0x20000d10

08004350 <chThdCreateStatic.constprop.48>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8004350:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8004354:	4607      	mov	r7, r0
                            tprio_t prio, tfunc_t pf, void *arg) {
  thread_t *tp;
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 8004356:	f100 0544 	add.w	r5, r0, #68	; 0x44
 800435a:	4604      	mov	r4, r0
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 800435c:	26ff      	movs	r6, #255	; 0xff
 800435e:	f804 6b01 	strb.w	r6, [r4], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8004362:	42a5      	cmp	r5, r4
 8004364:	d1fb      	bne.n	800435e <chThdCreateStatic.constprop.48+0xe>
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 8004366:	1878      	adds	r0, r7, r1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8004368:	4285      	cmp	r5, r0
 800436a:	d204      	bcs.n	8004376 <chThdCreateStatic.constprop.48+0x26>
    *startp++ = v;
 800436c:	2455      	movs	r4, #85	; 0x55
 800436e:	f805 4b01 	strb.w	r4, [r5], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 8004372:	4285      	cmp	r5, r0
 8004374:	d1fb      	bne.n	800436e <chThdCreateStatic.constprop.48+0x1e>
 8004376:	2020      	movs	r0, #32
 8004378:	f380 8811 	msr	BASEPRI, r0
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800437c:	4d18      	ldr	r5, [pc, #96]	; (80043e0 <chThdCreateStatic.constprop.48+0x90>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800437e:	f8df 9064 	ldr.w	r9, [pc, #100]	; 80043e4 <chThdCreateStatic.constprop.48+0x94>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8004382:	696e      	ldr	r6, [r5, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8004384:	f1a1 0024 	sub.w	r0, r1, #36	; 0x24
 8004388:	1839      	adds	r1, r7, r0
 800438a:	2400      	movs	r4, #0
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 800438c:	f107 0e28 	add.w	lr, r7, #40	; 0x28
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8004390:	f107 0c24 	add.w	ip, r7, #36	; 0x24
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8004394:	f04f 0a02 	mov.w	sl, #2
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8004398:	f04f 0801 	mov.w	r8, #1

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800439c:	60f9      	str	r1, [r7, #12]
 800439e:	503b      	str	r3, [r7, r0]
 80043a0:	604c      	str	r4, [r1, #4]
 80043a2:	f8c1 9020 	str.w	r9, [r1, #32]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 80043a6:	4638      	mov	r0, r7
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80043a8:	60ba      	str	r2, [r7, #8]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80043aa:	613d      	str	r5, [r7, #16]
 80043ac:	617e      	str	r6, [r7, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80043ae:	777c      	strb	r4, [r7, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80043b0:	63fa      	str	r2, [r7, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 80043b2:	63bc      	str	r4, [r7, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 80043b4:	637c      	str	r4, [r7, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80043b6:	61bc      	str	r4, [r7, #24]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80043b8:	f887 a01c 	strb.w	sl, [r7, #28]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80043bc:	f887 801e 	strb.w	r8, [r7, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80043c0:	6137      	str	r7, [r6, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80043c2:	f8c7 c024 	str.w	ip, [r7, #36]	; 0x24
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80043c6:	f8c7 e028 	str.w	lr, [r7, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 80043ca:	f8c7 e02c 	str.w	lr, [r7, #44]	; 0x2c
 80043ce:	616f      	str	r7, [r5, #20]
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 80043d0:	f000 ffde 	bl	8005390 <chSchWakeupS.constprop.49>
 80043d4:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();

  return tp;
}
 80043d8:	4638      	mov	r0, r7
 80043da:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80043de:	bf00      	nop
 80043e0:	200016a8 	.word	0x200016a8
 80043e4:	08000291 	.word	0x08000291
	...

080043f0 <usbTermInit>:
    (void) chp;
}
void usbTermInit(void)
{

  chThdCreateStatic(waThreadusbterm, sizeof(waThreadusbterm), NORMALPRIO, Threadusbterm, NULL);
 80043f0:	4803      	ldr	r0, [pc, #12]	; (8004400 <usbTermInit+0x10>)
 80043f2:	4b04      	ldr	r3, [pc, #16]	; (8004404 <usbTermInit+0x14>)
 80043f4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80043f8:	2240      	movs	r2, #64	; 0x40
 80043fa:	f7ff bfa9 	b.w	8004350 <chThdCreateStatic.constprop.48>
 80043fe:	bf00      	nop
 8004400:	20002288 	.word	0x20002288
 8004404:	08006471 	.word	0x08006471
	...

08004410 <_usb_ep0out.4379>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8004410:	b538      	push	{r3, r4, r5, lr}

  (void)ep;
  switch (usbp->ep0state) {
 8004412:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 8004416:	2b06      	cmp	r3, #6
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8004418:	4604      	mov	r4, r0
 800441a:	d80a      	bhi.n	8004432 <_usb_ep0out.4379+0x22>
 800441c:	2201      	movs	r2, #1
 800441e:	fa02 f303 	lsl.w	r3, r2, r3
 8004422:	f013 0f67 	tst.w	r3, #103	; 0x67
 8004426:	d111      	bne.n	800444c <_usb_ep0out.4379+0x3c>
 8004428:	f013 0508 	ands.w	r5, r3, #8
 800442c:	d102      	bne.n	8004434 <_usb_ep0out.4379+0x24>
 800442e:	06db      	lsls	r3, r3, #27
 8004430:	d422      	bmi.n	8004478 <_usb_ep0out.4379+0x68>
 8004432:	bd38      	pop	{r3, r4, r5, pc}
    return;
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeI(usbp, 0) != 0U) {
 8004434:	68c3      	ldr	r3, [r0, #12]
 8004436:	699b      	ldr	r3, [r3, #24]
 8004438:	689b      	ldr	r3, [r3, #8]
 800443a:	2b00      	cmp	r3, #0
 800443c:	d1f9      	bne.n	8004432 <_usb_ep0out.4379+0x22>
      break;
    }
#endif
    if (usbp->ep0endcb != NULL) {
 800443e:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004440:	b103      	cbz	r3, 8004444 <_usb_ep0out.4379+0x34>
      usbp->ep0endcb(usbp);
 8004442:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8004444:	2300      	movs	r3, #0
 8004446:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 800444a:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 800444c:	6d03      	ldr	r3, [r0, #80]	; 0x50
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800444e:	6842      	ldr	r2, [r0, #4]
 8004450:	f8d3 1900 	ldr.w	r1, [r3, #2304]	; 0x900
 8004454:	6812      	ldr	r2, [r2, #0]
 8004456:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 800445a:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800445e:	f8d3 1b00 	ldr.w	r1, [r3, #2816]	; 0xb00
 8004462:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8004466:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
 800446a:	b10a      	cbz	r2, 8004470 <_usb_ep0out.4379+0x60>
 800446c:	2105      	movs	r1, #5
 800446e:	4790      	blx	r2
    usbp->ep0state = USB_EP0_ERROR;
 8004470:	2306      	movs	r3, #6
 8004472:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8004476:	bd38      	pop	{r3, r4, r5, pc}
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8004478:	68c3      	ldr	r3, [r0, #12]
 800447a:	695b      	ldr	r3, [r3, #20]

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 800447c:	2205      	movs	r2, #5
 800447e:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8004482:	4629      	mov	r1, r5
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8004484:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 8004486:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 8004488:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 800448a:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 800448c:	f001 fa40 	bl	8005910 <usb_lld_prepare_transmit>
 8004490:	2320      	movs	r3, #32
 8004492:	f383 8811 	msr	BASEPRI, r3
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    usbPrepareTransmit(usbp, 0, NULL, 0);
    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, 0);
 8004496:	4620      	mov	r0, r4
 8004498:	4629      	mov	r1, r5
 800449a:	f001 f9f9 	bl	8005890 <usbStartTransmitI>
 800449e:	f385 8811 	msr	BASEPRI, r5
 80044a2:	bd38      	pop	{r3, r4, r5, pc}
	...

080044b0 <otg_epin_handler.10088.4413>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 80044b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  stm32_otg_t *otgp = usbp->otg;
 80044b4:	6d05      	ldr	r5, [r0, #80]	; 0x50
  uint32_t epint = otgp->ie[ep].DIEPINT;
 80044b6:	eb05 1341 	add.w	r3, r5, r1, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 80044ba:	4606      	mov	r6, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->ie[ep].DIEPINT;
 80044bc:	f8d3 4908 	ldr.w	r4, [r3, #2312]	; 0x908

  otgp->ie[ep].DIEPINT = epint;
 80044c0:	f8c3 4908 	str.w	r4, [r3, #2312]	; 0x908

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 80044c4:	07e3      	lsls	r3, r4, #31
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 80044c6:	460f      	mov	r7, r1
  otgp->ie[ep].DIEPINT = epint;

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 80044c8:	d503      	bpl.n	80044d2 <otg_epin_handler.10088.4413+0x22>
 80044ca:	f8d5 3810 	ldr.w	r3, [r5, #2064]	; 0x810
 80044ce:	07da      	lsls	r2, r3, #31
 80044d0:	d40a      	bmi.n	80044e8 <otg_epin_handler.10088.4413+0x38>
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 80044d2:	0623      	lsls	r3, r4, #24
 80044d4:	d506      	bpl.n	80044e4 <otg_epin_handler.10088.4413+0x34>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 80044d6:	2201      	movs	r2, #1
 80044d8:	f8d5 3834 	ldr.w	r3, [r5, #2100]	; 0x834
 80044dc:	fa02 f707 	lsl.w	r7, r2, r7
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 80044e0:	421f      	tst	r7, r3
 80044e2:	d12b      	bne.n	800453c <otg_epin_handler.10088.4413+0x8c>
 80044e4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 80044e8:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 80044ec:	68da      	ldr	r2, [r3, #12]
 80044ee:	6953      	ldr	r3, [r2, #20]

    if (isp->txsize < isp->totsize) {
 80044f0:	f8d3 e004 	ldr.w	lr, [r3, #4]
 80044f4:	f8d3 c010 	ldr.w	ip, [r3, #16]
 80044f8:	45e6      	cmp	lr, ip
 80044fa:	d238      	bcs.n	800456e <otg_epin_handler.10088.4413+0xbe>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 80044fc:	ebce 020c 	rsb	r2, lr, ip
      isp->txcnt  = 0;
 8004500:	f04f 0800 	mov.w	r8, #0

    if (isp->txsize < isp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 8004504:	605a      	str	r2, [r3, #4]
      isp->txcnt  = 0;
 8004506:	f8c3 8008 	str.w	r8, [r3, #8]
      usb_lld_prepare_transmit(usbp, ep);
 800450a:	f001 fa01 	bl	8005910 <usb_lld_prepare_transmit>
 800450e:	2320      	movs	r3, #32
 8004510:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 8004514:	6d33      	ldr	r3, [r6, #80]	; 0x50
 8004516:	eb03 1247 	add.w	r2, r3, r7, lsl #5
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800451a:	2001      	movs	r0, #1
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800451c:	f8d2 1900 	ldr.w	r1, [r2, #2304]	; 0x900
 8004520:	f041 4104 	orr.w	r1, r1, #2214592512	; 0x84000000
 8004524:	f8c2 1900 	str.w	r1, [r2, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 8004528:	f8d3 1834 	ldr.w	r1, [r3, #2100]	; 0x834
 800452c:	fa00 f207 	lsl.w	r2, r0, r7
 8004530:	430a      	orrs	r2, r1
 8004532:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
 8004536:	f388 8811 	msr	BASEPRI, r8
 800453a:	e7ca      	b.n	80044d2 <otg_epin_handler.10088.4413+0x22>
 800453c:	2320      	movs	r3, #32
 800453e:	f383 8811 	msr	BASEPRI, r3
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 8004542:	6df2      	ldr	r2, [r6, #92]	; 0x5c
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8004544:	f8d5 1834 	ldr.w	r1, [r5, #2100]	; 0x834
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8004548:	6e33      	ldr	r3, [r6, #96]	; 0x60
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 800454a:	433a      	orrs	r2, r7
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800454c:	ea21 0707 	bic.w	r7, r1, r7
  }
  if ((epint & DIEPINT_TXFE) &&
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
    usbp->txpending |= (1 << ep);
 8004550:	65f2      	str	r2, [r6, #92]	; 0x5c
    otgp->DIEPEMPMSK &= ~(1 << ep);
 8004552:	f8c5 7834 	str.w	r7, [r5, #2100]	; 0x834
 8004556:	b12b      	cbz	r3, 8004564 <otg_epin_handler.10088.4413+0xb4>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8004558:	2200      	movs	r2, #0
 800455a:	6632      	str	r2, [r6, #96]	; 0x60
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 800455c:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 800455e:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8004560:	f7fd f91e 	bl	80017a0 <chSchReadyI>
 8004564:	2300      	movs	r3, #0
 8004566:	f383 8811 	msr	BASEPRI, r3
 800456a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      usb_lld_start_in(usbp, ep);
      osalSysUnlockFromISR();
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 800456e:	f8b0 e008 	ldrh.w	lr, [r0, #8]
 8004572:	6893      	ldr	r3, [r2, #8]
 8004574:	f04f 0c01 	mov.w	ip, #1
 8004578:	fa0c f201 	lsl.w	r2, ip, r1
 800457c:	ea2e 0202 	bic.w	r2, lr, r2
 8004580:	8102      	strh	r2, [r0, #8]
 8004582:	4798      	blx	r3
 8004584:	e7a5      	b.n	80044d2 <otg_epin_handler.10088.4413+0x22>
 8004586:	bf00      	nop
	...

08004590 <Vector14C.4393>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8004590:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8004594:	4e83      	ldr	r6, [pc, #524]	; (80047a4 <Vector14C.4393+0x214>)
 8004596:	6d34      	ldr	r4, [r6, #80]	; 0x50
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 8004598:	6963      	ldr	r3, [r4, #20]
  sts &= otgp->GINTMSK;
 800459a:	69a5      	ldr	r5, [r4, #24]
 800459c:	401d      	ands	r5, r3
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 800459e:	04ea      	lsls	r2, r5, #19
  stm32_otg_t *otgp = usbp->otg;
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
  sts &= otgp->GINTMSK;
  otgp->GINTSTS = sts;
 80045a0:	6165      	str	r5, [r4, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 80045a2:	d436      	bmi.n	8004612 <Vector14C.4393+0x82>
    _usb_reset(usbp);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 80045a4:	04ab      	lsls	r3, r5, #18
    (void)otgp->DSTS;
 80045a6:	bf48      	it	mi
 80045a8:	f8d4 3808 	ldrmi.w	r3, [r4, #2056]	; 0x808
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 80045ac:	072f      	lsls	r7, r5, #28
 80045ae:	d504      	bpl.n	80045ba <Vector14C.4393+0x2a>
    _usb_isr_invoke_sof_cb(usbp);
 80045b0:	6873      	ldr	r3, [r6, #4]
 80045b2:	68db      	ldr	r3, [r3, #12]
 80045b4:	b10b      	cbz	r3, 80045ba <Vector14C.4393+0x2a>
 80045b6:	487b      	ldr	r0, [pc, #492]	; (80047a4 <Vector14C.4393+0x214>)
 80045b8:	4798      	blx	r3
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 80045ba:	06e8      	lsls	r0, r5, #27
 80045bc:	f100 80ac 	bmi.w	8004718 <Vector14C.4393+0x188>
    osalSysUnlockFromISR();
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_IEPINT) {
 80045c0:	0369      	lsls	r1, r5, #13
    osalThreadResumeI(&usbp->wait, MSG_OK);
    osalSysUnlockFromISR();
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 80045c2:	f8d4 4818 	ldr.w	r4, [r4, #2072]	; 0x818
  if (sts & GINTSTS_IEPINT) {
 80045c6:	d50b      	bpl.n	80045e0 <Vector14C.4393+0x50>
    if (src & (1 << 0))
 80045c8:	07e2      	lsls	r2, r4, #31
 80045ca:	f100 80d0 	bmi.w	800476e <Vector14C.4393+0x1de>
      otg_epin_handler(usbp, 0);
    if (src & (1 << 1))
 80045ce:	07a3      	lsls	r3, r4, #30
 80045d0:	f100 80d4 	bmi.w	800477c <Vector14C.4393+0x1ec>
      otg_epin_handler(usbp, 1);
    if (src & (1 << 2))
 80045d4:	0767      	lsls	r7, r4, #29
 80045d6:	f100 80d8 	bmi.w	800478a <Vector14C.4393+0x1fa>
      otg_epin_handler(usbp, 2);
    if (src & (1 << 3))
 80045da:	0726      	lsls	r6, r4, #28
 80045dc:	f100 80dc 	bmi.w	8004798 <Vector14C.4393+0x208>
      otg_epin_handler(usbp, 4);
    if (src & (1 << 5))
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
 80045e0:	032d      	lsls	r5, r5, #12
 80045e2:	d50a      	bpl.n	80045fa <Vector14C.4393+0x6a>
    if (src & (1 << 16))
 80045e4:	03e0      	lsls	r0, r4, #15
 80045e6:	f100 80b3 	bmi.w	8004750 <Vector14C.4393+0x1c0>
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
 80045ea:	03a1      	lsls	r1, r4, #14
 80045ec:	f100 80b7 	bmi.w	800475e <Vector14C.4393+0x1ce>
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
 80045f0:	0362      	lsls	r2, r4, #13
 80045f2:	f100 80a5 	bmi.w	8004740 <Vector14C.4393+0x1b0>
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
 80045f6:	0323      	lsls	r3, r4, #12
 80045f8:	d403      	bmi.n	8004602 <Vector14C.4393+0x72>
  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
}
 80045fa:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 80045fe:	f7fc be97 	b.w	8001330 <_port_irq_epilogue>
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
    if (src & (1 << 19))
      otg_epout_handler(usbp, 3);
 8004602:	4868      	ldr	r0, [pc, #416]	; (80047a4 <Vector14C.4393+0x214>)
 8004604:	2103      	movs	r1, #3
 8004606:	f001 fa13 	bl	8005a30 <otg_epout_handler.10080>
  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
}
 800460a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);

  OSAL_IRQ_EPILOGUE();
 800460e:	f7fc be8f 	b.w	8001330 <_port_irq_epilogue>

  /* State transition.*/
  usbp->state         = USB_READY;

  /* Resetting internal state.*/
  usbp->status        = 0;
 8004612:	2300      	movs	r3, #0
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8004614:	2102      	movs	r1, #2
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8004616:	2220      	movs	r2, #32

  /* Resetting internal state.*/
  usbp->status        = 0;
 8004618:	f8a6 304c 	strh.w	r3, [r6, #76]	; 0x4c
  usbp->address       = 0;
 800461c:	f886 304e 	strb.w	r3, [r6, #78]	; 0x4e
  usbp->configuration = 0;
 8004620:	f886 304f 	strb.w	r3, [r6, #79]	; 0x4f
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 8004624:	60f3      	str	r3, [r6, #12]
 8004626:	6133      	str	r3, [r6, #16]
 8004628:	6173      	str	r3, [r6, #20]
 800462a:	61b3      	str	r3, [r6, #24]
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800462c:	f886 3034 	strb.w	r3, [r6, #52]	; 0x34

  /* Resetting internal state.*/
  usbp->status        = 0;
  usbp->address       = 0;
  usbp->configuration = 0;
  usbp->transmitting  = 0;
 8004630:	8133      	strh	r3, [r6, #8]
  usbp->receiving     = 0;
 8004632:	8173      	strh	r3, [r6, #10]
 */
void _usb_reset(USBDriver *usbp) {
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8004634:	7031      	strb	r1, [r6, #0]
 8004636:	6122      	str	r2, [r4, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8004638:	6922      	ldr	r2, [r4, #16]
 800463a:	f012 0820 	ands.w	r8, r2, #32
 800463e:	d1fb      	bne.n	8004638 <Vector14C.4393+0xa8>
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 8004640:	200c      	movs	r0, #12
 8004642:	f7fd fd05 	bl	8002050 <chSysPolledDelayX>
 8004646:	f8d6 e054 	ldr.w	lr, [r6, #84]	; 0x54
 800464a:	f8de 7008 	ldr.w	r7, [lr, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800464e:	4642      	mov	r2, r8
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 8004650:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
    otgp->ie[i].DIEPINT = 0xFF;
 8004654:	21ff      	movs	r1, #255	; 0xff
 8004656:	eb04 1342 	add.w	r3, r4, r2, lsl #5

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800465a:	3201      	adds	r2, #1
 800465c:	42ba      	cmp	r2, r7
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 800465e:	f8c3 0900 	str.w	r0, [r3, #2304]	; 0x900
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 8004662:	f8c3 0b00 	str.w	r0, [r3, #2816]	; 0xb00
    otgp->ie[i].DIEPINT = 0xFF;
 8004666:	f8c3 1908 	str.w	r1, [r3, #2312]	; 0x908
    otgp->oe[i].DOEPINT = 0xFF;
 800466a:	f8c3 1b08 	str.w	r1, [r3, #2824]	; 0xb08

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800466e:	d9f2      	bls.n	8004656 <Vector14C.4393+0xc6>
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8004670:	f8de 3000 	ldr.w	r3, [lr]
 8004674:	65b3      	str	r3, [r6, #88]	; 0x58
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8004676:	6d33      	ldr	r3, [r6, #80]	; 0x50

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 8004678:	f8de 1000 	ldr.w	r1, [lr]
    otgp->ie[i].DIEPINT = 0xFF;
    otgp->oe[i].DOEPINT = 0xFF;
  }

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DAINT = 0xFFFFFFFF;
 800467c:	f04f 37ff 	mov.w	r7, #4294967295
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 8004680:	f04f 1001 	mov.w	r0, #65537	; 0x10001
}

static void otg_rxfifo_flush(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8004684:	2210      	movs	r2, #16
    otgp->ie[i].DIEPINT = 0xFF;
    otgp->oe[i].DOEPINT = 0xFF;
  }

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DAINT = 0xFFFFFFFF;
 8004686:	f8c4 7818 	str.w	r7, [r4, #2072]	; 0x818
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800468a:	f8c4 081c 	str.w	r0, [r4, #2076]	; 0x81c

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 800468e:	6261      	str	r1, [r4, #36]	; 0x24
}

static void otg_rxfifo_flush(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 8004690:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 8004692:	6919      	ldr	r1, [r3, #16]
 8004694:	f011 0710 	ands.w	r7, r1, #16
 8004698:	d1fb      	bne.n	8004692 <Vector14C.4393+0x102>
 800469a:	200c      	movs	r0, #12
 800469c:	f7fd fcd8 	bl	8002050 <chSysPolledDelayX>
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 80046a0:	f8d4 1800 	ldr.w	r1, [r4, #2048]	; 0x800

  /* Low level reset.*/
  usb_lld_reset(usbp);

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 80046a4:	6873      	ldr	r3, [r6, #4]
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 80046a6:	6db0      	ldr	r0, [r6, #88]	; 0x58
 80046a8:	f8d3 c000 	ldr.w	ip, [r3]
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 80046ac:	4a3e      	ldr	r2, [pc, #248]	; (80047a8 <Vector14C.4393+0x218>)
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 80046ae:	f8df 90fc 	ldr.w	r9, [pc, #252]	; 80047ac <Vector14C.4393+0x21c>
 80046b2:	f8df 80f0 	ldr.w	r8, [pc, #240]	; 80047a4 <Vector14C.4393+0x214>
  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
  otg_rxfifo_flush(usbp);

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 80046b6:	f421 63fe 	bic.w	r3, r1, #2032	; 0x7f0
 80046ba:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 80046be:	69a3      	ldr	r3, [r4, #24]
 80046c0:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 80046c4:	2109      	movs	r1, #9
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 80046c6:	f100 0a10 	add.w	sl, r0, #16

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 80046ca:	f043 0310 	orr.w	r3, r3, #16
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 80046ce:	f440 1080 	orr.w	r0, r0, #1048576	; 0x100000

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 80046d2:	61a3      	str	r3, [r4, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 80046d4:	f8c4 1810 	str.w	r1, [r4, #2064]	; 0x810
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 80046d8:	f8c6 a058 	str.w	sl, [r6, #88]	; 0x58
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 80046dc:	f8c4 1814 	str.w	r1, [r4, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 80046e0:	f8c6 900c 	str.w	r9, [r6, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 80046e4:	f8c4 7b10 	str.w	r7, [r4, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 80046e8:	f8c4 2b00 	str.w	r2, [r4, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 80046ec:	f8c4 7910 	str.w	r7, [r4, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 80046f0:	f8c4 2900 	str.w	r2, [r4, #2304]	; 0x900
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 80046f4:	62a0      	str	r0, [r4, #40]	; 0x28
 80046f6:	f1bc 0f00 	cmp.w	ip, #0
 80046fa:	f43f af53 	beq.w	80045a4 <Vector14C.4393+0x14>
 80046fe:	4640      	mov	r0, r8
 8004700:	4639      	mov	r1, r7
 8004702:	47e0      	blx	ip
  otgp->GINTSTS = sts;

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
    _usb_reset(usbp);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8004704:	f8d8 3004 	ldr.w	r3, [r8, #4]
 8004708:	681b      	ldr	r3, [r3, #0]
 800470a:	2b00      	cmp	r3, #0
 800470c:	f43f af4a 	beq.w	80045a4 <Vector14C.4393+0x14>
 8004710:	4640      	mov	r0, r8
 8004712:	4639      	mov	r1, r7
 8004714:	4798      	blx	r3
 8004716:	e745      	b.n	80045a4 <Vector14C.4393+0x14>
 8004718:	2320      	movs	r3, #32
 800471a:	f383 8811 	msr	BASEPRI, r3
  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 800471e:	69a2      	ldr	r2, [r4, #24]
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8004720:	6e33      	ldr	r3, [r6, #96]	; 0x60
 8004722:	4920      	ldr	r1, [pc, #128]	; (80047a4 <Vector14C.4393+0x214>)
 8004724:	f022 0210 	bic.w	r2, r2, #16
 8004728:	61a2      	str	r2, [r4, #24]
 800472a:	b12b      	cbz	r3, 8004738 <Vector14C.4393+0x1a8>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 800472c:	2200      	movs	r2, #0
 800472e:	660a      	str	r2, [r1, #96]	; 0x60
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8004730:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8004732:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8004734:	f7fd f834 	bl	80017a0 <chSchReadyI>
 8004738:	2300      	movs	r3, #0
 800473a:	f383 8811 	msr	BASEPRI, r3
 800473e:	e73f      	b.n	80045c0 <Vector14C.4393+0x30>
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
    if (src & (1 << 17))
      otg_epout_handler(usbp, 1);
    if (src & (1 << 18))
      otg_epout_handler(usbp, 2);
 8004740:	4818      	ldr	r0, [pc, #96]	; (80047a4 <Vector14C.4393+0x214>)
 8004742:	2102      	movs	r1, #2
 8004744:	f001 f974 	bl	8005a30 <otg_epout_handler.10080>
    if (src & (1 << 19))
 8004748:	0323      	lsls	r3, r4, #12
 800474a:	f57f af56 	bpl.w	80045fa <Vector14C.4393+0x6a>
 800474e:	e758      	b.n	8004602 <Vector14C.4393+0x72>
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
    if (src & (1 << 16))
      otg_epout_handler(usbp, 0);
 8004750:	2100      	movs	r1, #0
 8004752:	4814      	ldr	r0, [pc, #80]	; (80047a4 <Vector14C.4393+0x214>)
 8004754:	f001 f96c 	bl	8005a30 <otg_epout_handler.10080>
    if (src & (1 << 17))
 8004758:	03a1      	lsls	r1, r4, #14
 800475a:	f57f af49 	bpl.w	80045f0 <Vector14C.4393+0x60>
      otg_epout_handler(usbp, 1);
 800475e:	4811      	ldr	r0, [pc, #68]	; (80047a4 <Vector14C.4393+0x214>)
 8004760:	2101      	movs	r1, #1
 8004762:	f001 f965 	bl	8005a30 <otg_epout_handler.10080>
    if (src & (1 << 18))
 8004766:	0362      	lsls	r2, r4, #13
 8004768:	f57f af45 	bpl.w	80045f6 <Vector14C.4393+0x66>
 800476c:	e7e8      	b.n	8004740 <Vector14C.4393+0x1b0>

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
  if (sts & GINTSTS_IEPINT) {
    if (src & (1 << 0))
      otg_epin_handler(usbp, 0);
 800476e:	480d      	ldr	r0, [pc, #52]	; (80047a4 <Vector14C.4393+0x214>)
 8004770:	2100      	movs	r1, #0
 8004772:	f7ff fe9d 	bl	80044b0 <otg_epin_handler.10088.4413>
    if (src & (1 << 1))
 8004776:	07a3      	lsls	r3, r4, #30
 8004778:	f57f af2c 	bpl.w	80045d4 <Vector14C.4393+0x44>
      otg_epin_handler(usbp, 1);
 800477c:	4809      	ldr	r0, [pc, #36]	; (80047a4 <Vector14C.4393+0x214>)
 800477e:	2101      	movs	r1, #1
 8004780:	f7ff fe96 	bl	80044b0 <otg_epin_handler.10088.4413>
    if (src & (1 << 2))
 8004784:	0767      	lsls	r7, r4, #29
 8004786:	f57f af28 	bpl.w	80045da <Vector14C.4393+0x4a>
      otg_epin_handler(usbp, 2);
 800478a:	4806      	ldr	r0, [pc, #24]	; (80047a4 <Vector14C.4393+0x214>)
 800478c:	2102      	movs	r1, #2
 800478e:	f7ff fe8f 	bl	80044b0 <otg_epin_handler.10088.4413>
    if (src & (1 << 3))
 8004792:	0726      	lsls	r6, r4, #28
 8004794:	f57f af24 	bpl.w	80045e0 <Vector14C.4393+0x50>
      otg_epin_handler(usbp, 3);
 8004798:	4802      	ldr	r0, [pc, #8]	; (80047a4 <Vector14C.4393+0x214>)
 800479a:	2103      	movs	r1, #3
 800479c:	f7ff fe88 	bl	80044b0 <otg_epin_handler.10088.4413>
 80047a0:	e71e      	b.n	80045e0 <Vector14C.4393+0x50>
 80047a2:	bf00      	nop
 80047a4:	200011b8 	.word	0x200011b8
 80047a8:	10008040 	.word	0x10008040
 80047ac:	08007020 	.word	0x08007020

080047b0 <VectorDC.4447>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 80047b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 80047b4:	4d6d      	ldr	r5, [pc, #436]	; (800496c <VectorDC.4447+0x1bc>)
 80047b6:	f8d5 6094 	ldr.w	r6, [r5, #148]	; 0x94
  uint16_t cr1 = u->CR1;
 80047ba:	f8d6 900c 	ldr.w	r9, [r6, #12]
  uint16_t sr = u->SR;
 80047be:	6833      	ldr	r3, [r6, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 80047c0:	05d8      	lsls	r0, r3, #23
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
 80047c2:	b083      	sub	sp, #12
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 80047c4:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 80047c6:	f100 8083 	bmi.w	80048d0 <VectorDC.4447+0x120>
 80047ca:	2320      	movs	r3, #32
 80047cc:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80047d0:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80047d4:	d048      	beq.n	8004868 <VectorDC.4447+0xb8>
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80047d6:	4f65      	ldr	r7, [pc, #404]	; (800496c <VectorDC.4447+0x1bc>)
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 80047d8:	f107 080c 	add.w	r8, r7, #12
 80047dc:	e007      	b.n	80047ee <VectorDC.4447+0x3e>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 80047de:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 80047e0:	6873      	ldr	r3, [r6, #4]
    if (sr & USART_SR_RXNE)
 80047e2:	d41d      	bmi.n	8004820 <VectorDC.4447+0x70>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 80047e4:	6834      	ldr	r4, [r6, #0]
 80047e6:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 80047e8:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 80047ec:	d03c      	beq.n	8004868 <VectorDC.4447+0xb8>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80047ee:	0721      	lsls	r1, r4, #28
 80047f0:	d0f5      	beq.n	80047de <VectorDC.4447+0x2e>
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] sr        USART SR register value
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;
 80047f2:	f014 0f08 	tst.w	r4, #8
 80047f6:	bf14      	ite	ne
 80047f8:	2180      	movne	r1, #128	; 0x80
 80047fa:	2100      	moveq	r1, #0

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
  if (sr & USART_SR_PE)
 80047fc:	07e2      	lsls	r2, r4, #31
    sts |= SD_PARITY_ERROR;
 80047fe:	bf48      	it	mi
 8004800:	f041 0120 	orrmi.w	r1, r1, #32
  if (sr & USART_SR_FE)
 8004804:	07a3      	lsls	r3, r4, #30
    sts |= SD_FRAMING_ERROR;
 8004806:	bf48      	it	mi
 8004808:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (sr & USART_SR_NE)
 800480c:	0760      	lsls	r0, r4, #29
    sts |= SD_NOISE_ERROR;
 800480e:	bf48      	it	mi
 8004810:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8004814:	4856      	ldr	r0, [pc, #344]	; (8004970 <VectorDC.4447+0x1c0>)
 8004816:	f7fc ffdb 	bl	80017d0 <chEvtBroadcastFlagsI>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 800481a:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 800481c:	6873      	ldr	r3, [r6, #4]
    if (sr & USART_SR_RXNE)
 800481e:	d5e1      	bpl.n	80047e4 <VectorDC.4447+0x34>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8004820:	696a      	ldr	r2, [r5, #20]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8004822:	2a00      	cmp	r2, #0
 8004824:	d042      	beq.n	80048ac <VectorDC.4447+0xfc>
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8004826:	6a2a      	ldr	r2, [r5, #32]
 8004828:	6a69      	ldr	r1, [r5, #36]	; 0x24
 800482a:	428a      	cmp	r2, r1
 800482c:	d048      	beq.n	80048c0 <VectorDC.4447+0x110>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 800482e:	6968      	ldr	r0, [r5, #20]
  *iqp->q_wrptr++ = b;
 8004830:	1c51      	adds	r1, r2, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8004832:	3001      	adds	r0, #1
  *iqp->q_wrptr++ = b;
 8004834:	6229      	str	r1, [r5, #32]

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8004836:	6168      	str	r0, [r5, #20]
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8004838:	7013      	strb	r3, [r2, #0]
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top) {
 800483a:	6a2a      	ldr	r2, [r5, #32]
 800483c:	69eb      	ldr	r3, [r5, #28]
 800483e:	429a      	cmp	r2, r3
 8004840:	d301      	bcc.n	8004846 <VectorDC.4447+0x96>
    iqp->q_wrptr = iqp->q_buffer;
 8004842:	69bb      	ldr	r3, [r7, #24]
 8004844:	623b      	str	r3, [r7, #32]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8004846:	68eb      	ldr	r3, [r5, #12]
 8004848:	4543      	cmp	r3, r8
 800484a:	d0cb      	beq.n	80047e4 <VectorDC.4447+0x34>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 800484c:	681a      	ldr	r2, [r3, #0]
 800484e:	60fa      	str	r2, [r7, #12]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8004850:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8004852:	f8c2 8004 	str.w	r8, [r2, #4]
  (void) chSchReadyI(tp);
 8004856:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8004858:	6219      	str	r1, [r3, #32]
  (void) chSchReadyI(tp);
 800485a:	f7fc ffa1 	bl	80017a0 <chSchReadyI>
    if (sr & USART_SR_RXNE)
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 800485e:	6834      	ldr	r4, [r6, #0]
 8004860:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8004862:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8004866:	d1c2      	bne.n	80047ee <VectorDC.4447+0x3e>
 8004868:	2300      	movs	r3, #0
 800486a:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 800486e:	f019 0f80 	tst.w	r9, #128	; 0x80
 8004872:	d001      	beq.n	8004878 <VectorDC.4447+0xc8>
 8004874:	0622      	lsls	r2, r4, #24
 8004876:	d43a      	bmi.n	80048ee <VectorDC.4447+0x13e>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8004878:	0663      	lsls	r3, r4, #25
 800487a:	d512      	bpl.n	80048a2 <VectorDC.4447+0xf2>
 800487c:	2320      	movs	r3, #32
 800487e:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8004882:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8004884:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8004886:	4839      	ldr	r0, [pc, #228]	; (800496c <VectorDC.4447+0x1bc>)
 8004888:	429a      	cmp	r2, r3
 800488a:	d057      	beq.n	800493c <VectorDC.4447+0x18c>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800488c:	f64f 73bf 	movw	r3, #65471	; 0xffbf
 8004890:	ea09 0303 	and.w	r3, r9, r3
    u->SR = ~USART_SR_TC;
 8004894:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8004898:	60f3      	str	r3, [r6, #12]
 800489a:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 800489c:	6032      	str	r2, [r6, #0]
 800489e:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);

  OSAL_IRQ_EPILOGUE();
}
 80048a2:	b003      	add	sp, #12
 80048a4:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD3);

  OSAL_IRQ_EPILOGUE();
 80048a8:	f7fc bd42 	b.w	8001330 <_port_irq_epilogue>
 80048ac:	2104      	movs	r1, #4
 80048ae:	4830      	ldr	r0, [pc, #192]	; (8004970 <VectorDC.4447+0x1c0>)
 80048b0:	9301      	str	r3, [sp, #4]
 80048b2:	f7fc ff8d 	bl	80017d0 <chEvtBroadcastFlagsI>
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80048b6:	6a2a      	ldr	r2, [r5, #32]
 80048b8:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80048ba:	9b01      	ldr	r3, [sp, #4]
 80048bc:	428a      	cmp	r2, r1
 80048be:	d1b6      	bne.n	800482e <VectorDC.4447+0x7e>
 80048c0:	6979      	ldr	r1, [r7, #20]
 80048c2:	2900      	cmp	r1, #0
 80048c4:	d0b3      	beq.n	800482e <VectorDC.4447+0x7e>
 80048c6:	482a      	ldr	r0, [pc, #168]	; (8004970 <VectorDC.4447+0x1c0>)
 80048c8:	2180      	movs	r1, #128	; 0x80
 80048ca:	f7fc ff81 	bl	80017d0 <chEvtBroadcastFlagsI>
 80048ce:	e789      	b.n	80047e4 <VectorDC.4447+0x34>
 80048d0:	2320      	movs	r3, #32
 80048d2:	f383 8811 	msr	BASEPRI, r3
 80048d6:	f44f 7100 	mov.w	r1, #512	; 0x200
 80048da:	1d28      	adds	r0, r5, #4
 80048dc:	f7fc ff78 	bl	80017d0 <chEvtBroadcastFlagsI>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 80048e0:	f46f 7380 	mvn.w	r3, #256	; 0x100
 80048e4:	6033      	str	r3, [r6, #0]
 80048e6:	2300      	movs	r3, #0
 80048e8:	f383 8811 	msr	BASEPRI, r3
 80048ec:	e76d      	b.n	80047ca <VectorDC.4447+0x1a>
 80048ee:	2320      	movs	r3, #32
 80048f0:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 80048f4:	6cab      	ldr	r3, [r5, #72]	; 0x48
 80048f6:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 80048f8:	481c      	ldr	r0, [pc, #112]	; (800496c <VectorDC.4447+0x1bc>)
 80048fa:	429a      	cmp	r2, r3
 80048fc:	d026      	beq.n	800494c <VectorDC.4447+0x19c>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 80048fe:	6ba8      	ldr	r0, [r5, #56]	; 0x38
 8004900:	491a      	ldr	r1, [pc, #104]	; (800496c <VectorDC.4447+0x1bc>)
  b = *oqp->q_rdptr++;
 8004902:	1c5a      	adds	r2, r3, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8004904:	3001      	adds	r0, #1
 8004906:	63a8      	str	r0, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8004908:	64aa      	str	r2, [r5, #72]	; 0x48
 800490a:	781f      	ldrb	r7, [r3, #0]
  if (oqp->q_rdptr >= oqp->q_top) {
 800490c:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 800490e:	429a      	cmp	r2, r3
 8004910:	d301      	bcc.n	8004916 <VectorDC.4447+0x166>
    oqp->q_rdptr = oqp->q_buffer;
 8004912:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8004914:	648b      	str	r3, [r1, #72]	; 0x48
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8004916:	4915      	ldr	r1, [pc, #84]	; (800496c <VectorDC.4447+0x1bc>)
 8004918:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 800491a:	f101 0230 	add.w	r2, r1, #48	; 0x30
 800491e:	4293      	cmp	r3, r2
 8004920:	d007      	beq.n	8004932 <VectorDC.4447+0x182>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8004922:	6818      	ldr	r0, [r3, #0]
 8004924:	6308      	str	r0, [r1, #48]	; 0x30

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8004926:	2100      	movs	r1, #0
  tqp->p_next->p_prev = (thread_t *)tqp;
 8004928:	6042      	str	r2, [r0, #4]
  (void) chSchReadyI(tp);
 800492a:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 800492c:	6219      	str	r1, [r3, #32]
  (void) chSchReadyI(tp);
 800492e:	f7fc ff37 	bl	80017a0 <chSchReadyI>
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 8004932:	6077      	str	r7, [r6, #4]
 8004934:	2300      	movs	r3, #0
 8004936:	f383 8811 	msr	BASEPRI, r3
 800493a:	e79d      	b.n	8004878 <VectorDC.4447+0xc8>
 800493c:	6b83      	ldr	r3, [r0, #56]	; 0x38
 800493e:	2b00      	cmp	r3, #0
 8004940:	d0a4      	beq.n	800488c <VectorDC.4447+0xdc>
 8004942:	3004      	adds	r0, #4
 8004944:	2110      	movs	r1, #16
 8004946:	f7fc ff43 	bl	80017d0 <chEvtBroadcastFlagsI>
 800494a:	e79f      	b.n	800488c <VectorDC.4447+0xdc>
 800494c:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800494e:	2a00      	cmp	r2, #0
 8004950:	d0d5      	beq.n	80048fe <VectorDC.4447+0x14e>
 8004952:	3004      	adds	r0, #4
 8004954:	2108      	movs	r1, #8
 8004956:	f7fc ff3b 	bl	80017d0 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800495a:	f64f 733f 	movw	r3, #65343	; 0xff3f
 800495e:	ea09 0303 	and.w	r3, r9, r3
 8004962:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8004966:	60f3      	str	r3, [r6, #12]
 8004968:	e7e4      	b.n	8004934 <VectorDC.4447+0x184>
 800496a:	bf00      	nop
 800496c:	20001368 	.word	0x20001368
 8004970:	2000136c 	.word	0x2000136c
	...

08004980 <usb_event.14033>:
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
  extern SerialUSBDriver SDU1;

  switch (event) {
 8004980:	2902      	cmp	r1, #2
};

/*
 * Handles the USB driver global events.
 */
static void usb_event(USBDriver *usbp, usbevent_t event) {
 8004982:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004984:	460d      	mov	r5, r1
 8004986:	4606      	mov	r6, r0
  extern SerialUSBDriver SDU1;

  switch (event) {
 8004988:	d143      	bne.n	8004a12 <usb_event.14033+0x92>
 800498a:	2320      	movs	r3, #32
 800498c:	f383 8811 	msr	BASEPRI, r3
 * @param[in] sdup      pointer to a @p SerialUSBDriver object
 *
 * @iclass
 */
void sduConfigureHookI(SerialUSBDriver *sdup) {
  USBDriver *usbp = sdup->config->usbp;
 8004990:	4c20      	ldr	r4, [pc, #128]	; (8004a14 <usb_event.14033+0x94>)
    chSysLockFromISR();

    /* Enables the endpoints specified into the configuration.
       Note, this callback is invoked from an ISR so I-Class functions
       must be used.*/
    usbInitEndpointI(usbp, USBD1_DATA_REQUEST_EP, &ep1config);
 8004992:	4a21      	ldr	r2, [pc, #132]	; (8004a18 <usb_event.14033+0x98>)
 8004994:	2101      	movs	r1, #1
 8004996:	f001 f893 	bl	8005ac0 <usbInitEndpointI>
    usbInitEndpointI(usbp, USBD1_INTERRUPT_REQUEST_EP, &ep2config);
 800499a:	4630      	mov	r0, r6
 800499c:	4629      	mov	r1, r5
 800499e:	4a1f      	ldr	r2, [pc, #124]	; (8004a1c <usb_event.14033+0x9c>)
 80049a0:	f001 f88e 	bl	8005ac0 <usbInitEndpointI>
 80049a4:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 */
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 80049a8:	69a3      	ldr	r3, [r4, #24]
 80049aa:	6816      	ldr	r6, [r2, #0]
 80049ac:	6263      	str	r3, [r4, #36]	; 0x24
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 80049ae:	f104 070c 	add.w	r7, r4, #12

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 80049b2:	2500      	movs	r5, #0
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 80049b4:	4638      	mov	r0, r7
void chIQResetI(input_queue_t *iqp) {

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
  iqp->q_wrptr = iqp->q_buffer;
 80049b6:	6223      	str	r3, [r4, #32]
  iqp->q_counter = 0;
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 80049b8:	f06f 0101 	mvn.w	r1, #1

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
  iqp->q_wrptr = iqp->q_buffer;
  iqp->q_counter = 0;
 80049bc:	6165      	str	r5, [r4, #20]
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 80049be:	f7fd f89f 	bl	8001b00 <chThdDequeueAllI>
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 80049c2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 80049c4:	6c22      	ldr	r2, [r4, #64]	; 0x40
 */
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 80049c6:	64a3      	str	r3, [r4, #72]	; 0x48
  oqp->q_wrptr = oqp->q_buffer;
  oqp->q_counter = chQSizeX(oqp);
 80049c8:	1ad2      	subs	r2, r2, r3
void chOQResetI(output_queue_t *oqp) {

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
  oqp->q_wrptr = oqp->q_buffer;
 80049ca:	6463      	str	r3, [r4, #68]	; 0x44
  oqp->q_counter = chQSizeX(oqp);
 80049cc:	63a2      	str	r2, [r4, #56]	; 0x38
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 80049ce:	f104 0030 	add.w	r0, r4, #48	; 0x30
 80049d2:	f06f 0101 	mvn.w	r1, #1
 80049d6:	f7fd f893 	bl	8001b00 <chThdDequeueAllI>
 80049da:	1d20      	adds	r0, r4, #4
 80049dc:	2101      	movs	r1, #1
 80049de:	f7fc fef7 	bl	80017d0 <chEvtBroadcastFlagsI>
  oqResetI(&sdup->oqueue);
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
 80049e2:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 80049e6:	7959      	ldrb	r1, [r3, #5]
 80049e8:	eb06 0381 	add.w	r3, r6, r1, lsl #2
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
 80049ec:	2001      	movs	r0, #1
 80049ee:	68da      	ldr	r2, [r3, #12]
 *
 * @special
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80049f0:	6993      	ldr	r3, [r2, #24]
  iqResetI(&sdup->iqueue);
  oqResetI(&sdup->oqueue);
  chnAddFlagsI(sdup, CHN_CONNECTED);

  /* Starts the first OUT transaction immediately.*/
  usbPrepareQueuedReceive(usbp, sdup->config->bulk_out, &sdup->iqueue,
 80049f2:	8a52      	ldrh	r2, [r2, #18]

  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
 80049f4:	605a      	str	r2, [r3, #4]
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
 80049f6:	60df      	str	r7, [r3, #12]
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 80049f8:	609d      	str	r5, [r3, #8]
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
 80049fa:	7018      	strb	r0, [r3, #0]
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 80049fc:	4630      	mov	r0, r6
 80049fe:	f000 ffaf 	bl	8005960 <usb_lld_prepare_receive>
                          usbp->epc[sdup->config->bulk_out]->out_maxsize);
  (void) usbStartReceiveI(usbp, sdup->config->bulk_out);
 8004a02:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 8004a06:	4630      	mov	r0, r6
 8004a08:	7959      	ldrb	r1, [r3, #5]
 8004a0a:	f000 ff61 	bl	80058d0 <usbStartReceiveI>
 8004a0e:	f385 8811 	msr	BASEPRI, r5
 8004a12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8004a14:	20002418 	.word	0x20002418
 8004a18:	080076c0 	.word	0x080076c0
 8004a1c:	080070e0 	.word	0x080070e0

08004a20 <_usb_ep0in.4443>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8004a20:	b538      	push	{r3, r4, r5, lr}
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8004a22:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8004a26:	4604      	mov	r4, r0
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 8004a28:	2b06      	cmp	r3, #6
 8004a2a:	d81a      	bhi.n	8004a62 <_usb_ep0in.4443+0x42>
 8004a2c:	e8df f003 	tbb	[pc, r3]
 8004a30:	04213904 	.word	0x04213904
 8004a34:	1a04      	.short	0x1a04
 8004a36:	04          	.byte	0x04
 8004a37:	00          	.byte	0x00
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8004a38:	6d03      	ldr	r3, [r0, #80]	; 0x50
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
    usb_lld_stall_out(usbp, 0);
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8004a3a:	6842      	ldr	r2, [r0, #4]
 8004a3c:	f8d3 1900 	ldr.w	r1, [r3, #2304]	; 0x900
 8004a40:	6812      	ldr	r2, [r2, #0]
 8004a42:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8004a46:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8004a4a:	f8d3 1b00 	ldr.w	r1, [r3, #2816]	; 0xb00
 8004a4e:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8004a52:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
 8004a56:	b10a      	cbz	r2, 8004a5c <_usb_ep0in.4443+0x3c>
 8004a58:	2105      	movs	r1, #5
 8004a5a:	4790      	blx	r2
    usbp->ep0state = USB_EP0_ERROR;
 8004a5c:	2306      	movs	r3, #6
 8004a5e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8004a62:	bd38      	pop	{r3, r4, r5, pc}
    usb_lld_end_setup(usbp, ep);
#endif
    return;
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8004a64:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8004a66:	b103      	cbz	r3, 8004a6a <_usb_ep0in.4443+0x4a>
      usbp->ep0endcb(usbp);
 8004a68:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8004a6a:	2300      	movs	r3, #0
 8004a6c:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8004a70:	bd38      	pop	{r3, r4, r5, pc}
 8004a72:	68c3      	ldr	r3, [r0, #12]
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8004a74:	699b      	ldr	r3, [r3, #24]

  osp->rxqueued           = false;
 8004a76:	2500      	movs	r5, #0
      return;
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 8004a78:	2203      	movs	r2, #3
 8004a7a:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 8004a7e:	4629      	mov	r1, r5
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 8004a80:	701d      	strb	r5, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
 8004a82:	60dd      	str	r5, [r3, #12]
  osp->rxsize             = n;
 8004a84:	605d      	str	r5, [r3, #4]
  osp->rxcnt              = 0;
 8004a86:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 8004a88:	4620      	mov	r0, r4
 8004a8a:	f000 ff69 	bl	8005960 <usb_lld_prepare_receive>
 8004a8e:	2320      	movs	r3, #32
 8004a90:	f383 8811 	msr	BASEPRI, r3
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    usbPrepareReceive(usbp, 0, NULL, 0);
    osalSysLockFromISR();
    (void) usbStartReceiveI(usbp, 0);
 8004a94:	4620      	mov	r0, r4
 8004a96:	4629      	mov	r1, r5
 8004a98:	f000 ff1a 	bl	80058d0 <usbStartReceiveI>
 8004a9c:	f385 8811 	msr	BASEPRI, r5
 8004aa0:	bd38      	pop	{r3, r4, r5, pc}

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 8004aa2:	f890 104b 	ldrb.w	r1, [r0, #75]	; 0x4b
 8004aa6:	f890 304a 	ldrb.w	r3, [r0, #74]	; 0x4a
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8004aaa:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 8004aac:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8004ab0:	4293      	cmp	r3, r2
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8004ab2:	68c3      	ldr	r3, [r0, #12]
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8004ab4:	d9de      	bls.n	8004a74 <_usb_ep0in.4443+0x54>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 8004ab6:	8a19      	ldrh	r1, [r3, #16]
 8004ab8:	fbb2 f5f1 	udiv	r5, r2, r1
 8004abc:	fb01 2515 	mls	r5, r1, r5, r2
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 8004ac0:	2d00      	cmp	r5, #0
 8004ac2:	d1d7      	bne.n	8004a74 <_usb_ep0in.4443+0x54>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8004ac4:	695b      	ldr	r3, [r3, #20]
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8004ac6:	4629      	mov	r1, r5
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8004ac8:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 8004aca:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 8004acc:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 8004ace:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 8004ad0:	f000 ff1e 	bl	8005910 <usb_lld_prepare_transmit>
 8004ad4:	2320      	movs	r3, #32
 8004ad6:	f383 8811 	msr	BASEPRI, r3
       transmitted.*/
    if ((usbp->ep0n < max) &&
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      usbPrepareTransmit(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
 8004ada:	4620      	mov	r0, r4
 8004adc:	4629      	mov	r1, r5
 8004ade:	f000 fed7 	bl	8005890 <usbStartTransmitI>
 8004ae2:	f385 8811 	msr	BASEPRI, r5
      osalSysUnlockFromISR();
      usbp->ep0state = USB_EP0_WAITING_TX0;
 8004ae6:	2302      	movs	r3, #2
 8004ae8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8004aec:	bd38      	pop	{r3, r4, r5, pc}
 8004aee:	bf00      	nop

08004af0 <cmd_mem.16145>:

static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
  size_t n, size;

  (void)argv;
  if (argc > 0) {
 8004af0:	2900      	cmp	r1, #0
*/
float f = 1;                                // temoprary float
uint32_t DEVICE_ID = 101 ;
uint16_t id;                // can parameter id varaibale

static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004af2:	b570      	push	{r4, r5, r6, lr}
 8004af4:	4606      	mov	r6, r0
  size_t n, size;

  (void)argv;
  if (argc > 0) {
 8004af6:	dd04      	ble.n	8004b02 <cmd_mem.16145+0x12>
    chprintf(chp, "Usage: mem\r\n");
 8004af8:	4919      	ldr	r1, [pc, #100]	; (8004b60 <cmd_mem.16145+0x70>)
  }
  n = chHeapStatus(NULL, &size);
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u\r\n", n);
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
}
 8004afa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
  size_t n, size;

  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: mem\r\n");
 8004afe:	f000 bc9f 	b.w	8005440 <chprintf.16065>
 8004b02:	2320      	movs	r3, #32
 8004b04:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chMtxLock(mutex_t *mp) {

  chSysLock();
  chMtxLockS(mp);
 8004b08:	4816      	ldr	r0, [pc, #88]	; (8004b64 <cmd_mem.16145+0x74>)
 8004b0a:	f7fc ff09 	bl	8001920 <chMtxLockS>
 8004b0e:	2400      	movs	r4, #0
 8004b10:	f384 8811 	msr	BASEPRI, r4

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8004b14:	4b14      	ldr	r3, [pc, #80]	; (8004b68 <cmd_mem.16145+0x78>)
 8004b16:	689b      	ldr	r3, [r3, #8]
 8004b18:	b1f3      	cbz	r3, 8004b58 <cmd_mem.16145+0x68>
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  sz = 0;
 8004b1a:	4625      	mov	r5, r4
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
    sz += qp->h.u.next->h.size;
 8004b1c:	685a      	ldr	r2, [r3, #4]

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8004b1e:	681b      	ldr	r3, [r3, #0]
    sz += qp->h.u.next->h.size;
    n++;
 8004b20:	3401      	adds	r4, #1
  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
    sz += qp->h.u.next->h.size;
 8004b22:	4415      	add	r5, r2

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8004b24:	2b00      	cmp	r3, #0
 8004b26:	d1f9      	bne.n	8004b1c <cmd_mem.16145+0x2c>
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
    *sizep = sz;
  }
  H_UNLOCK(heapp);
 8004b28:	480e      	ldr	r0, [pc, #56]	; (8004b64 <cmd_mem.16145+0x74>)
 8004b2a:	f7fc fec1 	bl	80018b0 <chMtxUnlock>
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
 8004b2e:	4a0f      	ldr	r2, [pc, #60]	; (8004b6c <cmd_mem.16145+0x7c>)
 8004b30:	4b0f      	ldr	r3, [pc, #60]	; (8004b70 <cmd_mem.16145+0x80>)
 8004b32:	6812      	ldr	r2, [r2, #0]
 8004b34:	681b      	ldr	r3, [r3, #0]
    return;
  }
  n = chHeapStatus(NULL, &size);
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
 8004b36:	490f      	ldr	r1, [pc, #60]	; (8004b74 <cmd_mem.16145+0x84>)
 8004b38:	1ad2      	subs	r2, r2, r3
 8004b3a:	4630      	mov	r0, r6
 8004b3c:	f000 fc80 	bl	8005440 <chprintf.16065>
  chprintf(chp, "heap fragments   : %u\r\n", n);
 8004b40:	4622      	mov	r2, r4
 8004b42:	4630      	mov	r0, r6
 8004b44:	490c      	ldr	r1, [pc, #48]	; (8004b78 <cmd_mem.16145+0x88>)
 8004b46:	f000 fc7b 	bl	8005440 <chprintf.16065>
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
 8004b4a:	4630      	mov	r0, r6
 8004b4c:	462a      	mov	r2, r5
 8004b4e:	490b      	ldr	r1, [pc, #44]	; (8004b7c <cmd_mem.16145+0x8c>)
}
 8004b50:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return;
  }
  n = chHeapStatus(NULL, &size);
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u\r\n", n);
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
 8004b54:	f000 bc74 	b.w	8005440 <chprintf.16065>
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  sz = 0;
  n = 0;
 8004b58:	461c      	mov	r4, r3
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  sz = 0;
 8004b5a:	461d      	mov	r5, r3
 8004b5c:	e7e4      	b.n	8004b28 <cmd_mem.16145+0x38>
 8004b5e:	bf00      	nop
 8004b60:	08007050 	.word	0x08007050
 8004b64:	20001d90 	.word	0x20001d90
 8004b68:	20001d80 	.word	0x20001d80
 8004b6c:	20001f68 	.word	0x20001f68
 8004b70:	20001d78 	.word	0x20001d78
 8004b74:	08007060 	.word	0x08007060
 8004b78:	08007080 	.word	0x08007080
 8004b7c:	08007098 	.word	0x08007098

08004b80 <_usb_ep0setup.4505>:
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 8004b80:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8004b84:	b570      	push	{r4, r5, r6, lr}
 8004b86:	68cb      	ldr	r3, [r1, #12]
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8004b88:	2200      	movs	r2, #0
 8004b8a:	6a1b      	ldr	r3, [r3, #32]
 8004b8c:	f880 2034 	strb.w	r2, [r0, #52]	; 0x34
 8004b90:	6819      	ldr	r1, [r3, #0]
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8004b92:	6842      	ldr	r2, [r0, #4]
 8004b94:	685b      	ldr	r3, [r3, #4]
 8004b96:	6483      	str	r3, [r0, #72]	; 0x48
 8004b98:	6441      	str	r1, [r0, #68]	; 0x44
 8004b9a:	6893      	ldr	r3, [r2, #8]
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8004b9c:	4604      	mov	r4, r0
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8004b9e:	b35b      	cbz	r3, 8004bf8 <_usb_ep0setup.4505+0x78>
      !(usbp->config->requests_hook_cb(usbp))) {
 8004ba0:	4798      	blx	r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8004ba2:	b348      	cbz	r0, 8004bf8 <_usb_ep0setup.4505+0x78>
 8004ba4:	6be5      	ldr	r5, [r4, #60]	; 0x3c
 8004ba6:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 8004baa:	f894 104b 	ldrb.w	r1, [r4, #75]	; 0x4b
 8004bae:	f894 204a 	ldrb.w	r2, [r4, #74]	; 0x4a
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 8004bb2:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 8004bb6:	42aa      	cmp	r2, r5
    usbp->ep0n = max;
 8004bb8:	bf3c      	itt	cc
 8004bba:	63e2      	strcc	r2, [r4, #60]	; 0x3c
 8004bbc:	4615      	movcc	r5, r2
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8004bbe:	f013 0f80 	tst.w	r3, #128	; 0x80
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8004bc2:	68e3      	ldr	r3, [r4, #12]
  max = (size_t)get_hword(&usbp->setup[6]);
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 8004bc4:	f040 8093 	bne.w	8004cee <_usb_ep0setup.4505+0x16e>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 8004bc8:	2d00      	cmp	r5, #0
 8004bca:	d178      	bne.n	8004cbe <_usb_ep0setup.4505+0x13e>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8004bcc:	695b      	ldr	r3, [r3, #20]
      osalSysUnlockFromISR();
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8004bce:	2205      	movs	r2, #5
 8004bd0:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8004bd4:	4620      	mov	r0, r4
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8004bd6:	701d      	strb	r5, [r3, #0]
  isp->mode.linear.txbuf  = buf;
 8004bd8:	60dd      	str	r5, [r3, #12]
  isp->txsize             = n;
 8004bda:	605d      	str	r5, [r3, #4]
  isp->txcnt              = 0;
 8004bdc:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 8004bde:	4629      	mov	r1, r5
 8004be0:	f000 fe96 	bl	8005910 <usb_lld_prepare_transmit>
 8004be4:	2320      	movs	r3, #32
 8004be6:	f383 8811 	msr	BASEPRI, r3
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      usbPrepareTransmit(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
 8004bea:	4620      	mov	r0, r4
 8004bec:	4629      	mov	r1, r5
 8004bee:	f000 fe4f 	bl	8005890 <usbStartTransmitI>
 8004bf2:	f385 8811 	msr	BASEPRI, r5
 8004bf6:	bd70      	pop	{r4, r5, r6, pc}
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8004bf8:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004bfc:	f013 0660 	ands.w	r6, r3, #96	; 0x60
 8004c00:	d016      	beq.n	8004c30 <_usb_ep0setup.4505+0xb0>
 8004c02:	6d22      	ldr	r2, [r4, #80]	; 0x50
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8004c04:	f8d2 1900 	ldr.w	r1, [r2, #2304]	; 0x900
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
      usb_lld_stall_out(usbp, 0);
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8004c08:	6863      	ldr	r3, [r4, #4]
 8004c0a:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8004c0e:	f8c2 1900 	str.w	r1, [r2, #2304]	; 0x900
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8004c12:	f8d2 1b00 	ldr.w	r1, [r2, #2816]	; 0xb00
 8004c16:	681b      	ldr	r3, [r3, #0]
 8004c18:	f441 1100 	orr.w	r1, r1, #2097152	; 0x200000
 8004c1c:	f8c2 1b00 	str.w	r1, [r2, #2816]	; 0xb00
 8004c20:	b113      	cbz	r3, 8004c28 <_usb_ep0setup.4505+0xa8>
 8004c22:	4620      	mov	r0, r4
 8004c24:	2105      	movs	r1, #5
 8004c26:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 8004c28:	2306      	movs	r3, #6
 8004c2a:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
 8004c2e:	bd70      	pop	{r4, r5, r6, pc}
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 8004c30:	f894 5045 	ldrb.w	r5, [r4, #69]	; 0x45
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8004c34:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
 8004c38:	ea42 2505 	orr.w	r5, r2, r5, lsl #8
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8004c3c:	f5b5 7f40 	cmp.w	r5, #768	; 0x300
 8004c40:	f000 8119 	beq.w	8004e76 <_usb_ep0setup.4505+0x2f6>
 8004c44:	d917      	bls.n	8004c76 <_usb_ep0setup.4505+0xf6>
 8004c46:	f5b5 6fc0 	cmp.w	r5, #1536	; 0x600
 8004c4a:	f000 80f1 	beq.w	8004e30 <_usb_ep0setup.4505+0x2b0>
 8004c4e:	d97d      	bls.n	8004d4c <_usb_ep0setup.4505+0x1cc>
 8004c50:	f5b5 6f10 	cmp.w	r5, #2304	; 0x900
 8004c54:	f000 808d 	beq.w	8004d72 <_usb_ep0setup.4505+0x1f2>
 8004c58:	f640 4202 	movw	r2, #3074	; 0xc02
 8004c5c:	4295      	cmp	r5, r2
 8004c5e:	f000 8103 	beq.w	8004e68 <_usb_ep0setup.4505+0x2e8>
 8004c62:	f5b5 6f00 	cmp.w	r5, #2048	; 0x800
 8004c66:	d1cc      	bne.n	8004c02 <_usb_ep0setup.4505+0x82>
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 8004c68:	f104 024f 	add.w	r2, r4, #79	; 0x4f
 8004c6c:	2501      	movs	r5, #1
 8004c6e:	6426      	str	r6, [r4, #64]	; 0x40
 8004c70:	63a2      	str	r2, [r4, #56]	; 0x38
 8004c72:	63e5      	str	r5, [r4, #60]	; 0x3c
 8004c74:	e799      	b.n	8004baa <_usb_ep0setup.4505+0x2a>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8004c76:	2d02      	cmp	r5, #2
 8004c78:	f000 80c1 	beq.w	8004dfe <_usb_ep0setup.4505+0x27e>
 8004c7c:	f240 80b5 	bls.w	8004dea <_usb_ep0setup.4505+0x26a>
 8004c80:	f5b5 7f80 	cmp.w	r5, #256	; 0x100
 8004c84:	f000 80a1 	beq.w	8004dca <_usb_ep0setup.4505+0x24a>
 8004c88:	f5b5 7f81 	cmp.w	r5, #258	; 0x102
 8004c8c:	d1b9      	bne.n	8004c02 <_usb_ep0setup.4505+0x82>
        return false;
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8004c8e:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8004c92:	2a00      	cmp	r2, #0
 8004c94:	d1b5      	bne.n	8004c02 <_usb_ep0setup.4505+0x82>
      return false;
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8004c96:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 8004c9a:	f012 010f 	ands.w	r1, r2, #15
 8004c9e:	d063      	beq.n	8004d68 <_usb_ep0setup.4505+0x1e8>
 8004ca0:	6d23      	ldr	r3, [r4, #80]	; 0x50
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8004ca2:	0612      	lsls	r2, r2, #24
 8004ca4:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 8004ca8:	f100 8115 	bmi.w	8004ed6 <_usb_ep0setup.4505+0x356>
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 8004cac:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8004cb0:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8004cb4:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 8004cb8:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004cbc:	e054      	b.n	8004d68 <_usb_ep0setup.4505+0x1e8>
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8004cbe:	699b      	ldr	r3, [r3, #24]
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
 8004cc0:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 8004cc2:	2600      	movs	r6, #0
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8004cc4:	2104      	movs	r1, #4
 8004cc6:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 8004cca:	4620      	mov	r0, r4
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
 8004ccc:	60da      	str	r2, [r3, #12]
  osp->rxsize             = n;
 8004cce:	605d      	str	r5, [r3, #4]
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 8004cd0:	701e      	strb	r6, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 8004cd2:	609e      	str	r6, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 8004cd4:	4631      	mov	r1, r6
 8004cd6:	f000 fe43 	bl	8005960 <usb_lld_prepare_receive>
 8004cda:	2320      	movs	r3, #32
 8004cdc:	f383 8811 	msr	BASEPRI, r3
    if (usbp->ep0n != 0U) {
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
      usbPrepareReceive(usbp, 0, usbp->ep0next, usbp->ep0n);
      osalSysLockFromISR();
      (void) usbStartReceiveI(usbp, 0);
 8004ce0:	4620      	mov	r0, r4
 8004ce2:	4631      	mov	r1, r6
 8004ce4:	f000 fdf4 	bl	80058d0 <usbStartReceiveI>
 8004ce8:	f386 8811 	msr	BASEPRI, r6
 8004cec:	bd70      	pop	{r4, r5, r6, pc}
  if (usbp->ep0n > max) {
    usbp->ep0n = max;
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 8004cee:	b1bd      	cbz	r5, 8004d20 <_usb_ep0setup.4505+0x1a0>
 *
 * @special
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8004cf0:	695b      	ldr	r3, [r3, #20]
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
      usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
 8004cf2:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8004cf4:	2600      	movs	r6, #0
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 8004cf6:	2101      	movs	r1, #1
 8004cf8:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8004cfc:	4620      	mov	r0, r4
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
  isp->mode.linear.txbuf  = buf;
 8004cfe:	60da      	str	r2, [r3, #12]
  isp->txsize             = n;
 8004d00:	605d      	str	r5, [r3, #4]
 */
void usbPrepareTransmit(USBDriver *usbp, usbep_t ep,
                        const uint8_t *buf, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = false;
 8004d02:	701e      	strb	r6, [r3, #0]
  isp->mode.linear.txbuf  = buf;
  isp->txsize             = n;
  isp->txcnt              = 0;
 8004d04:	609e      	str	r6, [r3, #8]

  usb_lld_prepare_transmit(usbp, ep);
 8004d06:	4631      	mov	r1, r6
 8004d08:	f000 fe02 	bl	8005910 <usb_lld_prepare_transmit>
 8004d0c:	2320      	movs	r3, #32
 8004d0e:	f383 8811 	msr	BASEPRI, r3
    if (usbp->ep0n != 0U) {
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
      usbPrepareTransmit(usbp, 0, usbp->ep0next, usbp->ep0n);
      osalSysLockFromISR();
      (void) usbStartTransmitI(usbp, 0);
 8004d12:	4620      	mov	r0, r4
 8004d14:	4631      	mov	r1, r6
 8004d16:	f000 fdbb 	bl	8005890 <usbStartTransmitI>
 8004d1a:	f386 8811 	msr	BASEPRI, r6
 8004d1e:	bd70      	pop	{r4, r5, r6, pc}
 * @param[in] n         transaction size
 *
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8004d20:	699b      	ldr	r3, [r3, #24]
      osalSysUnlockFromISR();
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 8004d22:	2203      	movs	r2, #3
 8004d24:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
  osp->rxqueued           = false;
  osp->mode.linear.rxbuf  = buf;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 8004d28:	4620      	mov	r0, r4
 * @special
 */
void usbPrepareReceive(USBDriver *usbp, usbep_t ep, uint8_t *buf, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = false;
 8004d2a:	701d      	strb	r5, [r3, #0]
  osp->mode.linear.rxbuf  = buf;
 8004d2c:	60dd      	str	r5, [r3, #12]
  osp->rxsize             = n;
 8004d2e:	605d      	str	r5, [r3, #4]
  osp->rxcnt              = 0;
 8004d30:	609d      	str	r5, [r3, #8]

  usb_lld_prepare_receive(usbp, ep);
 8004d32:	4629      	mov	r1, r5
 8004d34:	f000 fe14 	bl	8005960 <usb_lld_prepare_receive>
 8004d38:	2320      	movs	r3, #32
 8004d3a:	f383 8811 	msr	BASEPRI, r3
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      usbPrepareReceive(usbp, 0, NULL, 0);
      osalSysLockFromISR();
      (void) usbStartReceiveI(usbp, 0);
 8004d3e:	4620      	mov	r0, r4
 8004d40:	4629      	mov	r1, r5
 8004d42:	f000 fdc5 	bl	80058d0 <usbStartReceiveI>
 8004d46:	f385 8811 	msr	BASEPRI, r5
 8004d4a:	bd70      	pop	{r4, r5, r6, pc}
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8004d4c:	f240 3202 	movw	r2, #770	; 0x302
 8004d50:	4295      	cmp	r5, r2
 8004d52:	d021      	beq.n	8004d98 <_usb_ep0setup.4505+0x218>
 8004d54:	f5b5 6fa0 	cmp.w	r5, #1280	; 0x500
 8004d58:	f47f af53 	bne.w	8004c02 <_usb_ep0setup.4505+0x82>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 8004d5c:	f8b4 2044 	ldrh.w	r2, [r4, #68]	; 0x44
 8004d60:	f5b2 6fa0 	cmp.w	r2, #1280	; 0x500
 8004d64:	f000 809f 	beq.w	8004ea6 <_usb_ep0setup.4505+0x326>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8004d68:	2500      	movs	r5, #0
 8004d6a:	63a5      	str	r5, [r4, #56]	; 0x38
 8004d6c:	63e5      	str	r5, [r4, #60]	; 0x3c
 8004d6e:	6425      	str	r5, [r4, #64]	; 0x40
 8004d70:	e71b      	b.n	8004baa <_usb_ep0setup.4505+0x2a>
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host.*/
    usbp->configuration = usbp->setup[2];
 8004d72:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8004d76:	f884 204f 	strb.w	r2, [r4, #79]	; 0x4f
    if (usbp->configuration == 0U) {
 8004d7a:	2a00      	cmp	r2, #0
 8004d7c:	f040 808b 	bne.w	8004e96 <_usb_ep0setup.4505+0x316>
      usbp->state = USB_SELECTED;
 8004d80:	2203      	movs	r2, #3
 8004d82:	7022      	strb	r2, [r4, #0]
    }
    else {
      usbp->state = USB_ACTIVE;
    }
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8004d84:	6862      	ldr	r2, [r4, #4]
 8004d86:	6812      	ldr	r2, [r2, #0]
 8004d88:	2a00      	cmp	r2, #0
 8004d8a:	d0ed      	beq.n	8004d68 <_usb_ep0setup.4505+0x1e8>
 8004d8c:	4620      	mov	r0, r4
 8004d8e:	2102      	movs	r1, #2
 8004d90:	4790      	blx	r2
 8004d92:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004d96:	e7e7      	b.n	8004d68 <_usb_ep0setup.4505+0x1e8>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8004d98:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8004d9c:	2a00      	cmp	r2, #0
 8004d9e:	f47f af30 	bne.w	8004c02 <_usb_ep0setup.4505+0x82>
      return false;
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8004da2:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 8004da6:	f012 010f 	ands.w	r1, r2, #15
 8004daa:	d0dd      	beq.n	8004d68 <_usb_ep0setup.4505+0x1e8>
 8004dac:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8004dae:	eb03 1141 	add.w	r1, r3, r1, lsl #5
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8004db2:	0613      	lsls	r3, r2, #24
 8004db4:	f100 8098 	bmi.w	8004ee8 <_usb_ep0setup.4505+0x368>
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 8004db8:	f8d1 3b00 	ldr.w	r3, [r1, #2816]	; 0xb00
 8004dbc:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8004dc0:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
 8004dc4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004dc8:	e7ce      	b.n	8004d68 <_usb_ep0setup.4505+0x1e8>
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8004dca:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8004dce:	2a01      	cmp	r2, #1
 8004dd0:	f47f af17 	bne.w	8004c02 <_usb_ep0setup.4505+0x82>
      usbp->status &= ~2U;
 8004dd4:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8004dd8:	63a6      	str	r6, [r4, #56]	; 0x38
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 8004dda:	f022 0202 	bic.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8004dde:	63e6      	str	r6, [r4, #60]	; 0x3c
 8004de0:	6426      	str	r6, [r4, #64]	; 0x40
 8004de2:	4635      	mov	r5, r6
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status &= ~2U;
 8004de4:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
 8004de8:	e6df      	b.n	8004baa <_usb_ep0setup.4505+0x2a>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8004dea:	2d00      	cmp	r5, #0
 8004dec:	d139      	bne.n	8004e62 <_usb_ep0setup.4505+0x2e2>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 8004dee:	2202      	movs	r2, #2
 8004df0:	f104 014c 	add.w	r1, r4, #76	; 0x4c
 8004df4:	6425      	str	r5, [r4, #64]	; 0x40
 8004df6:	63a1      	str	r1, [r4, #56]	; 0x38
 8004df8:	63e2      	str	r2, [r4, #60]	; 0x3c
 8004dfa:	4615      	mov	r5, r2
 8004dfc:	e6d5      	b.n	8004baa <_usb_ep0setup.4505+0x2a>
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
    /*lint -restore*/
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8004dfe:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
 8004e02:	0611      	lsls	r1, r2, #24
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 8004e04:	bf53      	iteet	pl
 8004e06:	f002 010f 	andpl.w	r1, r2, #15
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 8004e0a:	f002 020f 	andmi.w	r2, r2, #15
 8004e0e:	f102 0148 	addmi.w	r1, r2, #72	; 0x48
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 8004e12:	3158      	addpl	r1, #88	; 0x58
 8004e14:	0149      	lsls	r1, r1, #5
 8004e16:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8004e18:	5851      	ldr	r1, [r2, r1]
  if (!(ctl & DOEPCTL_USBAEP))
 8004e1a:	0408      	lsls	r0, r1, #16
 8004e1c:	f57f aef2 	bpl.w	8004c04 <_usb_ep0setup.4505+0x84>
    return EP_STATUS_DISABLED;
  if (ctl & DOEPCTL_STALL)
 8004e20:	f411 1100 	ands.w	r1, r1, #2097152	; 0x200000
 8004e24:	d13a      	bne.n	8004e9c <_usb_ep0setup.4505+0x31c>
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
        /*lint -restore*/
        return true;
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8004e26:	4a35      	ldr	r2, [pc, #212]	; (8004efc <_usb_ep0setup.4505+0x37c>)
 8004e28:	63e5      	str	r5, [r4, #60]	; 0x3c
 8004e2a:	6421      	str	r1, [r4, #64]	; 0x40
 8004e2c:	63a2      	str	r2, [r4, #56]	; 0x38
 8004e2e:	e6bc      	b.n	8004baa <_usb_ep0setup.4505+0x2a>
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8004e30:	6862      	ldr	r2, [r4, #4]

static uint16_t get_hword(uint8_t *p) {
  uint16_t hw;

  hw  = (uint16_t)*p++;
  hw |= (uint16_t)*p << 8U;
 8004e32:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 8004e36:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 8004e3a:	6855      	ldr	r5, [r2, #4]
 8004e3c:	f894 1047 	ldrb.w	r1, [r4, #71]	; 0x47
 8004e40:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8004e44:	ea43 2300 	orr.w	r3, r3, r0, lsl #8
 8004e48:	4620      	mov	r0, r4
 8004e4a:	47a8      	blx	r5
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 8004e4c:	2800      	cmp	r0, #0
 8004e4e:	f43f aed8 	beq.w	8004c02 <_usb_ep0setup.4505+0x82>
      return false;
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 8004e52:	6843      	ldr	r3, [r0, #4]
 8004e54:	6805      	ldr	r5, [r0, #0]
 8004e56:	63e5      	str	r5, [r4, #60]	; 0x3c
 8004e58:	63a3      	str	r3, [r4, #56]	; 0x38
 8004e5a:	6426      	str	r6, [r4, #64]	; 0x40
 8004e5c:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004e60:	e6a3      	b.n	8004baa <_usb_ep0setup.4505+0x2a>
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8004e62:	2d01      	cmp	r5, #1
 8004e64:	f47f aecd 	bne.w	8004c02 <_usb_ep0setup.4505+0x82>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8004e68:	4a25      	ldr	r2, [pc, #148]	; (8004f00 <_usb_ep0setup.4505+0x380>)
 8004e6a:	63a2      	str	r2, [r4, #56]	; 0x38
 8004e6c:	2502      	movs	r5, #2
 8004e6e:	2200      	movs	r2, #0
 8004e70:	63e5      	str	r5, [r4, #60]	; 0x3c
 8004e72:	6422      	str	r2, [r4, #64]	; 0x40
 8004e74:	e699      	b.n	8004baa <_usb_ep0setup.4505+0x2a>
    }
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8004e76:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 8004e7a:	2a01      	cmp	r2, #1
 8004e7c:	f47f aec1 	bne.w	8004c02 <_usb_ep0setup.4505+0x82>
      usbp->status |= 2U;
 8004e80:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8004e84:	63a6      	str	r6, [r4, #56]	; 0x38
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 8004e86:	f042 0202 	orr.w	r2, r2, #2
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8004e8a:	63e6      	str	r6, [r4, #60]	; 0x3c
 8004e8c:	6426      	str	r6, [r4, #64]	; 0x40
 8004e8e:	4635      	mov	r5, r6
    return false;
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
      usbp->status |= 2U;
 8004e90:	f8a4 204c 	strh.w	r2, [r4, #76]	; 0x4c
 8004e94:	e689      	b.n	8004baa <_usb_ep0setup.4505+0x2a>
    usbp->configuration = usbp->setup[2];
    if (usbp->configuration == 0U) {
      usbp->state = USB_SELECTED;
    }
    else {
      usbp->state = USB_ACTIVE;
 8004e96:	2204      	movs	r2, #4
 8004e98:	7022      	strb	r2, [r4, #0]
 8004e9a:	e773      	b.n	8004d84 <_usb_ep0setup.4505+0x204>
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8004e9c:	4a19      	ldr	r2, [pc, #100]	; (8004f04 <_usb_ep0setup.4505+0x384>)
 8004e9e:	63e5      	str	r5, [r4, #60]	; 0x3c
 8004ea0:	6426      	str	r6, [r4, #64]	; 0x40
 8004ea2:	63a2      	str	r2, [r4, #56]	; 0x38
 8004ea4:	e681      	b.n	8004baa <_usb_ep0setup.4505+0x2a>
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {

  usbp->address = usbp->setup[2];
 8004ea6:	f894 2046 	ldrb.w	r2, [r4, #70]	; 0x46
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 8004eaa:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8004eac:	f884 204e 	strb.w	r2, [r4, #78]	; 0x4e

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 8004eb0:	f8d3 0800 	ldr.w	r0, [r3, #2048]	; 0x800
  usb_lld_set_address(usbp);
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8004eb4:	6861      	ldr	r1, [r4, #4]
 8004eb6:	f420 60fe 	bic.w	r0, r0, #2032	; 0x7f0
 8004eba:	680d      	ldr	r5, [r1, #0]
 8004ebc:	ea40 1202 	orr.w	r2, r0, r2, lsl #4
 8004ec0:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
 8004ec4:	b115      	cbz	r5, 8004ecc <_usb_ep0setup.4505+0x34c>
 8004ec6:	4620      	mov	r0, r4
 8004ec8:	2101      	movs	r1, #1
 8004eca:	47a8      	blx	r5
  usbp->state = USB_SELECTED;
 8004ecc:	2203      	movs	r2, #3
 8004ece:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004ed2:	7022      	strb	r2, [r4, #0]
 8004ed4:	e748      	b.n	8004d68 <_usb_ep0setup.4505+0x1e8>
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 8004ed6:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8004eda:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8004ede:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
 8004ee2:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004ee6:	e73f      	b.n	8004d68 <_usb_ep0setup.4505+0x1e8>
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 8004ee8:	f8d1 3900 	ldr.w	r3, [r1, #2304]	; 0x900
 8004eec:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8004ef0:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
 8004ef4:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 8004ef8:	e736      	b.n	8004d68 <_usb_ep0setup.4505+0x1e8>
 8004efa:	bf00      	nop
 8004efc:	08007010 	.word	0x08007010
 8004f00:	08007110 	.word	0x08007110
 8004f04:	080070d0 	.word	0x080070d0
	...

08004f10 <cmd_tx.16069>:
    telnetReconfig();
    chprintf(chp, "done:\n\r");
    return 1;
}

static void cmd_tx(BaseSequentialStream *chp, int argc, char *argv[]) {
 8004f10:	b570      	push	{r4, r5, r6, lr}
 8004f12:	b088      	sub	sp, #32
 8004f14:	4605      	mov	r5, r0
 8004f16:	f89d 6000 	ldrb.w	r6, [sp]
 8004f1a:	e001      	b.n	8004f20 <cmd_tx.16069+0x10>
                    chprintf(chp, "closed \n\r",b);
                    return 1;
                    }
                  else{
                 //chprintf(chp, "%c",*crack);
                 chThdSleep(100);
 8004f1c:	f7fe ff88 	bl	8003e30 <chThdSleep>
  (void)argv;

   uint8_t crack[32];
   int i =1;
   while(i == 1){
                   uint8_t b = pubA();
 8004f20:	f001 f83e 	bl	8005fa0 <pubA>
                   chprintf(chp, "%c",b);
 8004f24:	b2c4      	uxtb	r4, r0
 8004f26:	4622      	mov	r2, r4
 8004f28:	490a      	ldr	r1, [pc, #40]	; (8004f54 <cmd_tx.16069+0x44>)
 8004f2a:	4628      	mov	r0, r5
 8004f2c:	f000 fa88 	bl	8005440 <chprintf.16065>

                    pubH();
                    chprintf(chp, "%c",*crack);
 8004f30:	4628      	mov	r0, r5
 8004f32:	4908      	ldr	r1, [pc, #32]	; (8004f54 <cmd_tx.16069+0x44>)
 8004f34:	4632      	mov	r2, r6
 8004f36:	f000 fa83 	bl	8005440 <chprintf.16065>



                 if(b == '!'){
 8004f3a:	2c21      	cmp	r4, #33	; 0x21
                    chprintf(chp, "closed \n\r",b);
                    return 1;
                    }
                  else{
                 //chprintf(chp, "%c",*crack);
                 chThdSleep(100);
 8004f3c:	f04f 0064 	mov.w	r0, #100	; 0x64
                    pubH();
                    chprintf(chp, "%c",*crack);



                 if(b == '!'){
 8004f40:	d1ec      	bne.n	8004f1c <cmd_tx.16069+0xc>
                    chprintf(chp, "closed \n\r",b);
 8004f42:	4905      	ldr	r1, [pc, #20]	; (8004f58 <cmd_tx.16069+0x48>)
 8004f44:	4628      	mov	r0, r5
 8004f46:	4622      	mov	r2, r4
                 //chprintf(chp, "%c",*crack);
                 chThdSleep(100);
                }
    }
     return 1;
}
 8004f48:	b008      	add	sp, #32
 8004f4a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
                    chprintf(chp, "%c",*crack);



                 if(b == '!'){
                    chprintf(chp, "closed \n\r",b);
 8004f4e:	f000 ba77 	b.w	8005440 <chprintf.16065>
 8004f52:	bf00      	nop
 8004f54:	080070c4 	.word	0x080070c4
 8004f58:	080070b8 	.word	0x080070b8
 8004f5c:	00000000 	.word	0x00000000

08004f60 <long_to_string_with_divisor.13654.constprop.4.4267>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8004f60:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8004f62:	f100 070b 	add.w	r7, r0, #11
 8004f66:	f100 050a 	add.w	r5, r0, #10
 8004f6a:	460c      	mov	r4, r1
  do {
    i = (int)(l % radix);
 8004f6c:	fbb1 f6f2 	udiv	r6, r1, r2
 8004f70:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 8004f74:	f101 0330 	add.w	r3, r1, #48	; 0x30
    if (i > '9')
 8004f78:	2b39      	cmp	r3, #57	; 0x39
      i += 'A' - '0' - 10;
 8004f7a:	bfc8      	it	gt
 8004f7c:	f101 0337 	addgt.w	r3, r1, #55	; 0x37
    *--q = i;
 8004f80:	b2db      	uxtb	r3, r3
    l /= radix;
  } while ((ll /= radix) != 0);
 8004f82:	fbb4 f4f2 	udiv	r4, r4, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 8004f86:	4631      	mov	r1, r6
  do {
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
 8004f88:	462e      	mov	r6, r5
 8004f8a:	f805 3901 	strb.w	r3, [r5], #-1
    l /= radix;
  } while ((ll /= radix) != 0);
 8004f8e:	2c00      	cmp	r4, #0
 8004f90:	d1ec      	bne.n	8004f6c <long_to_string_with_divisor.13654.constprop.4.4267+0xc>

  i = (int)(p + MAX_FILLER - q);
 8004f92:	1bb9      	subs	r1, r7, r6
 8004f94:	4632      	mov	r2, r6
 8004f96:	4401      	add	r1, r0
 8004f98:	e001      	b.n	8004f9e <long_to_string_with_divisor.13654.constprop.4.4267+0x3e>
 8004f9a:	f812 3f01 	ldrb.w	r3, [r2, #1]!
  do
    *p++ = *q++;
 8004f9e:	f800 3b01 	strb.w	r3, [r0], #1
  while (--i);
 8004fa2:	4288      	cmp	r0, r1
 8004fa4:	d1f9      	bne.n	8004f9a <long_to_string_with_divisor.13654.constprop.4.4267+0x3a>

  return p;
}
 8004fa6:	bcf0      	pop	{r4, r5, r6, r7}
 8004fa8:	4770      	bx	lr
 8004faa:	bf00      	nop
 8004fac:	0000      	movs	r0, r0
	...

08004fb0 <chvprintf.4252>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8004fb0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004fb4:	b089      	sub	sp, #36	; 0x24
 8004fb6:	ab05      	add	r3, sp, #20
 8004fb8:	f10d 0c15 	add.w	ip, sp, #21
 8004fbc:	9301      	str	r3, [sp, #4]
 8004fbe:	ebc3 030c 	rsb	r3, r3, ip
 8004fc2:	f8cd c000 	str.w	ip, [sp]
 8004fc6:	4683      	mov	fp, r0
 8004fc8:	460c      	mov	r4, r1
 8004fca:	4615      	mov	r5, r2
 8004fcc:	9303      	str	r3, [sp, #12]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8004fce:	f04f 0800 	mov.w	r8, #0
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8004fd2:	7821      	ldrb	r1, [r4, #0]
 8004fd4:	1c63      	adds	r3, r4, #1
    if (c == 0)
 8004fd6:	b169      	cbz	r1, 8004ff4 <chvprintf.4252+0x44>
      return n;
    if (c != '%') {
 8004fd8:	2925      	cmp	r1, #37	; 0x25
 8004fda:	d00f      	beq.n	8004ffc <chvprintf.4252+0x4c>
      chSequentialStreamPut(chp, (uint8_t)c);
 8004fdc:	f8db 2000 	ldr.w	r2, [fp]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8004fe0:	461c      	mov	r4, r3
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
 8004fe2:	6892      	ldr	r2, [r2, #8]
 8004fe4:	4658      	mov	r0, fp
 8004fe6:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8004fe8:	7821      	ldrb	r1, [r4, #0]
    if (c == 0)
      return n;
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
 8004fea:	f108 0801 	add.w	r8, r8, #1
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8004fee:	1c63      	adds	r3, r4, #1
    if (c == 0)
 8004ff0:	2900      	cmp	r1, #0
 8004ff2:	d1f1      	bne.n	8004fd8 <chvprintf.4252+0x28>
      chSequentialStreamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8004ff4:	4640      	mov	r0, r8
 8004ff6:	b009      	add	sp, #36	; 0x24
 8004ff8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8004ffc:	7862      	ldrb	r2, [r4, #1]
 8004ffe:	2a2d      	cmp	r2, #45	; 0x2d
 8005000:	bf03      	ittte	eq
 8005002:	78a2      	ldrbeq	r2, [r4, #2]
      fmt++;
 8005004:	1ca3      	addeq	r3, r4, #2
      left_align = TRUE;
 8005006:	f04f 0a01 	moveq.w	sl, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 800500a:	f04f 0a00 	movne.w	sl, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 800500e:	2a30      	cmp	r2, #48	; 0x30
 8005010:	bf03      	ittte	eq
 8005012:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 8005014:	3301      	addeq	r3, #1
      filler = '0';
 8005016:	2630      	moveq	r6, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 8005018:	2620      	movne	r6, #32
    if (*fmt == '0') {
      fmt++;
      filler = '0';
 800501a:	461c      	mov	r4, r3
    }
    width = 0;
 800501c:	2700      	movs	r7, #0
 800501e:	e006      	b.n	800502e <chvprintf.4252+0x7e>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 8005020:	782b      	ldrb	r3, [r5, #0]
 8005022:	3504      	adds	r5, #4
      else
        break;
      width = width * 10 + c;
 8005024:	eb07 0787 	add.w	r7, r7, r7, lsl #2
 8005028:	7822      	ldrb	r2, [r4, #0]
 800502a:	eb03 0747 	add.w	r7, r3, r7, lsl #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 800502e:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8005032:	b2db      	uxtb	r3, r3
 8005034:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 8005036:	f104 0401 	add.w	r4, r4, #1
      if (c >= '0' && c <= '9')
 800503a:	d9f3      	bls.n	8005024 <chvprintf.4252+0x74>
        c -= '0';
      else if (c == '*')
 800503c:	2a2a      	cmp	r2, #42	; 0x2a
 800503e:	d0ef      	beq.n	8005020 <chvprintf.4252+0x70>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 8005040:	2a2e      	cmp	r2, #46	; 0x2e
 8005042:	f04f 0100 	mov.w	r1, #0
 8005046:	d02b      	beq.n	80050a0 <chvprintf.4252+0xf0>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8005048:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 800504c:	2b4c      	cmp	r3, #76	; 0x4c
 800504e:	d034      	beq.n	80050ba <chvprintf.4252+0x10a>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8005050:	f1a2 0344 	sub.w	r3, r2, #68	; 0x44
 8005054:	2b34      	cmp	r3, #52	; 0x34
 8005056:	f200 80b6 	bhi.w	80051c6 <chvprintf.4252+0x216>
 800505a:	e8df f003 	tbb	[pc, r3]
 800505e:	b4ac      	.short	0xb4ac
 8005060:	acb4b4b4 	.word	0xacb4b4b4
 8005064:	b4b4b4b4 	.word	0xb4b4b4b4
 8005068:	b4b4aab4 	.word	0xb4b4aab4
 800506c:	34b4b4b4 	.word	0x34b4b4b4
 8005070:	b47db4b4 	.word	0xb47db4b4
 8005074:	b4b4b4b4 	.word	0xb4b4b4b4
 8005078:	b4b4b4b4 	.word	0xb4b4b4b4
 800507c:	b4ac9fb4 	.word	0xb4ac9fb4
 8005080:	acb4b4b4 	.word	0xacb4b4b4
 8005084:	b4b4b4b4 	.word	0xb4b4b4b4
 8005088:	b4b4aab4 	.word	0xb4b4aab4
 800508c:	34b47fb4 	.word	0x34b47fb4
 8005090:	b4b4      	.short	0xb4b4
 8005092:	7d          	.byte	0x7d
 8005093:	00          	.byte	0x00
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 8005094:	782b      	ldrb	r3, [r5, #0]
 8005096:	3504      	adds	r5, #4
        else
          break;
        precision *= 10;
 8005098:	eb01 0181 	add.w	r1, r1, r1, lsl #2
        precision += c;
 800509c:	eb03 0141 	add.w	r1, r3, r1, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 80050a0:	f814 2b01 	ldrb.w	r2, [r4], #1
        if (c >= '0' && c <= '9')
 80050a4:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 80050a8:	b2db      	uxtb	r3, r3
 80050aa:	2b09      	cmp	r3, #9
 80050ac:	d9f4      	bls.n	8005098 <chvprintf.4252+0xe8>
          c -= '0';
        else if (c == '*')
 80050ae:	2a2a      	cmp	r2, #42	; 0x2a
 80050b0:	d0f0      	beq.n	8005094 <chvprintf.4252+0xe4>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80050b2:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 80050b6:	2b4c      	cmp	r3, #76	; 0x4c
 80050b8:	d1ca      	bne.n	8005050 <chvprintf.4252+0xa0>
      is_long = TRUE;
      if (*fmt)
 80050ba:	7823      	ldrb	r3, [r4, #0]
 80050bc:	2b00      	cmp	r3, #0
 80050be:	d0c7      	beq.n	8005050 <chvprintf.4252+0xa0>
        c = *fmt++;
 80050c0:	3401      	adds	r4, #1
 80050c2:	461a      	mov	r2, r3
 80050c4:	e7c4      	b.n	8005050 <chvprintf.4252+0xa0>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80050c6:	220a      	movs	r2, #10
    case 'O':
    case 'o':
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
 80050c8:	6829      	ldr	r1, [r5, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80050ca:	a805      	add	r0, sp, #20
    case 'O':
    case 'o':
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
 80050cc:	3504      	adds	r5, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80050ce:	f7ff ff47 	bl	8004f60 <long_to_string_with_divisor.13654.constprop.4.4267>
 80050d2:	9b01      	ldr	r3, [sp, #4]
 80050d4:	1ac0      	subs	r0, r0, r3
 80050d6:	f100 3cff 	add.w	ip, r0, #4294967295
 80050da:	f8cd c008 	str.w	ip, [sp, #8]
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80050de:	f10d 0914 	add.w	r9, sp, #20
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 80050e2:	1a3f      	subs	r7, r7, r0
 80050e4:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
      width = 0;
    if (left_align == FALSE)
 80050e8:	f1ba 0f00 	cmp.w	sl, #0
 80050ec:	d112      	bne.n	8005114 <chvprintf.4252+0x164>
      width = -width;
 80050ee:	427f      	negs	r7, r7
    if (width < 0) {
 80050f0:	b187      	cbz	r7, 8005114 <chvprintf.4252+0x164>
      if (*s == '-' && filler == '0') {
 80050f2:	f899 1000 	ldrb.w	r1, [r9]
 80050f6:	292d      	cmp	r1, #45	; 0x2d
 80050f8:	d06d      	beq.n	80051d6 <chvprintf.4252+0x226>
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 80050fa:	46ba      	mov	sl, r7
        chSequentialStreamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
 80050fc:	f8db 3000 	ldr.w	r3, [fp]
 8005100:	4658      	mov	r0, fp
 8005102:	689b      	ldr	r3, [r3, #8]
 8005104:	4631      	mov	r1, r6
 8005106:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8005108:	f11a 0a01 	adds.w	sl, sl, #1
 800510c:	d1f6      	bne.n	80050fc <chvprintf.4252+0x14c>
 800510e:	ebc7 0808 	rsb	r8, r7, r8
 8005112:	4657      	mov	r7, sl
    }
    while (--i >= 0) {
 8005114:	9a02      	ldr	r2, [sp, #8]
 8005116:	2a00      	cmp	r2, #0
 8005118:	db0f      	blt.n	800513a <chvprintf.4252+0x18a>
 800511a:	f109 3aff 	add.w	sl, r9, #4294967295
 800511e:	4491      	add	r9, r2
      chSequentialStreamPut(chp, (uint8_t)*s++);
 8005120:	f8db 3000 	ldr.w	r3, [fp]
 8005124:	f81a 1f01 	ldrb.w	r1, [sl, #1]!
 8005128:	689b      	ldr	r3, [r3, #8]
 800512a:	4658      	mov	r0, fp
 800512c:	4798      	blx	r3
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 800512e:	45ca      	cmp	sl, r9
 8005130:	d1f6      	bne.n	8005120 <chvprintf.4252+0x170>
 8005132:	9b02      	ldr	r3, [sp, #8]
 8005134:	f108 0801 	add.w	r8, r8, #1
 8005138:	4498      	add	r8, r3
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800513a:	2f00      	cmp	r7, #0
 800513c:	f43f af49 	beq.w	8004fd2 <chvprintf.4252+0x22>
 8005140:	46b9      	mov	r9, r7
      chSequentialStreamPut(chp, (uint8_t)filler);
 8005142:	f8db 3000 	ldr.w	r3, [fp]
 8005146:	4658      	mov	r0, fp
 8005148:	689b      	ldr	r3, [r3, #8]
 800514a:	4631      	mov	r1, r6
 800514c:	4798      	blx	r3
    while (--i >= 0) {
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 800514e:	f1b9 0901 	subs.w	r9, r9, #1
 8005152:	d1f6      	bne.n	8005142 <chvprintf.4252+0x192>
 8005154:	44b8      	add	r8, r7
 8005156:	e73c      	b.n	8004fd2 <chvprintf.4252+0x22>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8005158:	2210      	movs	r2, #16
 800515a:	e7b5      	b.n	80050c8 <chvprintf.4252+0x118>
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 800515c:	f8d5 9000 	ldr.w	r9, [r5]
        s = "(null)";
 8005160:	4b30      	ldr	r3, [pc, #192]	; (8005224 <chvprintf.4252+0x274>)
 8005162:	f1b9 0f00 	cmp.w	r9, #0
 8005166:	bf08      	it	eq
 8005168:	4699      	moveq	r9, r3
      if (precision == 0)
        precision = 32767;
 800516a:	f647 73ff 	movw	r3, #32767	; 0x7fff
      for (p = s; *p && (--precision >= 0); p++)
 800516e:	f899 0000 	ldrb.w	r0, [r9]
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8005172:	3504      	adds	r5, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
 8005174:	2900      	cmp	r1, #0
 8005176:	bf08      	it	eq
 8005178:	4619      	moveq	r1, r3
      for (p = s; *p && (--precision >= 0); p++)
 800517a:	2800      	cmp	r0, #0
 800517c:	d04c      	beq.n	8005218 <chvprintf.4252+0x268>
 800517e:	4449      	add	r1, r9
 8005180:	464b      	mov	r3, r9
 8005182:	e001      	b.n	8005188 <chvprintf.4252+0x1d8>
 8005184:	4299      	cmp	r1, r3
 8005186:	d038      	beq.n	80051fa <chvprintf.4252+0x24a>
 8005188:	785a      	ldrb	r2, [r3, #1]
 800518a:	3301      	adds	r3, #1
 800518c:	2a00      	cmp	r2, #0
 800518e:	d1f9      	bne.n	8005184 <chvprintf.4252+0x1d4>
 8005190:	ebc9 0003 	rsb	r0, r9, r3
 8005194:	1e43      	subs	r3, r0, #1
 8005196:	9302      	str	r3, [sp, #8]
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8005198:	2620      	movs	r6, #32
 800519a:	e7a2      	b.n	80050e2 <chvprintf.4252+0x132>
 800519c:	9803      	ldr	r0, [sp, #12]

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 800519e:	682b      	ldr	r3, [r5, #0]
 80051a0:	f88d 3014 	strb.w	r3, [sp, #20]
 80051a4:	1e42      	subs	r2, r0, #1
 80051a6:	3504      	adds	r5, #4
 80051a8:	9202      	str	r2, [sp, #8]
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 80051aa:	2620      	movs	r6, #32
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80051ac:	f10d 0914 	add.w	r9, sp, #20
 80051b0:	e797      	b.n	80050e2 <chvprintf.4252+0x132>
 80051b2:	2208      	movs	r2, #8
 80051b4:	e788      	b.n	80050c8 <chvprintf.4252+0x118>
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
 80051b6:	6829      	ldr	r1, [r5, #0]
      else
        l = va_arg(ap, int);
      if (l < 0) {
 80051b8:	2900      	cmp	r1, #0
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
 80051ba:	f105 0504 	add.w	r5, r5, #4
      else
        l = va_arg(ap, int);
      if (l < 0) {
 80051be:	db24      	blt.n	800520a <chvprintf.4252+0x25a>
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 80051c0:	a805      	add	r0, sp, #20
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 80051c2:	220a      	movs	r2, #10
 80051c4:	e783      	b.n	80050ce <chvprintf.4252+0x11e>
 80051c6:	9803      	ldr	r0, [sp, #12]
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 80051c8:	f88d 2014 	strb.w	r2, [sp, #20]
 80051cc:	1e42      	subs	r2, r0, #1
 80051ce:	9202      	str	r2, [sp, #8]
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 80051d0:	f10d 0914 	add.w	r9, sp, #20
 80051d4:	e785      	b.n	80050e2 <chvprintf.4252+0x132>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 80051d6:	2e30      	cmp	r6, #48	; 0x30
 80051d8:	d18f      	bne.n	80050fa <chvprintf.4252+0x14a>
        chSequentialStreamPut(chp, (uint8_t)*s++);
 80051da:	f8db 3000 	ldr.w	r3, [fp]
 80051de:	4658      	mov	r0, fp
 80051e0:	689b      	ldr	r3, [r3, #8]
 80051e2:	4798      	blx	r3
 80051e4:	f8dd c008 	ldr.w	ip, [sp, #8]
 80051e8:	f10c 3cff 	add.w	ip, ip, #4294967295
 80051ec:	f109 0901 	add.w	r9, r9, #1
        n++;
 80051f0:	f108 0801 	add.w	r8, r8, #1
 80051f4:	f8cd c008 	str.w	ip, [sp, #8]
 80051f8:	e77f      	b.n	80050fa <chvprintf.4252+0x14a>
 80051fa:	ebc9 0001 	rsb	r0, r9, r1
 80051fe:	f100 3cff 	add.w	ip, r0, #4294967295
 8005202:	f8cd c008 	str.w	ip, [sp, #8]
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8005206:	2620      	movs	r6, #32
 8005208:	e76b      	b.n	80050e2 <chvprintf.4252+0x132>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 800520a:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 800520c:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 800520e:	f88d 3014 	strb.w	r3, [sp, #20]
 8005212:	f10d 0015 	add.w	r0, sp, #21
 8005216:	e7d4      	b.n	80051c2 <chvprintf.4252+0x212>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8005218:	f04f 33ff 	mov.w	r3, #4294967295
 800521c:	9302      	str	r3, [sp, #8]
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 800521e:	2620      	movs	r6, #32
 8005220:	e75f      	b.n	80050e2 <chvprintf.4252+0x132>
 8005222:	bf00      	nop
 8005224:	080071f0 	.word	0x080071f0
	...

08005230 <led5off.15419>:
}

static void led5off(void *arg) {

  (void)arg;
  palClearPad(GPIOD, GPIOD_LED6);
 8005230:	4b02      	ldr	r3, [pc, #8]	; (800523c <led5off.15419+0xc>)
 8005232:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8005236:	835a      	strh	r2, [r3, #26]
 8005238:	4770      	bx	lr
 800523a:	bf00      	nop
 800523c:	40020c00 	.word	0x40020c00

08005240 <get_descriptor.14024>:
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 8005240:	2902      	cmp	r1, #2
 8005242:	d006      	beq.n	8005252 <get_descriptor.14024+0x12>
 8005244:	2903      	cmp	r1, #3
 8005246:	d006      	beq.n	8005256 <get_descriptor.14024+0x16>
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
 8005248:	4807      	ldr	r0, [pc, #28]	; (8005268 <get_descriptor.14024+0x28>)
                                           uint8_t dindex,
                                           uint16_t lang) {

  (void)usbp;
  (void)lang;
  switch (dtype) {
 800524a:	2901      	cmp	r1, #1
    return &vcom_configuration_descriptor;
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
      return &vcom_strings[dindex];
  }
  return NULL;
 800524c:	bf18      	it	ne
 800524e:	2000      	movne	r0, #0
 8005250:	4770      	bx	lr
  (void)lang;
  switch (dtype) {
  case USB_DESCRIPTOR_DEVICE:
    return &vcom_device_descriptor;
  case USB_DESCRIPTOR_CONFIGURATION:
    return &vcom_configuration_descriptor;
 8005252:	4806      	ldr	r0, [pc, #24]	; (800526c <get_descriptor.14024+0x2c>)
 8005254:	4770      	bx	lr
  case USB_DESCRIPTOR_STRING:
    if (dindex < 4)
 8005256:	2a03      	cmp	r2, #3
 8005258:	d803      	bhi.n	8005262 <get_descriptor.14024+0x22>
      return &vcom_strings[dindex];
 800525a:	4805      	ldr	r0, [pc, #20]	; (8005270 <get_descriptor.14024+0x30>)
 800525c:	eb00 00c2 	add.w	r0, r0, r2, lsl #3
 8005260:	4770      	bx	lr
  }
  return NULL;
 8005262:	2000      	movs	r0, #0
}
 8005264:	4770      	bx	lr
 8005266:	bf00      	nop
 8005268:	08007570 	.word	0x08007570
 800526c:	08007560 	.word	0x08007560
 8005270:	08007160 	.word	0x08007160
	...

08005280 <notify3.10593>:

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE;
 8005280:	4b02      	ldr	r3, [pc, #8]	; (800528c <notify3.10593+0xc>)
 8005282:	68da      	ldr	r2, [r3, #12]
 8005284:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8005288:	60da      	str	r2, [r3, #12]
 800528a:	4770      	bx	lr
 800528c:	40004800 	.word	0x40004800

08005290 <VectorB8>:
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
 8005290:	b538      	push	{r3, r4, r5, lr}
 * @param[in] pwmp      pointer to a @p PWMDriver object
 */
static void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8005292:	4d17      	ldr	r5, [pc, #92]	; (80052f0 <VectorB8+0x60>)
 8005294:	69ab      	ldr	r3, [r5, #24]
 8005296:	691a      	ldr	r2, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8005298:	68dc      	ldr	r4, [r3, #12]
 800529a:	4014      	ands	r4, r2
 800529c:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
 800529e:	43d2      	mvns	r2, r2
 80052a0:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80052a2:	07a3      	lsls	r3, r4, #30
 80052a4:	d504      	bpl.n	80052b0 <VectorB8+0x20>
      (pwmp->config->channels[0].callback != NULL))
 80052a6:	686b      	ldr	r3, [r5, #4]
 80052a8:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80052aa:	b10b      	cbz	r3, 80052b0 <VectorB8+0x20>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 80052ac:	4628      	mov	r0, r5
 80052ae:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 80052b0:	0760      	lsls	r0, r4, #29
 80052b2:	d504      	bpl.n	80052be <VectorB8+0x2e>
      (pwmp->config->channels[1].callback != NULL))
 80052b4:	686b      	ldr	r3, [r5, #4]
 80052b6:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 80052b8:	b10b      	cbz	r3, 80052be <VectorB8+0x2e>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 80052ba:	480d      	ldr	r0, [pc, #52]	; (80052f0 <VectorB8+0x60>)
 80052bc:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 80052be:	0721      	lsls	r1, r4, #28
 80052c0:	d504      	bpl.n	80052cc <VectorB8+0x3c>
      (pwmp->config->channels[2].callback != NULL))
 80052c2:	686b      	ldr	r3, [r5, #4]
 80052c4:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 80052c6:	b10b      	cbz	r3, 80052cc <VectorB8+0x3c>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 80052c8:	4809      	ldr	r0, [pc, #36]	; (80052f0 <VectorB8+0x60>)
 80052ca:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 80052cc:	06e2      	lsls	r2, r4, #27
 80052ce:	d504      	bpl.n	80052da <VectorB8+0x4a>
      (pwmp->config->channels[3].callback != NULL))
 80052d0:	686b      	ldr	r3, [r5, #4]
 80052d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 80052d4:	b10b      	cbz	r3, 80052da <VectorB8+0x4a>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 80052d6:	4806      	ldr	r0, [pc, #24]	; (80052f0 <VectorB8+0x60>)
 80052d8:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 80052da:	07e3      	lsls	r3, r4, #31
 80052dc:	d504      	bpl.n	80052e8 <VectorB8+0x58>
 80052de:	686b      	ldr	r3, [r5, #4]
 80052e0:	689b      	ldr	r3, [r3, #8]
 80052e2:	b10b      	cbz	r3, 80052e8 <VectorB8+0x58>
    pwmp->config->callback(pwmp);
 80052e4:	4802      	ldr	r0, [pc, #8]	; (80052f0 <VectorB8+0x60>)
 80052e6:	4798      	blx	r3
  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD4);

  OSAL_IRQ_EPILOGUE();
}
 80052e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD4);

  OSAL_IRQ_EPILOGUE();
 80052ec:	f7fc b820 	b.w	8001330 <_port_irq_epilogue>
 80052f0:	20001bec 	.word	0x20001bec
	...

08005300 <VectorAC>:
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();

  sr = STM32_TIM1->SR & STM32_TIM1->DIER & (STM32_TIM_DIER_CC1IE |
 8005300:	4b14      	ldr	r3, [pc, #80]	; (8005354 <VectorAC+0x54>)
 *          associated callback pointer is not equal to @p NULL in order to not
 *          perform an extra check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
 8005302:	b510      	push	{r4, lr}
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();

  sr = STM32_TIM1->SR & STM32_TIM1->DIER & (STM32_TIM_DIER_CC1IE |
 8005304:	691a      	ldr	r2, [r3, #16]
 8005306:	68dc      	ldr	r4, [r3, #12]
 8005308:	4014      	ands	r4, r2
 800530a:	f004 021e 	and.w	r2, r4, #30
                                            STM32_TIM_DIER_CC2IE |
                                            STM32_TIM_DIER_CC3IE |
                                            STM32_TIM_DIER_CC4IE);
  STM32_TIM1->SR = ~sr;
 800530e:	43d2      	mvns	r2, r2
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8005310:	07a0      	lsls	r0, r4, #30

  sr = STM32_TIM1->SR & STM32_TIM1->DIER & (STM32_TIM_DIER_CC1IE |
                                            STM32_TIM_DIER_CC2IE |
                                            STM32_TIM_DIER_CC3IE |
                                            STM32_TIM_DIER_CC4IE);
  STM32_TIM1->SR = ~sr;
 8005312:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8005314:	d504      	bpl.n	8005320 <VectorAC+0x20>
      (PWMD1.config->channels[0].callback != NULL))
 8005316:	4810      	ldr	r0, [pc, #64]	; (8005358 <VectorAC+0x58>)
 8005318:	6843      	ldr	r3, [r0, #4]
 800531a:	691b      	ldr	r3, [r3, #16]
  sr = STM32_TIM1->SR & STM32_TIM1->DIER & (STM32_TIM_DIER_CC1IE |
                                            STM32_TIM_DIER_CC2IE |
                                            STM32_TIM_DIER_CC3IE |
                                            STM32_TIM_DIER_CC4IE);
  STM32_TIM1->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 800531c:	b103      	cbz	r3, 8005320 <VectorAC+0x20>
      (PWMD1.config->channels[0].callback != NULL))
    PWMD1.config->channels[0].callback(&PWMD1);
 800531e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8005320:	0761      	lsls	r1, r4, #29
 8005322:	d504      	bpl.n	800532e <VectorAC+0x2e>
      (PWMD1.config->channels[1].callback != NULL))
 8005324:	480c      	ldr	r0, [pc, #48]	; (8005358 <VectorAC+0x58>)
 8005326:	6843      	ldr	r3, [r0, #4]
 8005328:	699b      	ldr	r3, [r3, #24]
                                            STM32_TIM_DIER_CC4IE);
  STM32_TIM1->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (PWMD1.config->channels[0].callback != NULL))
    PWMD1.config->channels[0].callback(&PWMD1);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 800532a:	b103      	cbz	r3, 800532e <VectorAC+0x2e>
      (PWMD1.config->channels[1].callback != NULL))
    PWMD1.config->channels[1].callback(&PWMD1);
 800532c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 800532e:	0722      	lsls	r2, r4, #28
 8005330:	d504      	bpl.n	800533c <VectorAC+0x3c>
      (PWMD1.config->channels[2].callback != NULL))
 8005332:	4809      	ldr	r0, [pc, #36]	; (8005358 <VectorAC+0x58>)
 8005334:	6843      	ldr	r3, [r0, #4]
 8005336:	6a1b      	ldr	r3, [r3, #32]
      (PWMD1.config->channels[0].callback != NULL))
    PWMD1.config->channels[0].callback(&PWMD1);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (PWMD1.config->channels[1].callback != NULL))
    PWMD1.config->channels[1].callback(&PWMD1);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8005338:	b103      	cbz	r3, 800533c <VectorAC+0x3c>
      (PWMD1.config->channels[2].callback != NULL))
    PWMD1.config->channels[2].callback(&PWMD1);
 800533a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800533c:	06e3      	lsls	r3, r4, #27
 800533e:	d504      	bpl.n	800534a <VectorAC+0x4a>
      (PWMD1.config->channels[3].callback != NULL))
 8005340:	4805      	ldr	r0, [pc, #20]	; (8005358 <VectorAC+0x58>)
 8005342:	6843      	ldr	r3, [r0, #4]
 8005344:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (PWMD1.config->channels[1].callback != NULL))
    PWMD1.config->channels[1].callback(&PWMD1);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (PWMD1.config->channels[2].callback != NULL))
    PWMD1.config->channels[2].callback(&PWMD1);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8005346:	b103      	cbz	r3, 800534a <VectorAC+0x4a>
      (PWMD1.config->channels[3].callback != NULL))
    PWMD1.config->channels[3].callback(&PWMD1);
 8005348:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 800534a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    PWMD1.config->channels[2].callback(&PWMD1);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
      (PWMD1.config->channels[3].callback != NULL))
    PWMD1.config->channels[3].callback(&PWMD1);

  OSAL_IRQ_EPILOGUE();
 800534e:	f7fb bfef 	b.w	8001330 <_port_irq_epilogue>
 8005352:	bf00      	nop
 8005354:	40010000 	.word	0x40010000
 8005358:	20001bd0 	.word	0x20001bd0
 800535c:	00000000 	.word	0x00000000

08005360 <VectorA4>:
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  STM32_TIM1->SR = ~STM32_TIM_SR_UIF;
  if (PWMD1.config->callback != NULL)
 8005360:	4806      	ldr	r0, [pc, #24]	; (800537c <VectorA4+0x1c>)
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  STM32_TIM1->SR = ~STM32_TIM_SR_UIF;
 8005362:	4a07      	ldr	r2, [pc, #28]	; (8005380 <VectorA4+0x20>)
 *          pointer is not equal to @p NULL in order to not perform an extra
 *          check in a potentially critical interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8005364:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  STM32_TIM1->SR = ~STM32_TIM_SR_UIF;
  if (PWMD1.config->callback != NULL)
 8005366:	6843      	ldr	r3, [r0, #4]
 8005368:	689b      	ldr	r3, [r3, #8]
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  STM32_TIM1->SR = ~STM32_TIM_SR_UIF;
 800536a:	f06f 0101 	mvn.w	r1, #1
 800536e:	6111      	str	r1, [r2, #16]
  if (PWMD1.config->callback != NULL)
 8005370:	b103      	cbz	r3, 8005374 <VectorA4+0x14>
    PWMD1.config->callback(&PWMD1);
 8005372:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8005374:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  STM32_TIM1->SR = ~STM32_TIM_SR_UIF;
  if (PWMD1.config->callback != NULL)
    PWMD1.config->callback(&PWMD1);

  OSAL_IRQ_EPILOGUE();
 8005378:	f7fb bfda 	b.w	8001330 <_port_irq_epilogue>
 800537c:	20001bd0 	.word	0x20001bd0
 8005380:	40010000 	.word	0x40010000
	...

08005390 <chSchWakeupS.constprop.49>:

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8005390:	f8df c058 	ldr.w	ip, [pc, #88]	; 80053ec <chSchWakeupS.constprop.49+0x5c>
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8005394:	b4f0      	push	{r4, r5, r6, r7}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8005396:	f8dc 7018 	ldr.w	r7, [ip, #24]
 800539a:	6885      	ldr	r5, [r0, #8]
 800539c:	68bc      	ldr	r4, [r7, #8]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 800539e:	2300      	movs	r3, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80053a0:	42a5      	cmp	r5, r4
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80053a2:	4606      	mov	r6, r0

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 80053a4:	6203      	str	r3, [r0, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 80053a6:	d80c      	bhi.n	80053c2 <chSchWakeupS.constprop.49+0x32>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80053a8:	7703      	strb	r3, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 80053aa:	4663      	mov	r3, ip
  do {
    cp = cp->p_next;
 80053ac:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80053ae:	689a      	ldr	r2, [r3, #8]
 80053b0:	4295      	cmp	r5, r2
 80053b2:	d9fb      	bls.n	80053ac <chSchWakeupS.constprop.49+0x1c>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80053b4:	685a      	ldr	r2, [r3, #4]
 80053b6:	6072      	str	r2, [r6, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80053b8:	6033      	str	r3, [r6, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80053ba:	6016      	str	r6, [r2, #0]
  cp->p_prev = tp;
 80053bc:	605e      	str	r6, [r3, #4]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 80053be:	bcf0      	pop	{r4, r5, r6, r7}
 80053c0:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 80053c2:	773b      	strb	r3, [r7, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 80053c4:	4663      	mov	r3, ip
  do {
    cp = cp->p_next;
 80053c6:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 80053c8:	689a      	ldr	r2, [r3, #8]
 80053ca:	4294      	cmp	r4, r2
 80053cc:	d9fb      	bls.n	80053c6 <chSchWakeupS.constprop.49+0x36>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80053ce:	685a      	ldr	r2, [r3, #4]
 80053d0:	607a      	str	r2, [r7, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 80053d2:	2401      	movs	r4, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80053d4:	603b      	str	r3, [r7, #0]
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 80053d6:	6017      	str	r7, [r2, #0]
  cp->p_prev = tp;
 80053d8:	605f      	str	r7, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 80053da:	7734      	strb	r4, [r6, #28]
    chSysSwitch(ntp, otp);
 80053dc:	4639      	mov	r1, r7
 80053de:	4630      	mov	r0, r6
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 80053e0:	f8cc 6018 	str.w	r6, [ip, #24]
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 80053e4:	bcf0      	pop	{r4, r5, r6, r7}
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 80053e6:	f7fa bf4b 	b.w	8000280 <_port_switch>
 80053ea:	bf00      	nop
 80053ec:	200016a8 	.word	0x200016a8

080053f0 <chTMStartMeasurementX.constprop.45>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80053f0:	4b01      	ldr	r3, [pc, #4]	; (80053f8 <chTMStartMeasurementX.constprop.45+0x8>)
 80053f2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 80053f4:	6083      	str	r3, [r0, #8]
 80053f6:	4770      	bx	lr
 80053f8:	e0001000 	.word	0xe0001000
 80053fc:	00000000 	.word	0x00000000

08005400 <_strtok.13250.constprop.5>:
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 8005400:	b538      	push	{r3, r4, r5, lr}
  char *token;
  if (str)
 8005402:	4604      	mov	r4, r0
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 8005404:	460d      	mov	r5, r1
  char *token;
  if (str)
 8005406:	b190      	cbz	r0, 800542e <_strtok.13250.constprop.5+0x2e>
    *saveptr = str;
 8005408:	6028      	str	r0, [r5, #0]
  token = *saveptr;

  if (!token)
    return NULL;

  token += strspn(token, delim);
 800540a:	4620      	mov	r0, r4
 800540c:	490b      	ldr	r1, [pc, #44]	; (800543c <_strtok.13250.constprop.5+0x3c>)
 800540e:	f001 fb67 	bl	8006ae0 <strspn>
 8005412:	4404      	add	r4, r0
  *saveptr = strpbrk(token, delim);
 8005414:	4620      	mov	r0, r4
 8005416:	4909      	ldr	r1, [pc, #36]	; (800543c <_strtok.13250.constprop.5+0x3c>)
 8005418:	f001 fb3a 	bl	8006a90 <strpbrk>
  if (*saveptr)
 800541c:	b160      	cbz	r0, 8005438 <_strtok.13250.constprop.5+0x38>
    *(*saveptr)++ = '\0';
 800541e:	1c42      	adds	r2, r0, #1
 8005420:	2300      	movs	r3, #0
 8005422:	602a      	str	r2, [r5, #0]
 8005424:	7003      	strb	r3, [r0, #0]

  return *token ? token : NULL;
 8005426:	7823      	ldrb	r3, [r4, #0]
 8005428:	b123      	cbz	r3, 8005434 <_strtok.13250.constprop.5+0x34>
 800542a:	4620      	mov	r0, r4
}
 800542c:	bd38      	pop	{r3, r4, r5, pc}

static char *_strtok(char *str, const char *delim, char **saveptr) {
  char *token;
  if (str)
    *saveptr = str;
  token = *saveptr;
 800542e:	680c      	ldr	r4, [r1, #0]

  if (!token)
 8005430:	2c00      	cmp	r4, #0
 8005432:	d1ea      	bne.n	800540a <_strtok.13250.constprop.5+0xa>
    return NULL;
 8005434:	2000      	movs	r0, #0
 8005436:	bd38      	pop	{r3, r4, r5, pc}

  token += strspn(token, delim);
  *saveptr = strpbrk(token, delim);
 8005438:	6028      	str	r0, [r5, #0]
 800543a:	e7f4      	b.n	8005426 <_strtok.13250.constprop.5+0x26>
 800543c:	080071f8 	.word	0x080071f8

08005440 <chprintf.16065>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8005440:	b40e      	push	{r1, r2, r3}
 8005442:	b500      	push	{lr}
 8005444:	b082      	sub	sp, #8
 8005446:	aa03      	add	r2, sp, #12
 8005448:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800544c:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800544e:	f7ff fdaf 	bl	8004fb0 <chvprintf.4252>
  va_end(ap);

  return formatted_bytes;
}
 8005452:	b002      	add	sp, #8
 8005454:	f85d eb04 	ldr.w	lr, [sp], #4
 8005458:	b003      	add	sp, #12
 800545a:	4770      	bx	lr
 800545c:	0000      	movs	r0, r0
	...

08005460 <cmd_threads.16137>:
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u\r\n", n);
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
}

static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8005460:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 8005464:	2900      	cmp	r1, #0
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u\r\n", n);
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
}

static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8005466:	b084      	sub	sp, #16
 8005468:	4606      	mov	r6, r0
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 800546a:	dd05      	ble.n	8005478 <cmd_threads.16137+0x18>
    chprintf(chp, "Usage: threads\r\n");
 800546c:	491d      	ldr	r1, [pc, #116]	; (80054e4 <cmd_threads.16137+0x84>)
             (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
             (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
             states[tp->p_state]);
    tp = chRegNextThread(tp);
  } while (tp != NULL);
}
 800546e:	b004      	add	sp, #16
 8005470:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: threads\r\n");
 8005474:	f7ff bfe4 	b.w	8005440 <chprintf.16065>
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state\r\n");
 8005478:	491b      	ldr	r1, [pc, #108]	; (80054e8 <cmd_threads.16137+0x88>)
 800547a:	f7ff ffe1 	bl	8005440 <chprintf.16065>
 800547e:	f04f 0920 	mov.w	r9, #32
 8005482:	f389 8811 	msr	BASEPRI, r9
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.r_newer;
 8005486:	4f19      	ldr	r7, [pc, #100]	; (80054ec <cmd_threads.16137+0x8c>)
 8005488:	693c      	ldr	r4, [r7, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 800548a:	7fa3      	ldrb	r3, [r4, #30]
 800548c:	3301      	adds	r3, #1
 800548e:	77a3      	strb	r3, [r4, #30]
 8005490:	f04f 0800 	mov.w	r8, #0
 8005494:	f388 8811 	msr	BASEPRI, r8
 8005498:	f8df a058 	ldr.w	sl, [pc, #88]	; 80054f4 <cmd_threads.16137+0x94>
 800549c:	e000      	b.n	80054a0 <cmd_threads.16137+0x40>
  do {
    chprintf(chp, "%08lx %08lx %4lu %4lu %9s\r\n",
             (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
             (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
             states[tp->p_state]);
    tp = chRegNextThread(tp);
 800549e:	462c      	mov	r4, r5
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state\r\n");
  tp = chRegFirstThread();
  do {
    chprintf(chp, "%08lx %08lx %4lu %4lu %9s\r\n",
 80054a0:	68a2      	ldr	r2, [r4, #8]
 80054a2:	68e3      	ldr	r3, [r4, #12]
 80054a4:	9200      	str	r2, [sp, #0]
             (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
             (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
 80054a6:	7fa2      	ldrb	r2, [r4, #30]
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state\r\n");
  tp = chRegFirstThread();
  do {
    chprintf(chp, "%08lx %08lx %4lu %4lu %9s\r\n",
 80054a8:	4911      	ldr	r1, [pc, #68]	; (80054f0 <cmd_threads.16137+0x90>)
             (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
             (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
 80054aa:	3a01      	subs	r2, #1
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state\r\n");
  tp = chRegFirstThread();
  do {
    chprintf(chp, "%08lx %08lx %4lu %4lu %9s\r\n",
 80054ac:	9201      	str	r2, [sp, #4]
 80054ae:	7f22      	ldrb	r2, [r4, #28]
 80054b0:	f85a 2022 	ldr.w	r2, [sl, r2, lsl #2]
 80054b4:	9202      	str	r2, [sp, #8]
 80054b6:	4630      	mov	r0, r6
 80054b8:	4622      	mov	r2, r4
 80054ba:	f7ff ffc1 	bl	8005440 <chprintf.16065>
 80054be:	f389 8811 	msr	BASEPRI, r9
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
 80054c2:	6925      	ldr	r5, [r4, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 80054c4:	42bd      	cmp	r5, r7
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
    ntp->p_refs++;
 80054c6:	bf1d      	ittte	ne
 80054c8:	7fab      	ldrbne	r3, [r5, #30]
 80054ca:	3301      	addne	r3, #1
 80054cc:	77ab      	strbne	r3, [r5, #30]
  chSysLock();
  ntp = tp->p_newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 80054ce:	2500      	moveq	r5, #0
 80054d0:	f388 8811 	msr	BASEPRI, r8
    ntp->p_refs++;
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80054d4:	4620      	mov	r0, r4
 80054d6:	f7fc fa8b 	bl	80019f0 <chThdRelease>
             (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
             (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
             states[tp->p_state]);
    tp = chRegNextThread(tp);
  } while (tp != NULL);
 80054da:	2d00      	cmp	r5, #0
 80054dc:	d1df      	bne.n	800549e <cmd_threads.16137+0x3e>
}
 80054de:	b004      	add	sp, #16
 80054e0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80054e4:	080071fc 	.word	0x080071fc
 80054e8:	08007210 	.word	0x08007210
 80054ec:	200016a8 	.word	0x200016a8
 80054f0:	08007238 	.word	0x08007238
 80054f4:	080071b0 	.word	0x080071b0
	...

08005500 <cmd_dev.16105>:
               chThdSleep(1000);
               return 1;
    }
}

static void cmd_dev(BaseSequentialStream *chp, int argc, char *argv[]) {
 8005500:	b510      	push	{r4, lr}

  uint8_t u[3];
  (void)argv;
  if (argc > 0) {
 8005502:	2900      	cmp	r1, #0
               chThdSleep(1000);
               return 1;
    }
}

static void cmd_dev(BaseSequentialStream *chp, int argc, char *argv[]) {
 8005504:	b082      	sub	sp, #8
 8005506:	4604      	mov	r4, r0

  uint8_t u[3];
  (void)argv;
  if (argc > 0) {
 8005508:	dd01      	ble.n	800550e <cmd_dev.16105+0xe>
               DEVICE_ID = atoi(u);
               id = atoi(u);
                chprintf(chp, "DEV_ID_int: --%d--\r\n",id);
    return 1;
    }
}
 800550a:	b002      	add	sp, #8
 800550c:	bd10      	pop	{r4, pc}
    //chprintf(chp, "id\r\n\r");
    return;
  }
    while(true){

               chprintf(chp, "Pleas DEVICE_ID:\r\n");
 800550e:	490e      	ldr	r1, [pc, #56]	; (8005548 <cmd_dev.16105+0x48>)
 8005510:	f7ff ff96 	bl	8005440 <chprintf.16065>
               chSequentialStreamRead(serial,&u,4);
 8005514:	4b0d      	ldr	r3, [pc, #52]	; (800554c <cmd_dev.16105+0x4c>)
 8005516:	6818      	ldr	r0, [r3, #0]
 8005518:	6803      	ldr	r3, [r0, #0]
 800551a:	a901      	add	r1, sp, #4
 800551c:	2204      	movs	r2, #4
 800551e:	685b      	ldr	r3, [r3, #4]
 8005520:	4798      	blx	r3
               DEVICE_ID = atoi(u);
 8005522:	a801      	add	r0, sp, #4
 8005524:	f001 fafc 	bl	8006b20 <atoi>
 8005528:	4b09      	ldr	r3, [pc, #36]	; (8005550 <cmd_dev.16105+0x50>)
 800552a:	6018      	str	r0, [r3, #0]
               id = atoi(u);
 800552c:	a801      	add	r0, sp, #4
 800552e:	f001 faf7 	bl	8006b20 <atoi>
 8005532:	4b08      	ldr	r3, [pc, #32]	; (8005554 <cmd_dev.16105+0x54>)
                chprintf(chp, "DEV_ID_int: --%d--\r\n",id);
 8005534:	4908      	ldr	r1, [pc, #32]	; (8005558 <cmd_dev.16105+0x58>)
    while(true){

               chprintf(chp, "Pleas DEVICE_ID:\r\n");
               chSequentialStreamRead(serial,&u,4);
               DEVICE_ID = atoi(u);
               id = atoi(u);
 8005536:	8018      	strh	r0, [r3, #0]
 8005538:	4602      	mov	r2, r0
                chprintf(chp, "DEV_ID_int: --%d--\r\n",id);
 800553a:	b292      	uxth	r2, r2
 800553c:	4620      	mov	r0, r4
 800553e:	f7ff ff7f 	bl	8005440 <chprintf.16065>
    return 1;
    }
}
 8005542:	b002      	add	sp, #8
 8005544:	bd10      	pop	{r4, pc}
 8005546:	bf00      	nop
 8005548:	08007254 	.word	0x08007254
 800554c:	200008c4 	.word	0x200008c4
 8005550:	2000080c 	.word	0x2000080c
 8005554:	20000d14 	.word	0x20000d14
 8005558:	08007268 	.word	0x08007268
 800555c:	00000000 	.word	0x00000000

08005560 <cmd_test.16089>:

static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 8005560:	2900      	cmp	r1, #0
    tp = chRegNextThread(tp);
  } while (tp != NULL);
}


static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 8005562:	b500      	push	{lr}
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 8005564:	dc04      	bgt.n	8005570 <cmd_test.16089+0x10>
    chprintf(chp, "Usage: test\r\n");
    return;
  }
  if (tp == NULL) {
    chprintf(chp, "out of memory\r\n");
 8005566:	4905      	ldr	r1, [pc, #20]	; (800557c <cmd_test.16089+0x1c>)
    return;
  }
  chThdWait(tp);
}
 8005568:	f85d eb04 	ldr.w	lr, [sp], #4
  if (argc > 0) {
    chprintf(chp, "Usage: test\r\n");
    return;
  }
  if (tp == NULL) {
    chprintf(chp, "out of memory\r\n");
 800556c:	f7ff bf68 	b.w	8005440 <chprintf.16065>
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: test\r\n");
 8005570:	4903      	ldr	r1, [pc, #12]	; (8005580 <cmd_test.16089+0x20>)
  if (tp == NULL) {
    chprintf(chp, "out of memory\r\n");
    return;
  }
  chThdWait(tp);
}
 8005572:	f85d eb04 	ldr.w	lr, [sp], #4
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: test\r\n");
 8005576:	f7ff bf63 	b.w	8005440 <chprintf.16065>
 800557a:	bf00      	nop
 800557c:	08007290 	.word	0x08007290
 8005580:	08007280 	.word	0x08007280
	...

08005590 <chprintf.13255>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8005590:	b40e      	push	{r1, r2, r3}
 8005592:	b500      	push	{lr}
 8005594:	b082      	sub	sp, #8
 8005596:	aa03      	add	r2, sp, #12
 8005598:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 800559c:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 800559e:	f7ff fd07 	bl	8004fb0 <chvprintf.4252>
  va_end(ap);

  return formatted_bytes;
}
 80055a2:	b002      	add	sp, #8
 80055a4:	f85d eb04 	ldr.w	lr, [sp], #4
 80055a8:	b003      	add	sp, #12
 80055aa:	4770      	bx	lr
 80055ac:	0000      	movs	r0, r0
	...

080055b0 <cmd_info.13270>:
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 80055b0:	b510      	push	{r4, lr}

  (void)argv;
  if (argc > 0) {
 80055b2:	2900      	cmp	r1, #0
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 80055b4:	b082      	sub	sp, #8
 80055b6:	4604      	mov	r4, r0

  (void)argv;
  if (argc > 0) {
 80055b8:	dd06      	ble.n	80055c8 <cmd_info.13270+0x18>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 80055ba:	4919      	ldr	r1, [pc, #100]	; (8005620 <cmd_info.13270+0x70>)
 80055bc:	4a19      	ldr	r2, [pc, #100]	; (8005624 <cmd_info.13270+0x74>)
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
#endif
#endif
}
 80055be:	b002      	add	sp, #8
 80055c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 80055c4:	f7ff bfe4 	b.w	8005590 <chprintf.13255>
  if (argc > 0) {
    usage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 80055c8:	4917      	ldr	r1, [pc, #92]	; (8005628 <cmd_info.13270+0x78>)
 80055ca:	4a18      	ldr	r2, [pc, #96]	; (800562c <cmd_info.13270+0x7c>)
 80055cc:	f7ff ffe0 	bl	8005590 <chprintf.13255>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s\r\n", PORT_COMPILER_NAME);
 80055d0:	4620      	mov	r0, r4
 80055d2:	4917      	ldr	r1, [pc, #92]	; (8005630 <cmd_info.13270+0x80>)
 80055d4:	4a17      	ldr	r2, [pc, #92]	; (8005634 <cmd_info.13270+0x84>)
 80055d6:	f7ff ffdb 	bl	8005590 <chprintf.13255>
#endif
  chprintf(chp, "Architecture: %s\r\n", PORT_ARCHITECTURE_NAME);
 80055da:	4620      	mov	r0, r4
 80055dc:	4916      	ldr	r1, [pc, #88]	; (8005638 <cmd_info.13270+0x88>)
 80055de:	4a17      	ldr	r2, [pc, #92]	; (800563c <cmd_info.13270+0x8c>)
 80055e0:	f7ff ffd6 	bl	8005590 <chprintf.13255>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s\r\n", PORT_CORE_VARIANT_NAME);
 80055e4:	4620      	mov	r0, r4
 80055e6:	4916      	ldr	r1, [pc, #88]	; (8005640 <cmd_info.13270+0x90>)
 80055e8:	4a16      	ldr	r2, [pc, #88]	; (8005644 <cmd_info.13270+0x94>)
 80055ea:	f7ff ffd1 	bl	8005590 <chprintf.13255>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s\r\n", PORT_INFO);
 80055ee:	4620      	mov	r0, r4
 80055f0:	4915      	ldr	r1, [pc, #84]	; (8005648 <cmd_info.13270+0x98>)
 80055f2:	4a16      	ldr	r2, [pc, #88]	; (800564c <cmd_info.13270+0x9c>)
 80055f4:	f7ff ffcc 	bl	8005590 <chprintf.13255>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s\r\n", PLATFORM_NAME);
 80055f8:	4620      	mov	r0, r4
 80055fa:	4915      	ldr	r1, [pc, #84]	; (8005650 <cmd_info.13270+0xa0>)
 80055fc:	4a15      	ldr	r2, [pc, #84]	; (8005654 <cmd_info.13270+0xa4>)
 80055fe:	f7ff ffc7 	bl	8005590 <chprintf.13255>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s\r\n", BOARD_NAME);
 8005602:	4620      	mov	r0, r4
 8005604:	4914      	ldr	r1, [pc, #80]	; (8005658 <cmd_info.13270+0xa8>)
 8005606:	4a15      	ldr	r2, [pc, #84]	; (800565c <cmd_info.13270+0xac>)
 8005608:	f7ff ffc2 	bl	8005590 <chprintf.13255>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
 800560c:	4b14      	ldr	r3, [pc, #80]	; (8005660 <cmd_info.13270+0xb0>)
 800560e:	9300      	str	r3, [sp, #0]
 8005610:	4620      	mov	r0, r4
 8005612:	4914      	ldr	r1, [pc, #80]	; (8005664 <cmd_info.13270+0xb4>)
 8005614:	4a14      	ldr	r2, [pc, #80]	; (8005668 <cmd_info.13270+0xb8>)
 8005616:	4b15      	ldr	r3, [pc, #84]	; (800566c <cmd_info.13270+0xbc>)
 8005618:	f7ff ffba 	bl	8005590 <chprintf.13255>
#endif
#endif
}
 800561c:	b002      	add	sp, #8
 800561e:	bd10      	pop	{r4, pc}
 8005620:	08006e4c 	.word	0x08006e4c
 8005624:	08006e9c 	.word	0x08006e9c
 8005628:	080072a0 	.word	0x080072a0
 800562c:	080072b4 	.word	0x080072b4
 8005630:	080072bc 	.word	0x080072bc
 8005634:	080072d0 	.word	0x080072d0
 8005638:	080072f0 	.word	0x080072f0
 800563c:	08007304 	.word	0x08007304
 8005640:	08007310 	.word	0x08007310
 8005644:	08007324 	.word	0x08007324
 8005648:	08007330 	.word	0x08007330
 800564c:	08007344 	.word	0x08007344
 8005650:	0800735c 	.word	0x0800735c
 8005654:	08007370 	.word	0x08007370
 8005658:	0800739c 	.word	0x0800739c
 800565c:	080073b0 	.word	0x080073b0
 8005660:	08007400 	.word	0x08007400
 8005664:	080073d8 	.word	0x080073d8
 8005668:	080073f0 	.word	0x080073f0
 800566c:	080073fc 	.word	0x080073fc

08005670 <cmd_systime.13262>:

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8005670:	2900      	cmp	r1, #0
 8005672:	dd03      	ble.n	800567c <cmd_systime.13262+0xc>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8005674:	4907      	ldr	r1, [pc, #28]	; (8005694 <cmd_systime.13262+0x24>)
 8005676:	4a08      	ldr	r2, [pc, #32]	; (8005698 <cmd_systime.13262+0x28>)
 8005678:	f7ff bf8a 	b.w	8005590 <chprintf.13255>
 800567c:	2320      	movs	r3, #32
 800567e:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8005682:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8005686:	2300      	movs	r3, #0
 8005688:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800568a:	f383 8811 	msr	BASEPRI, r3
  (void)argv;
  if (argc > 0) {
    usage(chp, "systime");
    return;
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 800568e:	4903      	ldr	r1, [pc, #12]	; (800569c <cmd_systime.13262+0x2c>)
 8005690:	f7ff bf7e 	b.w	8005590 <chprintf.13255>
 8005694:	08006e4c 	.word	0x08006e4c
 8005698:	08006ea4 	.word	0x08006ea4
 800569c:	0800740c 	.word	0x0800740c

080056a0 <getAktTemp>:

}

// retun back sensor temp value int.
int getAktTemp(int s) {
return currentTemp2[s-1];
 80056a0:	4b02      	ldr	r3, [pc, #8]	; (80056ac <getAktTemp+0xc>)
 80056a2:	3801      	subs	r0, #1
 80056a4:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]

}
 80056a8:	4770      	bx	lr
 80056aa:	bf00      	nop
 80056ac:	2000268c 	.word	0x2000268c

080056b0 <cmd_relay.16097>:
                chprintf(chp, "DEV_ID_int: --%d--\r\n",id);
    return 1;
    }
}

static void cmd_relay(BaseSequentialStream *chp, int argc, char *argv[]) {
 80056b0:	b510      	push	{r4, lr}

  uint8_t u[3];
  (void)argv;
  if (argc > 0) {
 80056b2:	2900      	cmp	r1, #0
                chprintf(chp, "DEV_ID_int: --%d--\r\n",id);
    return 1;
    }
}

static void cmd_relay(BaseSequentialStream *chp, int argc, char *argv[]) {
 80056b4:	b082      	sub	sp, #8
 80056b6:	4604      	mov	r4, r0

  uint8_t u[3];
  (void)argv;
  if (argc > 0) {
 80056b8:	dd04      	ble.n	80056c4 <cmd_relay.16097+0x14>
    chprintf(chp, "id\r\n\r");
 80056ba:	4917      	ldr	r1, [pc, #92]	; (8005718 <cmd_relay.16097+0x68>)
 80056bc:	f7ff fec0 	bl	8005440 <chprintf.16065>
                    chprintf(chp, "RELAY OFF\n\r");
                    }

               return 1;
    }
}
 80056c0:	b002      	add	sp, #8
 80056c2:	bd10      	pop	{r4, pc}
    chprintf(chp, "id\r\n\r");
    return;
  }
    while(true){
               //palSetPad(RELAY_PORT, RELAY_PIN);
               chprintf(chp, "RELAY STATES 0 V 1:\n\r",getAktTemp(1));
 80056c4:	2001      	movs	r0, #1
 80056c6:	f7ff ffeb 	bl	80056a0 <getAktTemp>
 80056ca:	4914      	ldr	r1, [pc, #80]	; (800571c <cmd_relay.16097+0x6c>)
 80056cc:	4602      	mov	r2, r0
 80056ce:	4620      	mov	r0, r4
 80056d0:	f7ff feb6 	bl	8005440 <chprintf.16065>

               chSequentialStreamRead(serial,&u,4);
 80056d4:	4b12      	ldr	r3, [pc, #72]	; (8005720 <cmd_relay.16097+0x70>)
 80056d6:	6818      	ldr	r0, [r3, #0]
 80056d8:	6803      	ldr	r3, [r0, #0]
 80056da:	a901      	add	r1, sp, #4
 80056dc:	685b      	ldr	r3, [r3, #4]
 80056de:	2204      	movs	r2, #4
 80056e0:	4798      	blx	r3
               chprintf(chp, "STATE: --%s--\n\n\r",u);
 80056e2:	aa01      	add	r2, sp, #4
 80056e4:	490f      	ldr	r1, [pc, #60]	; (8005724 <cmd_relay.16097+0x74>)
 80056e6:	4620      	mov	r0, r4
 80056e8:	f7ff feaa 	bl	8005440 <chprintf.16065>

                if(atoi(u)){
 80056ec:	a801      	add	r0, sp, #4
 80056ee:	f001 fa17 	bl	8006b20 <atoi>
                    palSetPad(RELAY_PORT, RELAY_PIN);
 80056f2:	4b0d      	ldr	r3, [pc, #52]	; (8005728 <cmd_relay.16097+0x78>)
               chprintf(chp, "RELAY STATES 0 V 1:\n\r",getAktTemp(1));

               chSequentialStreamRead(serial,&u,4);
               chprintf(chp, "STATE: --%s--\n\n\r",u);

                if(atoi(u)){
 80056f4:	b938      	cbnz	r0, 8005706 <cmd_relay.16097+0x56>
                    palSetPad(RELAY_PORT, RELAY_PIN);
                    chprintf(chp, "RELAY ON\n\r");
                }
                else{
                    palClearPad(RELAY_PORT, RELAY_PIN);
 80056f6:	2280      	movs	r2, #128	; 0x80
                    chprintf(chp, "RELAY OFF\n\r");
 80056f8:	490c      	ldr	r1, [pc, #48]	; (800572c <cmd_relay.16097+0x7c>)
                if(atoi(u)){
                    palSetPad(RELAY_PORT, RELAY_PIN);
                    chprintf(chp, "RELAY ON\n\r");
                }
                else{
                    palClearPad(RELAY_PORT, RELAY_PIN);
 80056fa:	835a      	strh	r2, [r3, #26]
                    chprintf(chp, "RELAY OFF\n\r");
 80056fc:	4620      	mov	r0, r4
 80056fe:	f7ff fe9f 	bl	8005440 <chprintf.16065>
                    }

               return 1;
    }
}
 8005702:	b002      	add	sp, #8
 8005704:	bd10      	pop	{r4, pc}

               chSequentialStreamRead(serial,&u,4);
               chprintf(chp, "STATE: --%s--\n\n\r",u);

                if(atoi(u)){
                    palSetPad(RELAY_PORT, RELAY_PIN);
 8005706:	2280      	movs	r2, #128	; 0x80
                    chprintf(chp, "RELAY ON\n\r");
 8005708:	4909      	ldr	r1, [pc, #36]	; (8005730 <cmd_relay.16097+0x80>)

               chSequentialStreamRead(serial,&u,4);
               chprintf(chp, "STATE: --%s--\n\n\r",u);

                if(atoi(u)){
                    palSetPad(RELAY_PORT, RELAY_PIN);
 800570a:	831a      	strh	r2, [r3, #24]
                    chprintf(chp, "RELAY ON\n\r");
 800570c:	4620      	mov	r0, r4
 800570e:	f7ff fe97 	bl	8005440 <chprintf.16065>
                    chprintf(chp, "RELAY OFF\n\r");
                    }

               return 1;
    }
}
 8005712:	b002      	add	sp, #8
 8005714:	bd10      	pop	{r4, pc}
 8005716:	bf00      	nop
 8005718:	08007414 	.word	0x08007414
 800571c:	0800741c 	.word	0x0800741c
 8005720:	200008c4 	.word	0x200008c4
 8005724:	08007434 	.word	0x08007434
 8005728:	40021000 	.word	0x40021000
 800572c:	08007454 	.word	0x08007454
 8005730:	08007448 	.word	0x08007448
	...

08005740 <OneWire_GetBusLine>:
	}
}

uint8_t OneWire_GetBusLine(int c)
{
switch (c-1){
 8005740:	3801      	subs	r0, #1
 8005742:	2801      	cmp	r0, #1
 8005744:	d00d      	beq.n	8005762 <OneWire_GetBusLine+0x22>
 8005746:	2802      	cmp	r0, #2
 8005748:	d006      	beq.n	8005758 <OneWire_GetBusLine+0x18>
 800574a:	b100      	cbz	r0, 800574e <OneWire_GetBusLine+0xe>
    break;
case 2:
    return palReadPad(DS18B20_3_GPIO, DS18B20_3_DATAPIN);
    break;
    }
}
 800574c:	4770      	bx	lr

uint8_t OneWire_GetBusLine(int c)
{
switch (c-1){
case 0 :
	return palReadPad(DS18B20_1_GPIO, DS18B20_1_DATAPIN);
 800574e:	4b07      	ldr	r3, [pc, #28]	; (800576c <OneWire_GetBusLine+0x2c>)
 8005750:	6918      	ldr	r0, [r3, #16]
 8005752:	f3c0 0080 	ubfx	r0, r0, #2, #1
 8005756:	4770      	bx	lr
    break;
case 1 :
    return palReadPad(DS18B20_2_GPIO, DS18B20_2_DATAPIN);
    break;
case 2:
    return palReadPad(DS18B20_3_GPIO, DS18B20_3_DATAPIN);
 8005758:	4b04      	ldr	r3, [pc, #16]	; (800576c <OneWire_GetBusLine+0x2c>)
 800575a:	6918      	ldr	r0, [r3, #16]
 800575c:	f3c0 1000 	ubfx	r0, r0, #4, #1
 8005760:	4770      	bx	lr
switch (c-1){
case 0 :
	return palReadPad(DS18B20_1_GPIO, DS18B20_1_DATAPIN);
    break;
case 1 :
    return palReadPad(DS18B20_2_GPIO, DS18B20_2_DATAPIN);
 8005762:	4b02      	ldr	r3, [pc, #8]	; (800576c <OneWire_GetBusLine+0x2c>)
 8005764:	6918      	ldr	r0, [r3, #16]
 8005766:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 800576a:	4770      	bx	lr
 800576c:	40021000 	.word	0x40021000

08005770 <OneWire_DataPinOutput>:
    }
}

void OneWire_DataPinOutput(int c)
{
    switch(c-1){
 8005770:	1e42      	subs	r2, r0, #1
 8005772:	2a01      	cmp	r2, #1
 8005774:	d00d      	beq.n	8005792 <OneWire_DataPinOutput+0x22>
 8005776:	2a02      	cmp	r2, #2
 8005778:	d006      	beq.n	8005788 <OneWire_DataPinOutput+0x18>
 800577a:	b102      	cbz	r2, 800577e <OneWire_DataPinOutput+0xe>
 800577c:	4770      	bx	lr
    case 0 :
        palSetPadMode(DS18B20_1_GPIO, DS18B20_1_DATAPIN, PAL_MODE_OUTPUT_PUSHPULL);
 800577e:	4807      	ldr	r0, [pc, #28]	; (800579c <OneWire_DataPinOutput+0x2c>)
 8005780:	2104      	movs	r1, #4
 8005782:	2201      	movs	r2, #1
 8005784:	f7fb bd6c 	b.w	8001260 <_pal_lld_setgroupmode>
    case 1 :
        palSetPadMode(DS18B20_2_GPIO, DS18B20_2_DATAPIN , PAL_MODE_OUTPUT_PUSHPULL);
    break;

    case 2 :
        palSetPadMode(DS18B20_3_GPIO, DS18B20_3_DATAPIN, PAL_MODE_OUTPUT_PUSHPULL);
 8005788:	4804      	ldr	r0, [pc, #16]	; (800579c <OneWire_DataPinOutput+0x2c>)
 800578a:	2110      	movs	r1, #16
 800578c:	2201      	movs	r2, #1
 800578e:	f7fb bd67 	b.w	8001260 <_pal_lld_setgroupmode>
    case 0 :
        palSetPadMode(DS18B20_1_GPIO, DS18B20_1_DATAPIN, PAL_MODE_OUTPUT_PUSHPULL);
    break;

    case 1 :
        palSetPadMode(DS18B20_2_GPIO, DS18B20_2_DATAPIN , PAL_MODE_OUTPUT_PUSHPULL);
 8005792:	4802      	ldr	r0, [pc, #8]	; (800579c <OneWire_DataPinOutput+0x2c>)
 8005794:	2108      	movs	r1, #8
 8005796:	f7fb bd63 	b.w	8001260 <_pal_lld_setgroupmode>
 800579a:	bf00      	nop
 800579c:	40021000 	.word	0x40021000

080057a0 <OneWire_SetBusLine.part.2.14391>:

void OneWire_SetBusLine(uint8_t state, uint8_t ch)
{
	if(state)
	{
        switch(ch-1){
 80057a0:	1e42      	subs	r2, r0, #1
 80057a2:	2a01      	cmp	r2, #1

    }
}


void OneWire_SetBusLine(uint8_t state, uint8_t ch)
 80057a4:	b510      	push	{r4, lr}
{
	if(state)
	{
        switch(ch-1){
 80057a6:	d014      	beq.n	80057d2 <OneWire_SetBusLine.part.2.14391+0x32>
 80057a8:	2a02      	cmp	r2, #2
 80057aa:	d009      	beq.n	80057c0 <OneWire_SetBusLine.part.2.14391+0x20>
 80057ac:	b102      	cbz	r2, 80057b0 <OneWire_SetBusLine.part.2.14391+0x10>
 80057ae:	bd10      	pop	{r4, pc}
            case 0 :{
                palSetPadMode(DS18B20_1_GPIO, DS18B20_1_DATAPIN, PAL_MODE_INPUT);
 80057b0:	4c0c      	ldr	r4, [pc, #48]	; (80057e4 <OneWire_SetBusLine.part.2.14391+0x44>)
 80057b2:	2104      	movs	r1, #4
 80057b4:	4620      	mov	r0, r4
 80057b6:	f7fb fd53 	bl	8001260 <_pal_lld_setgroupmode>
                palWritePad(DS18B20_1_GPIO, DS18B20_1_DATAPIN, 1);
 80057ba:	2304      	movs	r3, #4
 80057bc:	61a3      	str	r3, [r4, #24]
 80057be:	bd10      	pop	{r4, pc}
                palWritePad(DS18B20_2_GPIO, DS18B20_2_DATAPIN, 1);
            }
            break;

            case 2 :{
                palSetPadMode(DS18B20_3_GPIO, DS18B20_3_DATAPIN, PAL_MODE_INPUT);
 80057c0:	4c08      	ldr	r4, [pc, #32]	; (80057e4 <OneWire_SetBusLine.part.2.14391+0x44>)
 80057c2:	2110      	movs	r1, #16
 80057c4:	4620      	mov	r0, r4
 80057c6:	2200      	movs	r2, #0
 80057c8:	f7fb fd4a 	bl	8001260 <_pal_lld_setgroupmode>
                palWritePad(DS18B20_3_GPIO, DS18B20_3_DATAPIN, 1);
 80057cc:	2310      	movs	r3, #16
 80057ce:	61a3      	str	r3, [r4, #24]
 80057d0:	bd10      	pop	{r4, pc}
                palWritePad(DS18B20_1_GPIO, DS18B20_1_DATAPIN, 1);
            }
            break;

            case 1 :{
                palSetPadMode(DS18B20_2_GPIO, DS18B20_2_DATAPIN , PAL_MODE_INPUT);
 80057d2:	4c04      	ldr	r4, [pc, #16]	; (80057e4 <OneWire_SetBusLine.part.2.14391+0x44>)
 80057d4:	2108      	movs	r1, #8
 80057d6:	4620      	mov	r0, r4
 80057d8:	2200      	movs	r2, #0
 80057da:	f7fb fd41 	bl	8001260 <_pal_lld_setgroupmode>
                palWritePad(DS18B20_2_GPIO, DS18B20_2_DATAPIN, 1);
 80057de:	2308      	movs	r3, #8
 80057e0:	61a3      	str	r3, [r4, #24]
 80057e2:	bd10      	pop	{r4, pc}
 80057e4:	40021000 	.word	0x40021000
	...

080057f0 <OneWire_SetBusLine>:
    }
}


void OneWire_SetBusLine(uint8_t state, uint8_t ch)
{
 80057f0:	b510      	push	{r4, lr}
	if(state)
 80057f2:	b120      	cbz	r0, 80057fe <OneWire_SetBusLine+0xe>
 80057f4:	4608      	mov	r0, r1
                palWritePad(DS18B20_3_GPIO, DS18B20_3_DATAPIN, 0);
            }
            break;
        }
	}
}
 80057f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80057fa:	f7ff bfd1 	b.w	80057a0 <OneWire_SetBusLine.part.2.14391>
            break;
        }
	}
	else
	{
		switch(ch-1){
 80057fe:	1e4a      	subs	r2, r1, #1
 8005800:	2a01      	cmp	r2, #1
 8005802:	d003      	beq.n	800580c <OneWire_SetBusLine+0x1c>
 8005804:	2a02      	cmp	r2, #2
 8005806:	d014      	beq.n	8005832 <OneWire_SetBusLine+0x42>
 8005808:	b14a      	cbz	r2, 800581e <OneWire_SetBusLine+0x2e>
 800580a:	bd10      	pop	{r4, pc}
                palWritePad(DS18B20_1_GPIO, DS18B20_1_DATAPIN, 0);
            }
            break;

            case 1 :{
                palSetPadMode(DS18B20_2_GPIO, DS18B20_2_DATAPIN, PAL_MODE_OUTPUT_PUSHPULL);
 800580c:	4c0e      	ldr	r4, [pc, #56]	; (8005848 <OneWire_SetBusLine+0x58>)
 800580e:	2108      	movs	r1, #8
 8005810:	4620      	mov	r0, r4
 8005812:	f7fb fd25 	bl	8001260 <_pal_lld_setgroupmode>
                palWritePad(DS18B20_2_GPIO, DS18B20_2_DATAPIN, 0);
 8005816:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 800581a:	61a3      	str	r3, [r4, #24]
 800581c:	bd10      	pop	{r4, pc}
	}
	else
	{
		switch(ch-1){
            case 0 :{
                palSetPadMode(DS18B20_1_GPIO, DS18B20_1_DATAPIN, PAL_MODE_OUTPUT_PUSHPULL);
 800581e:	4c0a      	ldr	r4, [pc, #40]	; (8005848 <OneWire_SetBusLine+0x58>)
 8005820:	2104      	movs	r1, #4
 8005822:	4620      	mov	r0, r4
 8005824:	2201      	movs	r2, #1
 8005826:	f7fb fd1b 	bl	8001260 <_pal_lld_setgroupmode>
                palWritePad(DS18B20_1_GPIO, DS18B20_1_DATAPIN, 0);
 800582a:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 800582e:	61a3      	str	r3, [r4, #24]
 8005830:	bd10      	pop	{r4, pc}
                palWritePad(DS18B20_2_GPIO, DS18B20_2_DATAPIN, 0);
            }
            break;

            case 2 :{
                palSetPadMode(DS18B20_3_GPIO, DS18B20_3_DATAPIN, PAL_MODE_OUTPUT_PUSHPULL);
 8005832:	4c05      	ldr	r4, [pc, #20]	; (8005848 <OneWire_SetBusLine+0x58>)
 8005834:	2110      	movs	r1, #16
 8005836:	4620      	mov	r0, r4
 8005838:	2201      	movs	r2, #1
 800583a:	f7fb fd11 	bl	8001260 <_pal_lld_setgroupmode>
                palWritePad(DS18B20_3_GPIO, DS18B20_3_DATAPIN, 0);
 800583e:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
 8005842:	61a3      	str	r3, [r4, #24]
 8005844:	bd10      	pop	{r4, pc}
 8005846:	bf00      	nop
 8005848:	40021000 	.word	0x40021000
 800584c:	00000000 	.word	0x00000000

08005850 <shellInit>:
 8005850:	4b01      	ldr	r3, [pc, #4]	; (8005858 <shellInit+0x8>)
 8005852:	601b      	str	r3, [r3, #0]
 8005854:	4770      	bx	lr
 8005856:	bf00      	nop
 8005858:	20001d7c 	.word	0x20001d7c
 800585c:	00000000 	.word	0x00000000

08005860 <pwmEnableChannel>:
 *
 * @api
 */
void pwmEnableChannel(PWMDriver *pwmp,
                      pwmchannel_t channel,
                      pwmcnt_t width) {
 8005860:	b470      	push	{r4, r5, r6}
 8005862:	2320      	movs	r3, #32
 8005864:	f383 8811 	msr	BASEPRI, r3
                            pwmchannel_t channel,
                            pwmcnt_t width) {

  /* Changing channel duty cycle on the fly.*/
#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = width;
 8005868:	6984      	ldr	r4, [r0, #24]

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");

  pwmEnableChannelI(pwmp, channel, width);
 800586a:	68c3      	ldr	r3, [r0, #12]
 800586c:	f101 050c 	add.w	r5, r1, #12
 8005870:	2601      	movs	r6, #1
 8005872:	fa06 f101 	lsl.w	r1, r6, r1
 8005876:	eb04 0485 	add.w	r4, r4, r5, lsl #2
 800587a:	430b      	orrs	r3, r1
 800587c:	60c3      	str	r3, [r0, #12]
 800587e:	2300      	movs	r3, #0
 8005880:	6062      	str	r2, [r4, #4]
 8005882:	f383 8811 	msr	BASEPRI, r3

  osalSysUnlock();
}
 8005886:	bc70      	pop	{r4, r5, r6}
 8005888:	4770      	bx	lr
 800588a:	bf00      	nop
 800588c:	0000      	movs	r0, r0
	...

08005890 <usbStartTransmitI>:
 * @retval false        Operation started successfully.
 * @retval true         Endpoint busy, operation not started.
 *
 * @iclass
 */
bool usbStartTransmitI(USBDriver *usbp, usbep_t ep) {
 8005890:	b4f0      	push	{r4, r5, r6, r7}

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 8005892:	2401      	movs	r4, #1
 8005894:	fa04 f501 	lsl.w	r5, r4, r1
 8005898:	8903      	ldrh	r3, [r0, #8]
 800589a:	b2aa      	uxth	r2, r5
 800589c:	ea12 0703 	ands.w	r7, r2, r3
 80058a0:	d002      	beq.n	80058a8 <usbStartTransmitI+0x18>
    return true;
 80058a2:	4620      	mov	r0, r4
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_in(usbp, ep);
  return false;
}
 80058a4:	bcf0      	pop	{r4, r5, r6, r7}
 80058a6:	4770      	bx	lr
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 80058a8:	6d06      	ldr	r6, [r0, #80]	; 0x50
 80058aa:	eb06 1141 	add.w	r1, r6, r1, lsl #5

  if (usbGetTransmitStatusI(usbp, ep)) {
    return true;
  }

  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80058ae:	4313      	orrs	r3, r2
 80058b0:	f8d1 4900 	ldr.w	r4, [r1, #2304]	; 0x900
 80058b4:	8103      	strh	r3, [r0, #8]
 80058b6:	f044 4304 	orr.w	r3, r4, #2214592512	; 0x84000000
 80058ba:	f8c1 3900 	str.w	r3, [r1, #2304]	; 0x900
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 80058be:	f8d6 3834 	ldr.w	r3, [r6, #2100]	; 0x834
 80058c2:	431d      	orrs	r5, r3
  usb_lld_start_in(usbp, ep);
  return false;
 80058c4:	4638      	mov	r0, r7
 80058c6:	f8c6 5834 	str.w	r5, [r6, #2100]	; 0x834
}
 80058ca:	bcf0      	pop	{r4, r5, r6, r7}
 80058cc:	4770      	bx	lr
 80058ce:	bf00      	nop

080058d0 <usbStartReceiveI>:
 * @retval false        Operation started successfully.
 * @retval true         Endpoint busy, operation not started.
 *
 * @iclass
 */
bool usbStartReceiveI(USBDriver *usbp, usbep_t ep) {
 80058d0:	b430      	push	{r4, r5}

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 80058d2:	2401      	movs	r4, #1
 80058d4:	fa04 f201 	lsl.w	r2, r4, r1
 80058d8:	8943      	ldrh	r3, [r0, #10]
 80058da:	b292      	uxth	r2, r2
 80058dc:	ea12 0503 	ands.w	r5, r2, r3
 80058e0:	d002      	beq.n	80058e8 <usbStartReceiveI+0x18>
    return true;
 80058e2:	4620      	mov	r0, r4
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
  usb_lld_start_out(usbp, ep);
  return false;
}
 80058e4:	bc30      	pop	{r4, r5}
 80058e6:	4770      	bx	lr
 80058e8:	6d04      	ldr	r4, [r0, #80]	; 0x50
 80058ea:	eb04 1141 	add.w	r1, r4, r1, lsl #5

  if (usbGetReceiveStatusI(usbp, ep)) {
    return true;
  }

  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 80058ee:	4313      	orrs	r3, r2
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
 80058f0:	f8d1 4b00 	ldr.w	r4, [r1, #2816]	; 0xb00
 80058f4:	8143      	strh	r3, [r0, #10]
 80058f6:	f044 6380 	orr.w	r3, r4, #67108864	; 0x4000000
  usb_lld_start_out(usbp, ep);
  return false;
 80058fa:	4628      	mov	r0, r5
 80058fc:	f8c1 3b00 	str.w	r3, [r1, #2816]	; 0xb00
}
 8005900:	bc30      	pop	{r4, r5}
 8005902:	4770      	bx	lr
	...

08005910 <usb_lld_prepare_transmit>:
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8005910:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_transmit(USBDriver *usbp, usbep_t ep) {
 8005914:	b430      	push	{r4, r5}
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8005916:	68dc      	ldr	r4, [r3, #12]
 8005918:	6962      	ldr	r2, [r4, #20]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800591a:	6853      	ldr	r3, [r2, #4]
 800591c:	6113      	str	r3, [r2, #16]
  if (isp->txsize == 0) {
 800591e:	b1a3      	cbz	r3, 800594a <usb_lld_prepare_transmit+0x3a>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
 8005920:	b169      	cbz	r1, 800593e <usb_lld_prepare_transmit+0x2e>
 8005922:	1e5d      	subs	r5, r3, #1
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8005924:	8a22      	ldrh	r2, [r4, #16]
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 8005926:	6d00      	ldr	r0, [r0, #80]	; 0x50
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 8005928:	18ac      	adds	r4, r5, r2
 800592a:	fbb4 f2f2 	udiv	r2, r4, r2
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
 800592e:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 8005932:	ea43 43c2 	orr.w	r3, r3, r2, lsl #19
 8005936:	f8c1 3910 	str.w	r3, [r1, #2320]	; 0x910
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 800593a:	bc30      	pop	{r4, r5}
 800593c:	4770      	bx	lr
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
  }
  else {
    if ((ep == 0) && (isp->txsize  > EP0_MAX_INSIZE))
 800593e:	2b40      	cmp	r3, #64	; 0x40
 8005940:	d9ef      	bls.n	8005922 <usb_lld_prepare_transmit+0x12>
      isp->txsize = EP0_MAX_INSIZE;
 8005942:	2340      	movs	r3, #64	; 0x40
 8005944:	6053      	str	r3, [r2, #4]
 8005946:	253f      	movs	r5, #63	; 0x3f
 8005948:	e7ec      	b.n	8005924 <usb_lld_prepare_transmit+0x14>

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
  if (isp->txsize == 0) {
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 800594a:	6d03      	ldr	r3, [r0, #80]	; 0x50
 800594c:	eb03 1141 	add.w	r1, r3, r1, lsl #5
 8005950:	f44f 2300 	mov.w	r3, #524288	; 0x80000
 8005954:	f8c1 3910 	str.w	r3, [r1, #2320]	; 0x910
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(pcnt) |
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }
}
 8005958:	bc30      	pop	{r4, r5}
 800595a:	4770      	bx	lr
 800595c:	0000      	movs	r0, r0
	...

08005960 <usb_lld_prepare_receive>:
 *
 * @notapi
 */
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
  uint32_t pcnt;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8005960:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_prepare_receive(USBDriver *usbp, usbep_t ep) {
 8005964:	b430      	push	{r4, r5}
  uint32_t pcnt;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8005966:	68dc      	ldr	r4, [r3, #12]
 8005968:	69a2      	ldr	r2, [r4, #24]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800596a:	6853      	ldr	r3, [r2, #4]
 800596c:	6113      	str	r3, [r2, #16]
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
 800596e:	b931      	cbnz	r1, 800597e <usb_lld_prepare_receive+0x1e>
 8005970:	2b40      	cmp	r3, #64	; 0x40
 8005972:	d904      	bls.n	800597e <usb_lld_prepare_receive+0x1e>
      osp->rxsize = EP0_MAX_OUTSIZE;
 8005974:	2540      	movs	r5, #64	; 0x40
 8005976:	6055      	str	r5, [r2, #4]
 8005978:	4b09      	ldr	r3, [pc, #36]	; (80059a0 <usb_lld_prepare_receive+0x40>)
 800597a:	253f      	movs	r5, #63	; 0x3f
 800597c:	e002      	b.n	8005984 <usb_lld_prepare_receive+0x24>
 800597e:	1e5d      	subs	r5, r3, #1
 8005980:	f043 43c0 	orr.w	r3, r3, #1610612736	; 0x60000000

  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 8005984:	8a62      	ldrh	r2, [r4, #18]
         usbp->epc[ep]->out_maxsize;
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8005986:	6d00      	ldr	r0, [r0, #80]	; 0x50
  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
  if ((ep == 0) && (osp->rxsize  > EP0_MAX_OUTSIZE))
      osp->rxsize = EP0_MAX_OUTSIZE;

  pcnt = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1) /
 8005988:	18ac      	adds	r4, r5, r2
 800598a:	fbb4 f2f2 	udiv	r2, r4, r2
         usbp->epc[ep]->out_maxsize;
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 800598e:	eb00 1141 	add.w	r1, r0, r1, lsl #5
 8005992:	ea43 42c2 	orr.w	r2, r3, r2, lsl #19
 8005996:	f8c1 2b10 	str.w	r2, [r1, #2832]	; 0xb10
                               DOEPTSIZ_XFRSIZ(osp->rxsize);

}
 800599a:	bc30      	pop	{r4, r5}
 800599c:	4770      	bx	lr
 800599e:	bf00      	nop
 80059a0:	60000040 	.word	0x60000040
	...

080059b0 <inotify.8142>:
/**
 * @brief   Notification of data removed from the input queue.
 *
 * @param[in] qp        the queue pointer.
 */
static void inotify(io_queue_t *qp) {
 80059b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size_t n, maxsize;
  SerialUSBDriver *sdup = qGetLink(qp);
 80059b2:	6a04      	ldr	r4, [r0, #32]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 80059b4:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 80059b8:	6813      	ldr	r3, [r2, #0]
 80059ba:	7819      	ldrb	r1, [r3, #0]
 80059bc:	2904      	cmp	r1, #4
 80059be:	d000      	beq.n	80059c2 <inotify.8142+0x12>
 80059c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80059c2:	7a21      	ldrb	r1, [r4, #8]
 80059c4:	2902      	cmp	r1, #2
 80059c6:	d1fb      	bne.n	80059c0 <inotify.8142+0x10>
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 80059c8:	7951      	ldrb	r1, [r2, #5]
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 80059ca:	895a      	ldrh	r2, [r3, #10]
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 80059cc:	eb03 0381 	add.w	r3, r3, r1, lsl #2
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 80059d0:	2501      	movs	r5, #1
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 80059d2:	68d8      	ldr	r0, [r3, #12]
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 80059d4:	fa05 f301 	lsl.w	r3, r5, r1
 80059d8:	401a      	ands	r2, r3
  }

  /* If there is in the queue enough space to hold at least one packet and
     a transaction is not yet started then a new transaction is started for
     the available space.*/
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
 80059da:	8a46      	ldrh	r6, [r0, #18]
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
 80059dc:	d1f0      	bne.n	80059c0 <inotify.8142+0x10>
 */
static inline size_t chIQGetEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(iqp) - chQSpaceI(iqp));
 80059de:	69e0      	ldr	r0, [r4, #28]
 80059e0:	69a1      	ldr	r1, [r4, #24]
 80059e2:	6967      	ldr	r7, [r4, #20]
 80059e4:	1a43      	subs	r3, r0, r1
 80059e6:	1bdb      	subs	r3, r3, r7
    if ((n = iqGetEmptyI(&sdup->iqueue)) >= maxsize) {
 80059e8:	429e      	cmp	r6, r3
 80059ea:	d8e9      	bhi.n	80059c0 <inotify.8142+0x10>
 80059ec:	f382 8811 	msr	BASEPRI, r2
      osalSysUnlock();

      n = (n / maxsize) * maxsize;
      usbPrepareQueuedReceive(sdup->config->usbp,
 80059f0:	f8d4 1254 	ldr.w	r1, [r4, #596]	; 0x254
 80059f4:	6808      	ldr	r0, [r1, #0]
 80059f6:	7949      	ldrb	r1, [r1, #5]
 *
 * @special
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80059f8:	eb00 0781 	add.w	r7, r0, r1, lsl #2
  maxsize = sdup->config->usbp->epc[sdup->config->bulk_out]->out_maxsize;
  if (!usbGetReceiveStatusI(sdup->config->usbp, sdup->config->bulk_out)) {
    if ((n = iqGetEmptyI(&sdup->iqueue)) >= maxsize) {
      osalSysUnlock();

      n = (n / maxsize) * maxsize;
 80059fc:	fbb3 f3f6 	udiv	r3, r3, r6
 8005a00:	68ff      	ldr	r7, [r7, #12]
 8005a02:	69bf      	ldr	r7, [r7, #24]
 8005a04:	fb06 f603 	mul.w	r6, r6, r3
      usbPrepareQueuedReceive(sdup->config->usbp,
 8005a08:	f104 030c 	add.w	r3, r4, #12

  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
 8005a0c:	60fb      	str	r3, [r7, #12]
  osp->rxsize             = n;
 8005a0e:	607e      	str	r6, [r7, #4]
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
 8005a10:	703d      	strb	r5, [r7, #0]
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 8005a12:	60ba      	str	r2, [r7, #8]

  usb_lld_prepare_receive(usbp, ep);
 8005a14:	f7ff ffa4 	bl	8005960 <usb_lld_prepare_receive>
 8005a18:	2320      	movs	r3, #32
 8005a1a:	f383 8811 	msr	BASEPRI, r3
                              sdup->config->bulk_out,
                              &sdup->iqueue, n);

      osalSysLock();
      (void) usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out);
 8005a1e:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 8005a22:	6818      	ldr	r0, [r3, #0]
 8005a24:	7959      	ldrb	r1, [r3, #5]
    }
  }
}
 8005a26:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      usbPrepareQueuedReceive(sdup->config->usbp,
                              sdup->config->bulk_out,
                              &sdup->iqueue, n);

      osalSysLock();
      (void) usbStartReceiveI(sdup->config->usbp, sdup->config->bulk_out);
 8005a2a:	f7ff bf51 	b.w	80058d0 <usbStartReceiveI>
 8005a2e:	bf00      	nop

08005a30 <otg_epout_handler.10080>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8005a30:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  stm32_otg_t *otgp = usbp->otg;
 8005a32:	6d07      	ldr	r7, [r0, #80]	; 0x50
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8005a34:	eb07 1341 	add.w	r3, r7, r1, lsl #5
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8005a38:	4605      	mov	r5, r0
  stm32_otg_t *otgp = usbp->otg;
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8005a3a:	f8d3 4b08 	ldr.w	r4, [r3, #2824]	; 0xb08

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 8005a3e:	f8c3 4b08 	str.w	r4, [r3, #2824]	; 0xb08

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8005a42:	0722      	lsls	r2, r4, #28
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8005a44:	460e      	mov	r6, r1
  uint32_t epint = otgp->oe[ep].DOEPINT;

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 8005a46:	d503      	bpl.n	8005a50 <otg_epout_handler.10080+0x20>
 8005a48:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 8005a4c:	071b      	lsls	r3, r3, #28
 8005a4e:	d419      	bmi.n	8005a84 <otg_epout_handler.10080+0x54>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);

  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 8005a50:	07e2      	lsls	r2, r4, #31
 8005a52:	d516      	bpl.n	8005a82 <otg_epout_handler.10080+0x52>
 8005a54:	f8d7 3814 	ldr.w	r3, [r7, #2068]	; 0x814
 8005a58:	07db      	lsls	r3, r3, #31
 8005a5a:	d512      	bpl.n	8005a82 <otg_epout_handler.10080+0x52>
    /* Receive transfer complete.*/
    USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 8005a5c:	eb05 0386 	add.w	r3, r5, r6, lsl #2
 8005a60:	68da      	ldr	r2, [r3, #12]
 8005a62:	6993      	ldr	r3, [r2, #24]

    if (osp->rxsize < osp->totsize) {
 8005a64:	6859      	ldr	r1, [r3, #4]
 8005a66:	6918      	ldr	r0, [r3, #16]
 8005a68:	4281      	cmp	r1, r0
 8005a6a:	d311      	bcc.n	8005a90 <otg_epout_handler.10080+0x60>
      usb_lld_start_out(usbp, ep);
      chSysUnlockFromISR();
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 8005a6c:	8969      	ldrh	r1, [r5, #10]
 8005a6e:	68d3      	ldr	r3, [r2, #12]
 8005a70:	2001      	movs	r0, #1
 8005a72:	fa00 f206 	lsl.w	r2, r0, r6
 8005a76:	ea21 0202 	bic.w	r2, r1, r2
 8005a7a:	816a      	strh	r2, [r5, #10]
 8005a7c:	4631      	mov	r1, r6
 8005a7e:	4628      	mov	r0, r5
 8005a80:	4798      	blx	r3
 8005a82:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  otgp->oe[ep].DOEPINT = epint;

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 8005a84:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 8005a88:	68db      	ldr	r3, [r3, #12]
 8005a8a:	685b      	ldr	r3, [r3, #4]
 8005a8c:	4798      	blx	r3
 8005a8e:	e7df      	b.n	8005a50 <otg_epout_handler.10080+0x20>

    if (osp->rxsize < osp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8005a90:	1a41      	subs	r1, r0, r1
      osp->rxcnt  = 0;
 8005a92:	2400      	movs	r4, #0

    if (osp->rxsize < osp->totsize) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8005a94:	6059      	str	r1, [r3, #4]
      osp->rxcnt  = 0;
 8005a96:	609c      	str	r4, [r3, #8]
      usb_lld_prepare_receive(usbp, ep);
 8005a98:	4628      	mov	r0, r5
 8005a9a:	4631      	mov	r1, r6
 8005a9c:	f7ff ff60 	bl	8005960 <usb_lld_prepare_receive>
 8005aa0:	2320      	movs	r3, #32
 8005aa2:	f383 8811 	msr	BASEPRI, r3
 8005aa6:	6d2b      	ldr	r3, [r5, #80]	; 0x50
 8005aa8:	eb03 1646 	add.w	r6, r3, r6, lsl #5
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_CNAK;
 8005aac:	f8d6 3b00 	ldr.w	r3, [r6, #2816]	; 0xb00
 8005ab0:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8005ab4:	f8c6 3b00 	str.w	r3, [r6, #2816]	; 0xb00
 8005ab8:	f384 8811 	msr	BASEPRI, r4
 8005abc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005abe:	bf00      	nop

08005ac0 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8005ac0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005ac4:	4607      	mov	r7, r0
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  if (epcp->in_state != NULL) {
 8005ac6:	6950      	ldr	r0, [r2, #20]
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8005ac8:	4614      	mov	r4, r2
 8005aca:	460e      	mov	r6, r1
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  if (epcp->in_state != NULL) {
 8005acc:	b118      	cbz	r0, 8005ad6 <usbInitEndpointI+0x16>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8005ace:	2100      	movs	r1, #0
 8005ad0:	2214      	movs	r2, #20
 8005ad2:	f000 ff35 	bl	8006940 <memset>
  }
  if (epcp->out_state != NULL) {
 8005ad6:	69a0      	ldr	r0, [r4, #24]
 8005ad8:	b118      	cbz	r0, 8005ae2 <usbInitEndpointI+0x22>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8005ada:	2100      	movs	r1, #0
 8005adc:	2214      	movs	r2, #20
 8005ade:	f000 ff2f 	bl	8006940 <memset>
 8005ae2:	fa0f fa86 	sxth.w	sl, r6
 8005ae6:	eb07 088a 	add.w	r8, r7, sl, lsl #2
  }

  usbp->epc[ep] = epcp;
 8005aea:	f8c8 400c 	str.w	r4, [r8, #12]
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8005aee:	6823      	ldr	r3, [r4, #0]
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 8005af0:	6d3d      	ldr	r5, [r7, #80]	; 0x50

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 8005af2:	f003 0303 	and.w	r3, r3, #3
 8005af6:	2b02      	cmp	r3, #2
 8005af8:	d058      	beq.n	8005bac <usbInitEndpointI+0xec>
 8005afa:	2b03      	cmp	r3, #3
 8005afc:	d059      	beq.n	8005bb2 <usbInitEndpointI+0xf2>
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8005afe:	494a      	ldr	r1, [pc, #296]	; (8005c28 <usbInitEndpointI+0x168>)
 8005b00:	4a4a      	ldr	r2, [pc, #296]	; (8005c2c <usbInitEndpointI+0x16c>)
 8005b02:	2b01      	cmp	r3, #1
 8005b04:	bf0c      	ite	eq
 8005b06:	4689      	moveq	r9, r1
 8005b08:	4691      	movne	r9, r2
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 8005b0a:	0172      	lsls	r2, r6, #5
  if (usbp->epc[ep]->out_cb != NULL) {
 8005b0c:	68e3      	ldr	r3, [r4, #12]
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 8005b0e:	18a9      	adds	r1, r5, r2
 8005b10:	2000      	movs	r0, #0
 8005b12:	f8c1 0b10 	str.w	r0, [r1, #2832]	; 0xb10
  if (usbp->epc[ep]->out_cb != NULL) {
 8005b16:	2b00      	cmp	r3, #0
 8005b18:	d072      	beq.n	8005c00 <usbInitEndpointI+0x140>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8005b1a:	8a61      	ldrh	r1, [r4, #18]
 8005b1c:	f106 0358 	add.w	r3, r6, #88	; 0x58
 8005b20:	015b      	lsls	r3, r3, #5
 8005b22:	ea49 0101 	orr.w	r1, r9, r1
 8005b26:	50e9      	str	r1, [r5, r3]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8005b28:	2001      	movs	r0, #1
 8005b2a:	f8d5 181c 	ldr.w	r1, [r5, #2076]	; 0x81c
 8005b2e:	f106 0310 	add.w	r3, r6, #16
 8005b32:	fa00 f303 	lsl.w	r3, r0, r3
 8005b36:	430b      	orrs	r3, r1
 8005b38:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 8005b3c:	442a      	add	r2, r5
  if (usbp->epc[ep]->in_cb != NULL) {
 8005b3e:	68a3      	ldr	r3, [r4, #8]
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 8005b40:	2100      	movs	r1, #0
 8005b42:	f8c2 1910 	str.w	r1, [r2, #2320]	; 0x910
  if (usbp->epc[ep]->in_cb != NULL) {
 8005b46:	2b00      	cmp	r3, #0
 8005b48:	d036      	beq.n	8005bb8 <usbInitEndpointI+0xf8>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
 8005b4a:	8ba3      	ldrh	r3, [r4, #28]

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8005b4c:	8a22      	ldrh	r2, [r4, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 8005b4e:	2b01      	cmp	r3, #1

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 8005b50:	ea4f 0292 	mov.w	r2, r2, lsr #2
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
 8005b54:	bf88      	it	hi
 8005b56:	435a      	mulhi	r2, r3
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8005b58:	f106 013f 	add.w	r1, r6, #63	; 0x3f
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
 8005b5c:	6dbb      	ldr	r3, [r7, #88]	; 0x58
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8005b5e:	eb05 0181 	add.w	r1, r5, r1, lsl #2
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8005b62:	18d0      	adds	r0, r2, r3
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8005b64:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
  uint32_t next;

  next = usbp->pmnext;
  usbp->pmnext += size;
 8005b68:	65b8      	str	r0, [r7, #88]	; 0x58
  if (usbp->epc[ep]->in_cb != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 8005b6a:	604a      	str	r2, [r1, #4]
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8005b6c:	6d3a      	ldr	r2, [r7, #80]	; 0x50
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8005b6e:	01b3      	lsls	r3, r6, #6
 8005b70:	f043 0320 	orr.w	r3, r3, #32
 8005b74:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8005b76:	6913      	ldr	r3, [r2, #16]
 8005b78:	0699      	lsls	r1, r3, #26
 8005b7a:	d4fc      	bmi.n	8005b76 <usbInitEndpointI+0xb6>
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {

  chSysPolledDelayX(cycles);
 8005b7c:	200c      	movs	r0, #12
 8005b7e:	f7fc fa67 	bl	8002050 <chSysPolledDelayX>
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 8005b82:	f8d8 300c 	ldr.w	r3, [r8, #12]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 8005b86:	8a1b      	ldrh	r3, [r3, #16]
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8005b88:	f106 0248 	add.w	r2, r6, #72	; 0x48
 8005b8c:	ea43 5386 	orr.w	r3, r3, r6, lsl #22
 8005b90:	0152      	lsls	r2, r2, #5
                           DIEPCTL_TXFNUM(ep) |
 8005b92:	ea43 0309 	orr.w	r3, r3, r9
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8005b96:	50ab      	str	r3, [r5, r2]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8005b98:	2201      	movs	r2, #1
 8005b9a:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
 8005b9e:	fa02 f606 	lsl.w	r6, r2, r6
 8005ba2:	431e      	orrs	r6, r3
 8005ba4:	f8c5 681c 	str.w	r6, [r5, #2076]	; 0x81c
 8005ba8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    break;
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
    break;
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 8005bac:	f8df 9084 	ldr.w	r9, [pc, #132]	; 8005c34 <usbInitEndpointI+0x174>
 8005bb0:	e7ab      	b.n	8005b0a <usbInitEndpointI+0x4a>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8005bb2:	f8df 9084 	ldr.w	r9, [pc, #132]	; 8005c38 <usbInitEndpointI+0x178>
 8005bb6:	e7a8      	b.n	8005b0a <usbInitEndpointI+0x4a>
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 8005bb8:	f106 033f 	add.w	r3, r6, #63	; 0x3f
 8005bbc:	eb05 0383 	add.w	r3, r5, r3, lsl #2
 8005bc0:	4a1b      	ldr	r2, [pc, #108]	; (8005c30 <usbInitEndpointI+0x170>)
 8005bc2:	605a      	str	r2, [r3, #4]
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 8005bc4:	6d3a      	ldr	r2, [r7, #80]	; 0x50
}

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
  stm32_otg_t *otgp = usbp->otg;

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 8005bc6:	01b3      	lsls	r3, r6, #6
 8005bc8:	f043 0320 	orr.w	r3, r3, #32
 8005bcc:	6113      	str	r3, [r2, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 8005bce:	6913      	ldr	r3, [r2, #16]
 8005bd0:	069b      	lsls	r3, r3, #26
 8005bd2:	d4fc      	bmi.n	8005bce <usbInitEndpointI+0x10e>
 8005bd4:	eb05 1a4a 	add.w	sl, r5, sl, lsl #5
 8005bd8:	200c      	movs	r0, #12
 8005bda:	f7fc fa39 	bl	8002050 <chSysPolledDelayX>
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 8005bde:	f8da 3900 	ldr.w	r3, [sl, #2304]	; 0x900
 8005be2:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8005be6:	f8ca 3900 	str.w	r3, [sl, #2304]	; 0x900
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 8005bea:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
 8005bee:	2201      	movs	r2, #1
 8005bf0:	fa02 f606 	lsl.w	r6, r2, r6
 8005bf4:	ea23 0306 	bic.w	r3, r3, r6
 8005bf8:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
 8005bfc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005c00:	eb05 134a 	add.w	r3, r5, sl, lsl #5
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8005c04:	f106 0110 	add.w	r1, r6, #16
  if (usbp->epc[ep]->out_cb != NULL) {
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8005c08:	f8d3 0b00 	ldr.w	r0, [r3, #2816]	; 0xb00
 8005c0c:	f420 4000 	bic.w	r0, r0, #32768	; 0x8000
 8005c10:	f8c3 0b00 	str.w	r0, [r3, #2816]	; 0xb00
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 8005c14:	f8d5 381c 	ldr.w	r3, [r5, #2076]	; 0x81c
 8005c18:	2001      	movs	r0, #1
 8005c1a:	fa00 f101 	lsl.w	r1, r0, r1
 8005c1e:	ea23 0301 	bic.w	r3, r3, r1
 8005c22:	f8c5 381c 	str.w	r3, [r5, #2076]	; 0x81c
 8005c26:	e789      	b.n	8005b3c <usbInitEndpointI+0x7c>
 8005c28:	10048000 	.word	0x10048000
 8005c2c:	10008000 	.word	0x10008000
 8005c30:	02000400 	.word	0x02000400
 8005c34:	10088000 	.word	0x10088000
 8005c38:	100c8000 	.word	0x100c8000
 8005c3c:	00000000 	.word	0x00000000

08005c40 <chSemWaitTimeoutS.part.1.5695.constprop.40.4167>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8005c40:	b538      	push	{r3, r4, r5, lr}
    if (TIME_IMMEDIATE == time) {
      sp->s_cnt++;

      return MSG_TIMEOUT;
    }
    currp->p_u.wtsemp = sp;
 8005c42:	4d0b      	ldr	r5, [pc, #44]	; (8005c70 <chSemWaitTimeoutS.part.1.5695.constprop.40.4167+0x30>)
 8005c44:	69ac      	ldr	r4, [r5, #24]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8005c46:	4603      	mov	r3, r0
 8005c48:	6220      	str	r0, [r4, #32]
 8005c4a:	e003      	b.n	8005c54 <chSemWaitTimeoutS.part.1.5695.constprop.40.4167+0x14>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8005c4c:	6899      	ldr	r1, [r3, #8]
 8005c4e:	68a2      	ldr	r2, [r4, #8]
 8005c50:	4291      	cmp	r1, r2
 8005c52:	d302      	bcc.n	8005c5a <chSemWaitTimeoutS.part.1.5695.constprop.40.4167+0x1a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8005c54:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8005c56:	4298      	cmp	r0, r3
 8005c58:	d1f8      	bne.n	8005c4c <chSemWaitTimeoutS.part.1.5695.constprop.40.4167+0xc>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8005c5a:	685a      	ldr	r2, [r3, #4]
 8005c5c:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8005c5e:	6023      	str	r3, [r4, #0]
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8005c60:	2005      	movs	r0, #5
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8005c62:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8005c64:	605c      	str	r4, [r3, #4]
 8005c66:	f7fb fd83 	bl	8001770 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8005c6a:	69ab      	ldr	r3, [r5, #24]
 8005c6c:	6a18      	ldr	r0, [r3, #32]
 8005c6e:	bd38      	pop	{r3, r4, r5, pc}
 8005c70:	200016a8 	.word	0x200016a8
	...

08005c80 <rxListen.14255>:
    TAILQ_ENTRY(pizza_t) entries;
};


static THD_FUNCTION (rxListen, arg)
{
 8005c80:	b500      	push	{lr}
 8005c82:	4c18      	ldr	r4, [pc, #96]	; (8005ce4 <rxListen.14255+0x64>)
 8005c84:	b083      	sub	sp, #12
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8005c86:	4625      	mov	r5, r4
 8005c88:	e013      	b.n	8005cb2 <rxListen.14255+0x32>
 8005c8a:	68a2      	ldr	r2, [r4, #8]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8005c8c:	6861      	ldr	r1, [r4, #4]
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8005c8e:	1d13      	adds	r3, r2, #4
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8005c90:	428b      	cmp	r3, r1
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->mb_wrptr++ = msg;
 8005c92:	60a3      	str	r3, [r4, #8]
		//sdRead(&SD3, &header, 9);
		sdRead(&SD3, &buffer, 1);
		/* Post contents of arg2 to mailbox pointed by arg1, wait to post maximum arg3 mSeconds
		 * arg3 may be TIME_IMMEDIATE(post if you can) or TIME_INFINITE(wait until post).
		 * If mailbox object is full, function waits for a free slot for arg3 mSeconds */
		chMBPost(&serialMbox, buffer, TIME_INFINITE);
 8005c94:	6016      	str	r6, [r2, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8005c96:	d301      	bcc.n	8005c9c <rxListen.14255+0x1c>
      mbp->mb_wrptr = mbp->mb_buffer;
 8005c98:	682b      	ldr	r3, [r5, #0]
 8005c9a:	60ab      	str	r3, [r5, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 8005c9c:	4812      	ldr	r0, [pc, #72]	; (8005ce8 <rxListen.14255+0x68>)
 8005c9e:	f7fb ff1f 	bl	8001ae0 <chSemSignalI>
    chSchRescheduleS();
 8005ca2:	f7fb fd55 	bl	8001750 <chSchRescheduleS>
 8005ca6:	2300      	movs	r3, #0
 8005ca8:	f383 8811 	msr	BASEPRI, r3
		chThdSleepMilliseconds(10);
 8005cac:	2064      	movs	r0, #100	; 0x64
 8005cae:	f7fe f8bf 	bl	8003e30 <chThdSleep>
		 * and write data to arg2(buffer for this example). Type of buffer
		 * should be (uint8_t *). This function blocks this thread until
		 * desired number of bytes have read*/

		//sdRead(&SD3, &header, 9);
		sdRead(&SD3, &buffer, 1);
 8005cb2:	f10d 0107 	add.w	r1, sp, #7
 8005cb6:	2201      	movs	r2, #1
 8005cb8:	f04f 33ff 	mov.w	r3, #4294967295
 8005cbc:	480b      	ldr	r0, [pc, #44]	; (8005cec <rxListen.14255+0x6c>)
 8005cbe:	f7fe f927 	bl	8003f10 <chIQReadTimeout>
		/* Post contents of arg2 to mailbox pointed by arg1, wait to post maximum arg3 mSeconds
		 * arg3 may be TIME_IMMEDIATE(post if you can) or TIME_INFINITE(wait until post).
		 * If mailbox object is full, function waits for a free slot for arg3 mSeconds */
		chMBPost(&serialMbox, buffer, TIME_INFINITE);
 8005cc2:	f89d 6007 	ldrb.w	r6, [sp, #7]
 8005cc6:	2320      	movs	r3, #32
 8005cc8:	f383 8811 	msr	BASEPRI, r3
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8005ccc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8005cce:	3b01      	subs	r3, #1
 8005cd0:	2b00      	cmp	r3, #0
 8005cd2:	6263      	str	r3, [r4, #36]	; 0x24
 8005cd4:	dad9      	bge.n	8005c8a <rxListen.14255+0xa>
 8005cd6:	4806      	ldr	r0, [pc, #24]	; (8005cf0 <rxListen.14255+0x70>)
 8005cd8:	f7ff ffb2 	bl	8005c40 <chSemWaitTimeoutS.part.1.5695.constprop.40.4167>

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
  if (rdymsg == MSG_OK) {
 8005cdc:	2800      	cmp	r0, #0
 8005cde:	d1e2      	bne.n	8005ca6 <rxListen.14255+0x26>
 8005ce0:	e7d3      	b.n	8005c8a <rxListen.14255+0xa>
 8005ce2:	bf00      	nop
 8005ce4:	20001c08 	.word	0x20001c08
 8005ce8:	20001c18 	.word	0x20001c18
 8005cec:	20001374 	.word	0x20001374
 8005cf0:	20001c24 	.word	0x20001c24
	...

08005d00 <ThreadButton.15422>:
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8005d00:	f8df 9280 	ldr.w	r9, [pc, #640]	; 8005f84 <ThreadButton.15422+0x284>
 8005d04:	4a95      	ldr	r2, [pc, #596]	; (8005f5c <ThreadButton.15422+0x25c>)
 8005d06:	f8df a280 	ldr.w	sl, [pc, #640]	; 8005f88 <ThreadButton.15422+0x288>
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005d0a:	4e95      	ldr	r6, [pc, #596]	; (8005f60 <ThreadButton.15422+0x260>)
void ext_lld_stop(EXTDriver *extp) {

  if (extp->state == EXT_ACTIVE)
    ext_lld_exti_irq_disable();

  EXTI->EMR = 0;
 8005d0c:	f8df 827c 	ldr.w	r8, [pc, #636]	; 8005f8c <ThreadButton.15422+0x28c>
}

static THD_WORKING_AREA(waThreadButton, 128);
static THD_FUNCTION(ThreadButton, arg) {
 8005d10:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
 8005d14:	f8d9 3018 	ldr.w	r3, [r9, #24]
 8005d18:	f8df b274 	ldr.w	fp, [pc, #628]	; 8005f90 <ThreadButton.15422+0x290>
 8005d1c:	4f91      	ldr	r7, [pc, #580]	; (8005f64 <ThreadButton.15422+0x264>)
 8005d1e:	619a      	str	r2, [r3, #24]
 8005d20:	2420      	movs	r4, #32
 8005d22:	f384 8811 	msr	BASEPRI, r4

    while(true){
    /** lock "pause" interupt task **/
     chSysLock();
        tp_button = chThdGetSelfX();
        chSchGoSleepS(CH_STATE_SUSPENDED);
 8005d26:	2003      	movs	r0, #3


    while(true){
    /** lock "pause" interupt task **/
     chSysLock();
        tp_button = chThdGetSelfX();
 8005d28:	f8d9 3018 	ldr.w	r3, [r9, #24]
 8005d2c:	f8cb 3000 	str.w	r3, [fp]
        chSchGoSleepS(CH_STATE_SUSPENDED);
 8005d30:	f7fb fd1e 	bl	8001770 <chSchGoSleepS>
 8005d34:	2300      	movs	r3, #0
 8005d36:	f383 8811 	msr	BASEPRI, r3
 8005d3a:	f384 8811 	msr	BASEPRI, r4
 *
 * @notapi
 */
void ext_lld_stop(EXTDriver *extp) {

  if (extp->state == EXT_ACTIVE)
 8005d3e:	783a      	ldrb	r2, [r7, #0]
 8005d40:	2a02      	cmp	r2, #2
 8005d42:	f000 80c1 	beq.w	8005ec8 <ThreadButton.15422+0x1c8>
    ext_lld_exti_irq_disable();

  EXTI->EMR = 0;
 8005d46:	2500      	movs	r5, #0
  EXTI->IMR = 0;
  EXTI->PR  = 0xFFFFFFFF;
 8005d48:	f04f 33ff 	mov.w	r3, #4294967295

  osalSysLock();
  osalDbgAssert((extp->state == EXT_STOP) || (extp->state == EXT_ACTIVE),
                "invalid state");
  ext_lld_stop(extp);
  extp->state = EXT_STOP;
 8005d4c:	2401      	movs	r4, #1
void ext_lld_stop(EXTDriver *extp) {

  if (extp->state == EXT_ACTIVE)
    ext_lld_exti_irq_disable();

  EXTI->EMR = 0;
 8005d4e:	f8c8 5004 	str.w	r5, [r8, #4]
  EXTI->IMR = 0;
 8005d52:	f8c8 5000 	str.w	r5, [r8]
  EXTI->PR  = 0xFFFFFFFF;
 8005d56:	f8c8 3014 	str.w	r3, [r8, #20]
 8005d5a:	703c      	strb	r4, [r7, #0]
 8005d5c:	f385 8811 	msr	BASEPRI, r5
     chSysUnlock();

     extStop(&EXTD1);  /**disable EXT driver **/


    pwmEnableChannel(&PWMD4, 1, 255);
 8005d60:	22ff      	movs	r2, #255	; 0xff
 8005d62:	4621      	mov	r1, r4
 8005d64:	4880      	ldr	r0, [pc, #512]	; (8005f68 <ThreadButton.15422+0x268>)
 8005d66:	f7ff fd7b 	bl	8005860 <pwmEnableChannel>
     chThdSleep(5000);
 8005d6a:	f241 3088 	movw	r0, #5000	; 0x1388
 8005d6e:	f7fe f85f 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 0);
 8005d72:	4621      	mov	r1, r4
 8005d74:	462a      	mov	r2, r5
 8005d76:	487c      	ldr	r0, [pc, #496]	; (8005f68 <ThreadButton.15422+0x268>)
 8005d78:	f7ff fd72 	bl	8005860 <pwmEnableChannel>
    chThdSleep(5000);
 8005d7c:	f241 3088 	movw	r0, #5000	; 0x1388
 8005d80:	f7fe f856 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 255);
 8005d84:	4621      	mov	r1, r4
 8005d86:	22ff      	movs	r2, #255	; 0xff
 8005d88:	4877      	ldr	r0, [pc, #476]	; (8005f68 <ThreadButton.15422+0x268>)
 8005d8a:	f7ff fd69 	bl	8005860 <pwmEnableChannel>
     chThdSleep(5000);
 8005d8e:	f241 3088 	movw	r0, #5000	; 0x1388
 8005d92:	f7fe f84d 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 0);
 8005d96:	4621      	mov	r1, r4
 8005d98:	462a      	mov	r2, r5
 8005d9a:	4873      	ldr	r0, [pc, #460]	; (8005f68 <ThreadButton.15422+0x268>)
 8005d9c:	f7ff fd60 	bl	8005860 <pwmEnableChannel>
    chThdSleep(5000);
 8005da0:	f241 3088 	movw	r0, #5000	; 0x1388
 8005da4:	f7fe f844 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 255);
 8005da8:	4621      	mov	r1, r4
 8005daa:	22ff      	movs	r2, #255	; 0xff
 8005dac:	486e      	ldr	r0, [pc, #440]	; (8005f68 <ThreadButton.15422+0x268>)
 8005dae:	f7ff fd57 	bl	8005860 <pwmEnableChannel>
     chThdSleep(5000);
 8005db2:	f241 3088 	movw	r0, #5000	; 0x1388
 8005db6:	f7fe f83b 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 0);
 8005dba:	4621      	mov	r1, r4
 8005dbc:	462a      	mov	r2, r5
 8005dbe:	486a      	ldr	r0, [pc, #424]	; (8005f68 <ThreadButton.15422+0x268>)
 8005dc0:	f7ff fd4e 	bl	8005860 <pwmEnableChannel>
    chThdSleep(5000);
 8005dc4:	f241 3088 	movw	r0, #5000	; 0x1388
 8005dc8:	f7fe f832 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 255);
 8005dcc:	4621      	mov	r1, r4
 8005dce:	22ff      	movs	r2, #255	; 0xff
 8005dd0:	4865      	ldr	r0, [pc, #404]	; (8005f68 <ThreadButton.15422+0x268>)
 8005dd2:	f7ff fd45 	bl	8005860 <pwmEnableChannel>
     chThdSleep(5000);
 8005dd6:	f241 3088 	movw	r0, #5000	; 0x1388
 8005dda:	f7fe f829 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 0);
 8005dde:	4621      	mov	r1, r4
 8005de0:	462a      	mov	r2, r5
 8005de2:	4861      	ldr	r0, [pc, #388]	; (8005f68 <ThreadButton.15422+0x268>)
 8005de4:	f7ff fd3c 	bl	8005860 <pwmEnableChannel>
    chThdSleep(5000);
 8005de8:	f241 3088 	movw	r0, #5000	; 0x1388
 8005dec:	f7fe f820 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 255);
 8005df0:	4621      	mov	r1, r4
 8005df2:	22ff      	movs	r2, #255	; 0xff
 8005df4:	485c      	ldr	r0, [pc, #368]	; (8005f68 <ThreadButton.15422+0x268>)
 8005df6:	f7ff fd33 	bl	8005860 <pwmEnableChannel>
     chThdSleep(5000);
 8005dfa:	f241 3088 	movw	r0, #5000	; 0x1388
 8005dfe:	f7fe f817 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 0);
 8005e02:	4621      	mov	r1, r4
 8005e04:	462a      	mov	r2, r5
 8005e06:	4858      	ldr	r0, [pc, #352]	; (8005f68 <ThreadButton.15422+0x268>)
 8005e08:	f7ff fd2a 	bl	8005860 <pwmEnableChannel>
    chThdSleep(5000);
 8005e0c:	f241 3088 	movw	r0, #5000	; 0x1388
 8005e10:	f7fe f80e 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 255);
 8005e14:	4621      	mov	r1, r4
 8005e16:	22ff      	movs	r2, #255	; 0xff
 8005e18:	4853      	ldr	r0, [pc, #332]	; (8005f68 <ThreadButton.15422+0x268>)
 8005e1a:	f7ff fd21 	bl	8005860 <pwmEnableChannel>
     chThdSleep(5000);
 8005e1e:	f241 3088 	movw	r0, #5000	; 0x1388
 8005e22:	f7fe f805 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 0);
 8005e26:	4621      	mov	r1, r4
 8005e28:	462a      	mov	r2, r5
 8005e2a:	484f      	ldr	r0, [pc, #316]	; (8005f68 <ThreadButton.15422+0x268>)
 8005e2c:	f7ff fd18 	bl	8005860 <pwmEnableChannel>
    chThdSleep(5000);
 8005e30:	f241 3088 	movw	r0, #5000	; 0x1388
 8005e34:	f7fd fffc 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 255);
 8005e38:	4621      	mov	r1, r4
 8005e3a:	22ff      	movs	r2, #255	; 0xff
 8005e3c:	484a      	ldr	r0, [pc, #296]	; (8005f68 <ThreadButton.15422+0x268>)
 8005e3e:	f7ff fd0f 	bl	8005860 <pwmEnableChannel>
     chThdSleep(5000);
 8005e42:	f241 3088 	movw	r0, #5000	; 0x1388
 8005e46:	f7fd fff3 	bl	8003e30 <chThdSleep>
    pwmEnableChannel(&PWMD4, 1, 0);
 8005e4a:	462a      	mov	r2, r5
 8005e4c:	4621      	mov	r1, r4
 8005e4e:	4846      	ldr	r0, [pc, #280]	; (8005f68 <ThreadButton.15422+0x268>)
 8005e50:	f7ff fd06 	bl	8005860 <pwmEnableChannel>
    chThdSleep(5000);
 8005e54:	f241 3088 	movw	r0, #5000	; 0x1388
 8005e58:	f7fd ffea 	bl	8003e30 <chThdSleep>

    /** READ button pin**/
    bns = palReadPad(GPIOC,button_ID);
 8005e5c:	4b43      	ldr	r3, [pc, #268]	; (8005f6c <ThreadButton.15422+0x26c>)
 8005e5e:	691a      	ldr	r2, [r3, #16]
 8005e60:	f8da 3000 	ldr.w	r3, [sl]
 8005e64:	40da      	lsrs	r2, r3

    if ( !bns){
 8005e66:	07d2      	lsls	r2, r2, #31
 8005e68:	d40b      	bmi.n	8005e82 <ThreadButton.15422+0x182>
        switch(button_ID){
 8005e6a:	2b03      	cmp	r3, #3
 8005e6c:	d809      	bhi.n	8005e82 <ThreadButton.15422+0x182>
 8005e6e:	e8df f003 	tbb	[pc, r3]
 8005e72:	161d      	.short	0x161d
 8005e74:	0224      	.short	0x0224
             CanWriteDATA( DEVICE_ID_IN_BCC ,BCC_ID ,inttofloat(OPMCCV));
             //CanWriteDATA( 101 ,1202 ,inttofloat(2));
            break;

            case 3:
             CanWriteDATA( DEVICE_ID_IN_BCC ,BCC_ID ,inttofloat(SBMCCV));
 8005e76:	4a3e      	ldr	r2, [pc, #248]	; (8005f70 <ThreadButton.15422+0x270>)
 8005e78:	2064      	movs	r0, #100	; 0x64
 8005e7a:	8811      	ldrh	r1, [r2, #0]
 8005e7c:	2200      	movs	r2, #0
 8005e7e:	f7fe fa3f 	bl	8004300 <CanWriteDATA>
 8005e82:	2320      	movs	r3, #32
 8005e84:	f383 8811 	msr	BASEPRI, r3
  osalDbgCheck((extp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((extp->state == EXT_STOP) || (extp->state == EXT_ACTIVE),
                "invalid state");
  extp->config = config;
 8005e88:	4b3a      	ldr	r3, [pc, #232]	; (8005f74 <ThreadButton.15422+0x274>)
  ext_lld_start(extp);
 8005e8a:	4836      	ldr	r0, [pc, #216]	; (8005f64 <ThreadButton.15422+0x264>)
  osalDbgCheck((extp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((extp->state == EXT_STOP) || (extp->state == EXT_ACTIVE),
                "invalid state");
  extp->config = config;
 8005e8c:	607b      	str	r3, [r7, #4]
  ext_lld_start(extp);
 8005e8e:	f7fc fd97 	bl	80029c0 <ext_lld_start>
  extp->state = EXT_ACTIVE;
 8005e92:	2302      	movs	r3, #2
 8005e94:	703b      	strb	r3, [r7, #0]
 8005e96:	2300      	movs	r3, #0
 8005e98:	f383 8811 	msr	BASEPRI, r3
 8005e9c:	e740      	b.n	8005d20 <ThreadButton.15422+0x20>
             CanWriteDATA( DEVICE_ID_IN_BCC , BCC_ID ,inttofloat(TPMCCV));
             //CanWriteDATA( 101 ,1202 ,inttofloat(8));
            break;

            case 1:
             CanWriteDATA( DEVICE_ID_IN_BCC ,BCC_ID ,inttofloat(FCMCCV));
 8005e9e:	4a34      	ldr	r2, [pc, #208]	; (8005f70 <ThreadButton.15422+0x270>)
 8005ea0:	2064      	movs	r0, #100	; 0x64
 8005ea2:	8811      	ldrh	r1, [r2, #0]
 8005ea4:	4a34      	ldr	r2, [pc, #208]	; (8005f78 <ThreadButton.15422+0x278>)
 8005ea6:	f7fe fa2b 	bl	8004300 <CanWriteDATA>
 8005eaa:	e7ea      	b.n	8005e82 <ThreadButton.15422+0x182>
    bns = palReadPad(GPIOC,button_ID);

    if ( !bns){
        switch(button_ID){
            case 0:
             CanWriteDATA( DEVICE_ID_IN_BCC , BCC_ID ,inttofloat(TPMCCV));
 8005eac:	4b30      	ldr	r3, [pc, #192]	; (8005f70 <ThreadButton.15422+0x270>)
 8005eae:	4a33      	ldr	r2, [pc, #204]	; (8005f7c <ThreadButton.15422+0x27c>)
 8005eb0:	8819      	ldrh	r1, [r3, #0]
 8005eb2:	2064      	movs	r0, #100	; 0x64
 8005eb4:	f7fe fa24 	bl	8004300 <CanWriteDATA>
 8005eb8:	e7e3      	b.n	8005e82 <ThreadButton.15422+0x182>
             CanWriteDATA( DEVICE_ID_IN_BCC ,BCC_ID ,inttofloat(FCMCCV));
             //CanWriteDATA( 101 ,1202 ,inttofloat(4));
            break;

            case 2:
             CanWriteDATA( DEVICE_ID_IN_BCC ,BCC_ID ,inttofloat(OPMCCV));
 8005eba:	4b2d      	ldr	r3, [pc, #180]	; (8005f70 <ThreadButton.15422+0x270>)
 8005ebc:	4a30      	ldr	r2, [pc, #192]	; (8005f80 <ThreadButton.15422+0x280>)
 8005ebe:	8819      	ldrh	r1, [r3, #0]
 8005ec0:	2064      	movs	r0, #100	; 0x64
 8005ec2:	f7fe fa1d 	bl	8004300 <CanWriteDATA>
 8005ec6:	e7dc      	b.n	8005e82 <ThreadButton.15422+0x182>
 8005ec8:	2540      	movs	r5, #64	; 0x40
 8005eca:	f8c6 5080 	str.w	r5, [r6, #128]	; 0x80
 8005ece:	f44f 7480 	mov.w	r4, #256	; 0x100
 8005ed2:	f04f 0e80 	mov.w	lr, #128	; 0x80
 8005ed6:	f44f 7000 	mov.w	r0, #512	; 0x200
 8005eda:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8005ede:	f44f 0500 	mov.w	r5, #8388608	; 0x800000
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005ee2:	f886 3306 	strb.w	r3, [r6, #774]	; 0x306
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005ee6:	f8c6 e080 	str.w	lr, [r6, #128]	; 0x80
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005eea:	f886 3307 	strb.w	r3, [r6, #775]	; 0x307
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005eee:	f04f 4e80 	mov.w	lr, #1073741824	; 0x40000000
 8005ef2:	f8c6 4080 	str.w	r4, [r6, #128]	; 0x80
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005ef6:	f886 3308 	strb.w	r3, [r6, #776]	; 0x308
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005efa:	f8c6 0080 	str.w	r0, [r6, #128]	; 0x80
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005efe:	f886 3309 	strb.w	r3, [r6, #777]	; 0x309
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005f02:	f8c6 1080 	str.w	r1, [r6, #128]	; 0x80
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005f06:	f886 330a 	strb.w	r3, [r6, #778]	; 0x30a
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005f0a:	f8c6 5080 	str.w	r5, [r6, #128]	; 0x80
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005f0e:	f886 3317 	strb.w	r3, [r6, #791]	; 0x317
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005f12:	f44f 5580 	mov.w	r5, #4096	; 0x1000
 8005f16:	f8c6 4084 	str.w	r4, [r6, #132]	; 0x84
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005f1a:	f886 3328 	strb.w	r3, [r6, #808]	; 0x328
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005f1e:	2404      	movs	r4, #4
 8005f20:	f8c6 2080 	str.w	r2, [r6, #128]	; 0x80
 8005f24:	2208      	movs	r2, #8
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005f26:	f886 3301 	strb.w	r3, [r6, #769]	; 0x301
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005f2a:	f8c6 0084 	str.w	r0, [r6, #132]	; 0x84
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005f2e:	f886 3329 	strb.w	r3, [r6, #809]	; 0x329
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005f32:	f8c6 1084 	str.w	r1, [r6, #132]	; 0x84
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005f36:	f886 332a 	strb.w	r3, [r6, #810]	; 0x32a
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005f3a:	f8c6 e084 	str.w	lr, [r6, #132]	; 0x84
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005f3e:	f886 333e 	strb.w	r3, [r6, #830]	; 0x33e
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005f42:	f8c6 5088 	str.w	r5, [r6, #136]	; 0x88
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005f46:	f886 334c 	strb.w	r3, [r6, #844]	; 0x34c
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005f4a:	f8c6 4080 	str.w	r4, [r6, #128]	; 0x80
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005f4e:	f886 3302 	strb.w	r3, [r6, #770]	; 0x302
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8005f52:	f8c6 2080 	str.w	r2, [r6, #128]	; 0x80
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 8005f56:	f886 3303 	strb.w	r3, [r6, #771]	; 0x303
 8005f5a:	e6f4      	b.n	8005d46 <ThreadButton.15422+0x46>
 8005f5c:	080075a0 	.word	0x080075a0
 8005f60:	e000e100 	.word	0xe000e100
 8005f64:	2000169c 	.word	0x2000169c
 8005f68:	20001bec 	.word	0x20001bec
 8005f6c:	40020800 	.word	0x40020800
 8005f70:	200008c2 	.word	0x200008c2
 8005f74:	08006f30 	.word	0x08006f30
 8005f78:	40a00000 	.word	0x40a00000
 8005f7c:	42480000 	.word	0x42480000
 8005f80:	42240000 	.word	0x42240000
 8005f84:	200016a8 	.word	0x200016a8
 8005f88:	20002414 	.word	0x20002414
 8005f8c:	40013c00 	.word	0x40013c00
 8005f90:	20002410 	.word	0x20002410
	...

08005fa0 <pubA>:
		chThdSleepMilliseconds(10);

	}
}

uint8_t pubA(void){
 8005fa0:	b510      	push	{r4, lr}
 8005fa2:	2320      	movs	r3, #32
 8005fa4:	b082      	sub	sp, #8
 8005fa6:	f383 8811 	msr	BASEPRI, r3
 8005faa:	4c15      	ldr	r4, [pc, #84]	; (8006000 <pubA+0x60>)
 8005fac:	69a3      	ldr	r3, [r4, #24]
 8005fae:	3b01      	subs	r3, #1
 8005fb0:	2b00      	cmp	r3, #0
 8005fb2:	61a3      	str	r3, [r4, #24]
 8005fb4:	db1c      	blt.n	8005ff0 <pubA+0x50>
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8005fb6:	68e3      	ldr	r3, [r4, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8005fb8:	6861      	ldr	r1, [r4, #4]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
 8005fba:	681a      	ldr	r2, [r3, #0]
 8005fbc:	f8cd 2007 	str.w	r2, [sp, #7]
 8005fc0:	3304      	adds	r3, #4
 8005fc2:	4a0f      	ldr	r2, [pc, #60]	; (8006000 <pubA+0x60>)
 8005fc4:	60e3      	str	r3, [r4, #12]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8005fc6:	428b      	cmp	r3, r1
      mbp->mb_rdptr = mbp->mb_buffer;
 8005fc8:	bf28      	it	cs
 8005fca:	6813      	ldrcs	r3, [r2, #0]
    }
    chSemSignalI(&mbp->mb_emptysem);
 8005fcc:	480d      	ldr	r0, [pc, #52]	; (8006004 <pubA+0x64>)

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->mb_rdptr++;
    if (mbp->mb_rdptr >= mbp->mb_top) {
      mbp->mb_rdptr = mbp->mb_buffer;
 8005fce:	bf28      	it	cs
 8005fd0:	60d3      	strcs	r3, [r2, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 8005fd2:	f7fb fd85 	bl	8001ae0 <chSemSignalI>
    chSchRescheduleS();
 8005fd6:	f7fb fbbb 	bl	8001750 <chSchRescheduleS>
 8005fda:	2000      	movs	r0, #0
 8005fdc:	2300      	movs	r3, #0
 8005fde:	f383 8811 	msr	BASEPRI, r3

    uint8_t toSend;

    if(chMBFetch(&serialMbox, (msg_t *)&toSend, TIME_INFINITE) == MSG_OK)
 8005fe2:	b918      	cbnz	r0, 8005fec <pubA+0x4c>
    return toSend;
 8005fe4:	f89d 0007 	ldrb.w	r0, [sp, #7]
}
 8005fe8:	b002      	add	sp, #8
 8005fea:	bd10      	pop	{r4, pc}
 8005fec:	b002      	add	sp, #8
 8005fee:	bd10      	pop	{r4, pc}
 8005ff0:	f104 0010 	add.w	r0, r4, #16
 8005ff4:	f7ff fe24 	bl	8005c40 <chSemWaitTimeoutS.part.1.5695.constprop.40.4167>

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
  if (rdymsg == MSG_OK) {
 8005ff8:	2800      	cmp	r0, #0
 8005ffa:	d1ef      	bne.n	8005fdc <pubA+0x3c>
 8005ffc:	e7db      	b.n	8005fb6 <pubA+0x16>
 8005ffe:	bf00      	nop
 8006000:	20001c08 	.word	0x20001c08
 8006004:	20001c24 	.word	0x20001c24
	...

08006010 <can_lld_start.constprop.24>:
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
void can_lld_start(CANDriver *canp) {
 8006010:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* Clock activation.*/
#if STM32_CAN_USE_CAN1
  if (&CAND1 == canp) {
 8006012:	4b31      	ldr	r3, [pc, #196]	; (80060d8 <can_lld_start.constprop.24+0xc8>)
 8006014:	4298      	cmp	r0, r3
 *
 * @param[in] canp      pointer to the @p CANDriver object
 *
 * @notapi
 */
void can_lld_start(CANDriver *canp) {
 8006016:	4604      	mov	r4, r0

  /* Clock activation.*/
#if STM32_CAN_USE_CAN1
  if (&CAND1 == canp) {
 8006018:	d018      	beq.n	800604c <can_lld_start.constprop.24+0x3c>
#endif
    rccEnableCAN1(FALSE);
  }
#endif
#if STM32_CAN_USE_CAN2
  if (&CAND2 == canp) {
 800601a:	4b30      	ldr	r3, [pc, #192]	; (80060dc <can_lld_start.constprop.24+0xcc>)
 800601c:	4298      	cmp	r0, r3
 800601e:	d039      	beq.n	8006094 <can_lld_start.constprop.24+0x84>
    rccEnableCAN2(FALSE);
  }
#endif

  /* Configuring CAN. */
  canp->can->MCR = CAN_MCR_INRQ;
 8006020:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006022:	2201      	movs	r2, #1
 8006024:	601a      	str	r2, [r3, #0]
  while ((canp->can->MSR & CAN_MSR_INAK) == 0)
 8006026:	685a      	ldr	r2, [r3, #4]
 8006028:	07d1      	lsls	r1, r2, #31
 800602a:	d407      	bmi.n	800603c <can_lld_start.constprop.24+0x2c>
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800602c:	2008      	movs	r0, #8
 800602e:	2101      	movs	r1, #1
 8006030:	f7fd fed6 	bl	8003de0 <chSchGoSleepTimeoutS>
 8006034:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8006036:	685a      	ldr	r2, [r3, #4]
 8006038:	07d2      	lsls	r2, r2, #31
 800603a:	d5f7      	bpl.n	800602c <can_lld_start.constprop.24+0x1c>
    osalThreadSleepS(1);
  canp->can->BTR = canp->config->btr;
 800603c:	6862      	ldr	r2, [r4, #4]
  canp->can->MCR = canp->config->mcr;

  /* Interrupt sources initialization.*/
  canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
 800603e:	4928      	ldr	r1, [pc, #160]	; (80060e0 <can_lld_start.constprop.24+0xd0>)

  /* Configuring CAN. */
  canp->can->MCR = CAN_MCR_INRQ;
  while ((canp->can->MSR & CAN_MSR_INAK) == 0)
    osalThreadSleepS(1);
  canp->can->BTR = canp->config->btr;
 8006040:	6850      	ldr	r0, [r2, #4]
  canp->can->MCR = canp->config->mcr;
 8006042:	6812      	ldr	r2, [r2, #0]

  /* Configuring CAN. */
  canp->can->MCR = CAN_MCR_INRQ;
  while ((canp->can->MSR & CAN_MSR_INAK) == 0)
    osalThreadSleepS(1);
  canp->can->BTR = canp->config->btr;
 8006044:	61d8      	str	r0, [r3, #28]
  canp->can->MCR = canp->config->mcr;
 8006046:	601a      	str	r2, [r3, #0]

  /* Interrupt sources initialization.*/
  canp->can->IER = CAN_IER_TMEIE  | CAN_IER_FMPIE0 | CAN_IER_FMPIE1 |
 8006048:	6159      	str	r1, [r3, #20]
 800604a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800604c:	4b25      	ldr	r3, [pc, #148]	; (80060e4 <can_lld_start.constprop.24+0xd4>)
    nvicEnableVector(STM32_CAN1_TX_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_RX0_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_RX1_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN1_SCE_NUMBER, STM32_CAN_CAN1_IRQ_PRIORITY);
#endif
    rccEnableCAN1(FALSE);
 800604e:	4926      	ldr	r1, [pc, #152]	; (80060e8 <can_lld_start.constprop.24+0xd8>)
 8006050:	22b0      	movs	r2, #176	; 0xb0
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006052:	f44f 2700 	mov.w	r7, #524288	; 0x80000
 8006056:	f44f 1680 	mov.w	r6, #1048576	; 0x100000
 800605a:	f44f 1500 	mov.w	r5, #2097152	; 0x200000
 800605e:	f44f 0080 	mov.w	r0, #4194304	; 0x400000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006062:	f883 2313 	strb.w	r2, [r3, #787]	; 0x313
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006066:	f8c3 7180 	str.w	r7, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800606a:	601f      	str	r7, [r3, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800606c:	f883 2314 	strb.w	r2, [r3, #788]	; 0x314
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006070:	f8c3 6180 	str.w	r6, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8006074:	601e      	str	r6, [r3, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006076:	f883 2315 	strb.w	r2, [r3, #789]	; 0x315
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800607a:	f8c3 5180 	str.w	r5, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800607e:	601d      	str	r5, [r3, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006080:	f883 2316 	strb.w	r2, [r3, #790]	; 0x316
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006084:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8006088:	6018      	str	r0, [r3, #0]
 800608a:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800608c:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8006090:	640b      	str	r3, [r1, #64]	; 0x40
 8006092:	e7c5      	b.n	8006020 <can_lld_start.constprop.24+0x10>

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006094:	4b13      	ldr	r3, [pc, #76]	; (80060e4 <can_lld_start.constprop.24+0xd4>)
    nvicEnableVector(STM32_CAN2_TX_NUMBER, STM32_CAN_CAN2_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN2_RX0_NUMBER, STM32_CAN_CAN2_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN2_RX1_NUMBER, STM32_CAN_CAN2_IRQ_PRIORITY);
    nvicEnableVector(STM32_CAN2_SCE_NUMBER, STM32_CAN_CAN2_IRQ_PRIORITY);
#endif
    rccEnableCAN2(FALSE);
 8006096:	4914      	ldr	r1, [pc, #80]	; (80060e8 <can_lld_start.constprop.24+0xd8>)
 8006098:	22b0      	movs	r2, #176	; 0xb0
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800609a:	f04f 4700 	mov.w	r7, #2147483648	; 0x80000000
 800609e:	2601      	movs	r6, #1
 80060a0:	2502      	movs	r5, #2
 80060a2:	2004      	movs	r0, #4

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80060a4:	f883 233f 	strb.w	r2, [r3, #831]	; 0x33f
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80060a8:	f8c3 7184 	str.w	r7, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80060ac:	605f      	str	r7, [r3, #4]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80060ae:	f883 2340 	strb.w	r2, [r3, #832]	; 0x340
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80060b2:	f8c3 6188 	str.w	r6, [r3, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80060b6:	609e      	str	r6, [r3, #8]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80060b8:	f883 2341 	strb.w	r2, [r3, #833]	; 0x341
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80060bc:	f8c3 5188 	str.w	r5, [r3, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80060c0:	609d      	str	r5, [r3, #8]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80060c2:	f883 2342 	strb.w	r2, [r3, #834]	; 0x342
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80060c6:	f8c3 0188 	str.w	r0, [r3, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80060ca:	6098      	str	r0, [r3, #8]
 80060cc:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 80060ce:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80060d2:	640b      	str	r3, [r1, #64]	; 0x40
 80060d4:	e7a4      	b.n	8006020 <can_lld_start.constprop.24+0x10>
 80060d6:	bf00      	nop
 80060d8:	20000d58 	.word	0x20000d58
 80060dc:	20000d80 	.word	0x20000d80
 80060e0:	00018f5b 	.word	0x00018f5b
 80060e4:	e000e100 	.word	0xe000e100
 80060e8:	40023800 	.word	0x40023800
 80060ec:	00000000 	.word	0x00000000

080060f0 <pwm_lld_start>:
 */
void pwm_lld_start(PWMDriver *pwmp) {
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 80060f0:	7803      	ldrb	r3, [r0, #0]
 80060f2:	2b01      	cmp	r3, #1
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_start(PWMDriver *pwmp) {
 80060f4:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 80060f6:	d053      	beq.n	80061a0 <pwm_lld_start+0xb0>
                       STM32_TIM_CCMR3_OC6M(6) | STM32_TIM_CCMR3_OC6PE;
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 80060f8:	6983      	ldr	r3, [r0, #24]
 80060fa:	2200      	movs	r2, #0
 80060fc:	601a      	str	r2, [r3, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 80060fe:	635a      	str	r2, [r3, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8006100:	639a      	str	r2, [r3, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 8006102:	63da      	str	r2, [r3, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 8006104:	641a      	str	r2, [r3, #64]	; 0x40
    if (pwmp->channels > 4) {
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
    }
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 8006106:	625a      	str	r2, [r3, #36]	; 0x24
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8006108:	6842      	ldr	r2, [r0, #4]
 800610a:	6946      	ldr	r6, [r0, #20]
 800610c:	6814      	ldr	r4, [r2, #0]
  pwmp->tim->ARR  = pwmp->period - 1;
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 800610e:	68d1      	ldr	r1, [r2, #12]
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
  pwmp->tim->ARR  = pwmp->period - 1;
 8006110:	6885      	ldr	r5, [r0, #8]
  pwmp->tim->CR2  = pwmp->config->cr2;
 8006112:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8006114:	fbb6 f4f4 	udiv	r4, r6, r4
  pwmp->tim->ARR  = pwmp->period - 1;
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8006118:	f001 010f 	and.w	r1, r1, #15
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 800611c:	3c01      	subs	r4, #1
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
  pwmp->tim->ARR  = pwmp->period - 1;
 800611e:	3d01      	subs	r5, #1
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8006120:	2901      	cmp	r1, #1
  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
  osalDbgAssert((psc <= 0xFFFF) &&
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
 8006122:	629c      	str	r4, [r3, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 8006124:	62dd      	str	r5, [r3, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 8006126:	6058      	str	r0, [r3, #4]

  /* Output enables and polarities setup.*/
  ccer = 0;
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8006128:	d038      	beq.n	800619c <pwm_lld_start+0xac>
 800612a:	2902      	cmp	r1, #2
 800612c:	d134      	bne.n	8006198 <pwm_lld_start+0xa8>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC1P;
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC1E;
 800612e:	f041 0101 	orr.w	r1, r1, #1
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 8006132:	6950      	ldr	r0, [r2, #20]
 8006134:	f000 000f 	and.w	r0, r0, #15
 8006138:	2801      	cmp	r0, #1
 800613a:	d02a      	beq.n	8006192 <pwm_lld_start+0xa2>
 800613c:	2802      	cmp	r0, #2
 800613e:	d026      	beq.n	800618e <pwm_lld_start+0x9e>
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 8006140:	69d0      	ldr	r0, [r2, #28]
 8006142:	f000 000f 	and.w	r0, r0, #15
 8006146:	2801      	cmp	r0, #1
 8006148:	d01e      	beq.n	8006188 <pwm_lld_start+0x98>
 800614a:	2802      	cmp	r0, #2
 800614c:	d01a      	beq.n	8006184 <pwm_lld_start+0x94>
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
  default:
    ;
  }
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 800614e:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8006150:	f000 000f 	and.w	r0, r0, #15
 8006154:	2801      	cmp	r0, #1
 8006156:	d003      	beq.n	8006160 <pwm_lld_start+0x70>
 8006158:	2802      	cmp	r0, #2
 800615a:	d103      	bne.n	8006164 <pwm_lld_start+0x74>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC4P;
 800615c:	f441 5100 	orr.w	r1, r1, #8192	; 0x2000
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC4E;
 8006160:	f441 5180 	orr.w	r1, r1, #4096	; 0x1000
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8006164:	6b10      	ldr	r0, [r2, #48]	; 0x30
      ;
    }
  }
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
 8006166:	6219      	str	r1, [r3, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8006168:	2501      	movs	r5, #1
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 800616a:	2400      	movs	r4, #0
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 800616c:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
                     ~STM32_TIM_DIER_IRQ_MASK;
#if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
#if STM32_PWM_USE_ADVANCED
  pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
#else
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
 8006170:	f44f 4100 	mov.w	r1, #32768	; 0x8000
#endif
#endif
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8006174:	2285      	movs	r2, #133	; 0x85
    }
  }
#endif /* STM32_PWM_USE_ADVANCED*/

  pwmp->tim->CCER  = ccer;
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8006176:	615d      	str	r5, [r3, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8006178:	611c      	str	r4, [r3, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 800617a:	60d8      	str	r0, [r3, #12]
#endif
#endif
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
                     STM32_TIM_CR1_CEN;
}
 800617c:	bcf0      	pop	{r4, r5, r6, r7}
                     ~STM32_TIM_DIER_IRQ_MASK;
#if STM32_PWM_USE_TIM1 || STM32_PWM_USE_TIM8
#if STM32_PWM_USE_ADVANCED
  pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
#else
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
 800617e:	6459      	str	r1, [r3, #68]	; 0x44
#endif
#endif
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8006180:	601a      	str	r2, [r3, #0]
                     STM32_TIM_CR1_CEN;
}
 8006182:	4770      	bx	lr
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC3P;
 8006184:	f441 7100 	orr.w	r1, r1, #512	; 0x200
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
 8006188:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800618c:	e7df      	b.n	800614e <pwm_lld_start+0x5e>
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC2P;
 800618e:	f041 0120 	orr.w	r1, r1, #32
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
 8006192:	f041 0110 	orr.w	r1, r1, #16
 8006196:	e7d3      	b.n	8006140 <pwm_lld_start+0x50>
  pwmp->tim->PSC  = psc;
  pwmp->tim->ARR  = pwmp->period - 1;
  pwmp->tim->CR2  = pwmp->config->cr2;

  /* Output enables and polarities setup.*/
  ccer = 0;
 8006198:	2100      	movs	r1, #0
 800619a:	e7ca      	b.n	8006132 <pwm_lld_start+0x42>
 800619c:	2100      	movs	r1, #0
 800619e:	e7c6      	b.n	800612e <pwm_lld_start+0x3e>
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
    /* Clock activation and timer reset.*/
#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
 80061a0:	4b20      	ldr	r3, [pc, #128]	; (8006224 <pwm_lld_start+0x134>)
 80061a2:	4298      	cmp	r0, r3
 80061a4:	d008      	beq.n	80061b8 <pwm_lld_start+0xc8>
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_PWM_TIM3_IRQ_PRIORITY);
      pwmp->clock = STM32_TIMCLK1;
    }
#endif
#if STM32_PWM_USE_TIM4
    if (&PWMD4 == pwmp) {
 80061a6:	4b20      	ldr	r3, [pc, #128]	; (8006228 <pwm_lld_start+0x138>)
 80061a8:	4298      	cmp	r0, r3
 80061aa:	d024      	beq.n	80061f6 <pwm_lld_start+0x106>
    }
#endif

    /* All channels configured in PWM1 mode with preload enabled and will
       stay that way until the driver is stopped.*/
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 80061ac:	6983      	ldr	r3, [r0, #24]
 80061ae:	f646 0268 	movw	r2, #26728	; 0x6868
 80061b2:	619a      	str	r2, [r3, #24]
                       STM32_TIM_CCMR1_OC2M(6) | STM32_TIM_CCMR1_OC2PE;
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 80061b4:	61da      	str	r2, [r3, #28]
 80061b6:	e7a7      	b.n	8006108 <pwm_lld_start+0x18>

  if (pwmp->state == PWM_STOP) {
    /* Clock activation and timer reset.*/
#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
      rccEnableTIM1(FALSE);
 80061b8:	4a1c      	ldr	r2, [pc, #112]	; (800622c <pwm_lld_start+0x13c>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80061ba:	4b1d      	ldr	r3, [pc, #116]	; (8006230 <pwm_lld_start+0x140>)
 80061bc:	6c51      	ldr	r1, [r2, #68]	; 0x44
      nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
      nvicEnableVector(STM32_TIM1_CC_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
#if defined(STM32_TIM1CLK)
      pwmp->clock = STM32_TIM1CLK;
#else
      pwmp->clock = STM32_TIMCLK2;
 80061be:	4e1d      	ldr	r6, [pc, #116]	; (8006234 <pwm_lld_start+0x144>)

  if (pwmp->state == PWM_STOP) {
    /* Clock activation and timer reset.*/
#if STM32_PWM_USE_TIM1
    if (&PWMD1 == pwmp) {
      rccEnableTIM1(FALSE);
 80061c0:	f041 0101 	orr.w	r1, r1, #1
 80061c4:	6451      	str	r1, [r2, #68]	; 0x44
      rccResetTIM1();
 80061c6:	6a51      	ldr	r1, [r2, #36]	; 0x24
 80061c8:	2470      	movs	r4, #112	; 0x70
 80061ca:	f041 0c01 	orr.w	ip, r1, #1
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80061ce:	f04f 7500 	mov.w	r5, #33554432	; 0x2000000
 80061d2:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
 80061d6:	2700      	movs	r7, #0
 80061d8:	f8c2 c024 	str.w	ip, [r2, #36]	; 0x24
 80061dc:	6257      	str	r7, [r2, #36]	; 0x24

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80061de:	f883 4319 	strb.w	r4, [r3, #793]	; 0x319
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80061e2:	f8c3 5180 	str.w	r5, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80061e6:	601d      	str	r5, [r3, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80061e8:	f883 431b 	strb.w	r4, [r3, #795]	; 0x31b
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80061ec:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80061f0:	6019      	str	r1, [r3, #0]
      nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
      nvicEnableVector(STM32_TIM1_CC_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
#if defined(STM32_TIM1CLK)
      pwmp->clock = STM32_TIM1CLK;
#else
      pwmp->clock = STM32_TIMCLK2;
 80061f2:	6146      	str	r6, [r0, #20]
 80061f4:	e7da      	b.n	80061ac <pwm_lld_start+0xbc>
      pwmp->clock = STM32_TIMCLK1;
    }
#endif
#if STM32_PWM_USE_TIM4
    if (&PWMD4 == pwmp) {
      rccEnableTIM4(FALSE);
 80061f6:	4b0d      	ldr	r3, [pc, #52]	; (800622c <pwm_lld_start+0x13c>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80061f8:	4a0d      	ldr	r2, [pc, #52]	; (8006230 <pwm_lld_start+0x140>)
 80061fa:	6c19      	ldr	r1, [r3, #64]	; 0x40
      rccResetTIM4();
      nvicEnableVector(STM32_TIM4_NUMBER, STM32_PWM_TIM4_IRQ_PRIORITY);
      pwmp->clock = STM32_TIMCLK1;
 80061fc:	4c0e      	ldr	r4, [pc, #56]	; (8006238 <pwm_lld_start+0x148>)
      pwmp->clock = STM32_TIMCLK1;
    }
#endif
#if STM32_PWM_USE_TIM4
    if (&PWMD4 == pwmp) {
      rccEnableTIM4(FALSE);
 80061fe:	f041 0104 	orr.w	r1, r1, #4
 8006202:	6419      	str	r1, [r3, #64]	; 0x40
      rccResetTIM4();
 8006204:	6a1f      	ldr	r7, [r3, #32]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006206:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 800620a:	2600      	movs	r6, #0
 800620c:	f047 0704 	orr.w	r7, r7, #4

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006210:	2570      	movs	r5, #112	; 0x70
 8006212:	621f      	str	r7, [r3, #32]
 8006214:	621e      	str	r6, [r3, #32]
 8006216:	f882 531e 	strb.w	r5, [r2, #798]	; 0x31e
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800621a:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800621e:	6011      	str	r1, [r2, #0]
      nvicEnableVector(STM32_TIM4_NUMBER, STM32_PWM_TIM4_IRQ_PRIORITY);
      pwmp->clock = STM32_TIMCLK1;
 8006220:	6144      	str	r4, [r0, #20]
 8006222:	e7c3      	b.n	80061ac <pwm_lld_start+0xbc>
 8006224:	20001bd0 	.word	0x20001bd0
 8006228:	20001bec 	.word	0x20001bec
 800622c:	40023800 	.word	0x40023800
 8006230:	e000e100 	.word	0xe000e100
 8006234:	0a037a00 	.word	0x0a037a00
 8006238:	0501bd00 	.word	0x0501bd00
 800623c:	00000000 	.word	0x00000000

08006240 <ThCurrentLimiter.14565>:
    }

}


static THD_FUNCTION(ThCurrentLimiter, arg) {
 8006240:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8006244:	4b64      	ldr	r3, [pc, #400]	; (80063d8 <ThCurrentLimiter.14565+0x198>)
 8006246:	4a65      	ldr	r2, [pc, #404]	; (80063dc <ThCurrentLimiter.14565+0x19c>)
 8006248:	699b      	ldr	r3, [r3, #24]
 800624a:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 80063f0 <ThCurrentLimiter.14565+0x1b0>
 800624e:	619a      	str	r2, [r3, #24]
 8006250:	b083      	sub	sp, #12
    int t = 0;
    int j= 0;
    int i = 0;
    bool fn = 0;

   originCurrent = CanReadInt(currentLimitDeviceID, currentLimitUserRef);
 8006252:	2065      	movs	r0, #101	; 0x65
 8006254:	f240 4153 	movw	r1, #1107	; 0x453
 8006258:	f7fc fc8a 	bl	8002b70 <CanReadInt>
 800625c:	f8df a198 	ldr.w	sl, [pc, #408]	; 80063f8 <ThCurrentLimiter.14565+0x1b8>
 8006260:	4a5f      	ldr	r2, [pc, #380]	; (80063e0 <ThCurrentLimiter.14565+0x1a0>)

    while( true ){

        if( alert == 0){
 8006262:	f8d9 6000 	ldr.w	r6, [r9]
 8006266:	4d5f      	ldr	r5, [pc, #380]	; (80063e4 <ThCurrentLimiter.14565+0x1a4>)
    int t = 0;
    int j= 0;
    int i = 0;
    bool fn = 0;

   originCurrent = CanReadInt(currentLimitDeviceID, currentLimitUserRef);
 8006268:	6010      	str	r0, [r2, #0]
    // read churging current

    int t = 0;
    int j= 0;
    int i = 0;
    bool fn = 0;
 800626a:	2300      	movs	r3, #0
            t++;

            while( j <=2 && currentTemp2[j] <= TEMP[j]){
            j++;
            }
            if(j <= 2 && !hiteup ){
 800626c:	4657      	mov	r7, sl
    // read churging current

    int t = 0;
    int j= 0;
    int i = 0;
    bool fn = 0;
 800626e:	9301      	str	r3, [sp, #4]

   originCurrent = CanReadInt(currentLimitDeviceID, currentLimitUserRef);

    while( true ){

        if( alert == 0){
 8006270:	2e00      	cmp	r6, #0
 8006272:	d14f      	bne.n	8006314 <ThCurrentLimiter.14565+0xd4>
 8006274:	485c      	ldr	r0, [pc, #368]	; (80063e8 <ThCurrentLimiter.14565+0x1a8>)
 8006276:	4c5d      	ldr	r4, [pc, #372]	; (80063ec <ThCurrentLimiter.14565+0x1ac>)
 8006278:	46b3      	mov	fp, r6
 800627a:	46b0      	mov	r8, r6
 800627c:	7806      	ldrb	r6, [r0, #0]
        while(i <= 2 && !quit){
 800627e:	2e00      	cmp	r6, #0
 8006280:	d178      	bne.n	8006374 <ThCurrentLimiter.14565+0x134>
            if( currentTemp2[i] >= TEMP[i]){
 8006282:	f855 0028 	ldr.w	r0, [r5, r8, lsl #2]
 8006286:	f7fa fd0d 	bl	8000ca4 <__aeabi_i2f>
 800628a:	f854 1f04 	ldr.w	r1, [r4, #4]!
            alert = 1;
            quit = 1;
           }
        i++;
 800628e:	f108 0801 	add.w	r8, r8, #1

    while( true ){

        if( alert == 0){
        while(i <= 2 && !quit){
            if( currentTemp2[i] >= TEMP[i]){
 8006292:	f7fa ff0f 	bl	80010b4 <__aeabi_fcmpge>
 8006296:	b108      	cbz	r0, 800629c <ThCurrentLimiter.14565+0x5c>
            alert = 1;
            quit = 1;
 8006298:	2601      	movs	r6, #1
    while( true ){

        if( alert == 0){
        while(i <= 2 && !quit){
            if( currentTemp2[i] >= TEMP[i]){
            alert = 1;
 800629a:	46b3      	mov	fp, r6
   originCurrent = CanReadInt(currentLimitDeviceID, currentLimitUserRef);

    while( true ){

        if( alert == 0){
        while(i <= 2 && !quit){
 800629c:	f1b8 0f03 	cmp.w	r8, #3
 80062a0:	d1ed      	bne.n	800627e <ThCurrentLimiter.14565+0x3e>
 80062a2:	4a51      	ldr	r2, [pc, #324]	; (80063e8 <ThCurrentLimiter.14565+0x1a8>)
 80062a4:	f8c9 b000 	str.w	fp, [r9]
 80062a8:	7016      	strb	r6, [r2, #0]
                }
            }

        //sleep task 10s
        j = 0;
        chThdSleep(1000);
 80062aa:	2600      	movs	r6, #0
 80062ac:	46b0      	mov	r8, r6
 80062ae:	4c4f      	ldr	r4, [pc, #316]	; (80063ec <ThCurrentLimiter.14565+0x1ac>)
 80062b0:	f04f 0b00 	mov.w	fp, #0
        }

        while(t <= delayT){
            t++;

            while( j <=2 && currentTemp2[j] <= TEMP[j]){
 80062b4:	f855 002b 	ldr.w	r0, [r5, fp, lsl #2]
 80062b8:	f7fa fcf4 	bl	8000ca4 <__aeabi_i2f>
 80062bc:	f854 1f04 	ldr.w	r1, [r4, #4]!
            j++;
 80062c0:	f10b 0b01 	add.w	fp, fp, #1
        }

        while(t <= delayT){
            t++;

            while( j <=2 && currentTemp2[j] <= TEMP[j]){
 80062c4:	f7fa feec 	bl	80010a0 <__aeabi_fcmple>
 80062c8:	2800      	cmp	r0, #0
 80062ca:	d036      	beq.n	800633a <ThCurrentLimiter.14565+0xfa>
 80062cc:	f1bb 0f03 	cmp.w	fp, #3
 80062d0:	d1f0      	bne.n	80062b4 <ThCurrentLimiter.14565+0x74>
            if(j <= 2 && !hiteup ){
            hiteup= 1;
            t = 0;
            }
            else{
                if(hiteup && j >= 3){
 80062d2:	f89a 3000 	ldrb.w	r3, [sl]
 80062d6:	bb43      	cbnz	r3, 800632a <ThCurrentLimiter.14565+0xea>
           // errorLevel = 1;
            }
        }

        while(t <= delayT){
            t++;
 80062d8:	3601      	adds	r6, #1
                }
            }

        //sleep task 10s
        j = 0;
        chThdSleep(1000);
 80062da:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80062de:	f7fd fda7 	bl	8003e30 <chThdSleep>
           // else
           // errorLevel = 1;
            }
        }

        while(t <= delayT){
 80062e2:	2e64      	cmp	r6, #100	; 0x64
 80062e4:	dde3      	ble.n	80062ae <ThCurrentLimiter.14565+0x6e>
        //sleep task 10s
        j = 0;
        chThdSleep(1000);
        }

        if(hiteup){
 80062e6:	f89a 3000 	ldrb.w	r3, [sl]
 80062ea:	b36b      	cbz	r3, 8006348 <ThCurrentLimiter.14565+0x108>
            if(4 >> alert){
 80062ec:	f8d9 2000 	ldr.w	r2, [r9]
 80062f0:	493f      	ldr	r1, [pc, #252]	; (80063f0 <ThCurrentLimiter.14565+0x1b0>)
 80062f2:	2304      	movs	r3, #4
 80062f4:	fa53 f002 	asrs.w	r0, r3, r2
              ++alert;}
 80062f8:	bf1a      	itte	ne
 80062fa:	3201      	addne	r2, #1
 80062fc:	600a      	strne	r2, [r1, #0]
              else{
              alert = 4;
 80062fe:	600b      	streq	r3, [r1, #0]
            }
            }
        }

      //  i = 0;
        quit = 0;
 8006300:	4a39      	ldr	r2, [pc, #228]	; (80063e8 <ThCurrentLimiter.14565+0x1a8>)
 8006302:	2300      	movs	r3, #0
        t = 0;


        chThdSleep(100);
 8006304:	2064      	movs	r0, #100	; 0x64
            }
            }
        }

      //  i = 0;
        quit = 0;
 8006306:	7013      	strb	r3, [r2, #0]
        t = 0;


        chThdSleep(100);
 8006308:	f7fd fd92 	bl	8003e30 <chThdSleep>

   originCurrent = CanReadInt(currentLimitDeviceID, currentLimitUserRef);

    while( true ){

        if( alert == 0){
 800630c:	f8d9 6000 	ldr.w	r6, [r9]
 8006310:	2e00      	cmp	r6, #0
 8006312:	d0af      	beq.n	8006274 <ThCurrentLimiter.14565+0x34>
        i++;
        }
        i = 0;
      }
       else{
           if(alert >> 1 ){
 8006314:	0872      	lsrs	r2, r6, #1
 8006316:	d0c8      	beq.n	80062aa <ThCurrentLimiter.14565+0x6a>



void sendAlert(int a){

    switch(a){
 8006318:	2e03      	cmp	r6, #3
 800631a:	d04c      	beq.n	80063b6 <ThCurrentLimiter.14565+0x176>
 800631c:	2e04      	cmp	r6, #4
 800631e:	d043      	beq.n	80063a8 <ThCurrentLimiter.14565+0x168>
 8006320:	2e02      	cmp	r6, #2
 8006322:	d02d      	beq.n	8006380 <ThCurrentLimiter.14565+0x140>
        i = 0;
      }
       else{
           if(alert >> 1 ){
           sendAlert(alert);
           fn = 1;
 8006324:	2301      	movs	r3, #1
 8006326:	9301      	str	r3, [sp, #4]
 8006328:	e7bf      	b.n	80062aa <ThCurrentLimiter.14565+0x6a>
            hiteup= 1;
            t = 0;
            }
            else{
                if(hiteup && j >= 3){
                hiteup = 0;
 800632a:	f887 8000 	strb.w	r8, [r7]
                }
            }

        //sleep task 10s
        j = 0;
        chThdSleep(1000);
 800632e:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8006332:	f7fd fd7d 	bl	8003e30 <chThdSleep>
 8006336:	2600      	movs	r6, #0
 8006338:	e7b9      	b.n	80062ae <ThCurrentLimiter.14565+0x6e>
            t++;

            while( j <=2 && currentTemp2[j] <= TEMP[j]){
            j++;
            }
            if(j <= 2 && !hiteup ){
 800633a:	f89a 3000 	ldrb.w	r3, [sl]
 800633e:	2b00      	cmp	r3, #0
 8006340:	d1ca      	bne.n	80062d8 <ThCurrentLimiter.14565+0x98>
            hiteup= 1;
 8006342:	2301      	movs	r3, #1
 8006344:	703b      	strb	r3, [r7, #0]
 8006346:	e7f2      	b.n	800632e <ThCurrentLimiter.14565+0xee>
              alert = 4;
              }

        }
        else{
            if(alert >> 0){
 8006348:	f8d9 4000 	ldr.w	r4, [r9]
 800634c:	4b28      	ldr	r3, [pc, #160]	; (80063f0 <ThCurrentLimiter.14565+0x1b0>)
 800634e:	b114      	cbz	r4, 8006356 <ThCurrentLimiter.14565+0x116>
            alert--;}
 8006350:	3c01      	subs	r4, #1
 8006352:	601c      	str	r4, [r3, #0]
 8006354:	e7d4      	b.n	8006300 <ThCurrentLimiter.14565+0xc0>
            else{
            if(fn){
 8006356:	9a01      	ldr	r2, [sp, #4]
 8006358:	2a00      	cmp	r2, #0
 800635a:	d0d1      	beq.n	8006300 <ThCurrentLimiter.14565+0xc0>
void sendAlert(int a){

    switch(a){

        case 1 :{
            CanWriteDATA(currentLimitDeviceID, currentLimitUserRef,floatToIEEE745(originCurrent));
 800635c:	4b20      	ldr	r3, [pc, #128]	; (80063e0 <ThCurrentLimiter.14565+0x1a0>)
 800635e:	6818      	ldr	r0, [r3, #0]
 8006360:	f7fa fca0 	bl	8000ca4 <__aeabi_i2f>
 8006364:	f240 4153 	movw	r1, #1107	; 0x453
 8006368:	4602      	mov	r2, r0
 800636a:	2065      	movs	r0, #101	; 0x65
 800636c:	f7fd ffc8 	bl	8004300 <CanWriteDATA>
            if(alert >> 0){
            alert--;}
            else{
            if(fn){
            sendAlert(1);
            fn = 0;
 8006370:	9401      	str	r4, [sp, #4]
 8006372:	e7c5      	b.n	8006300 <ThCurrentLimiter.14565+0xc0>
 8006374:	481c      	ldr	r0, [pc, #112]	; (80063e8 <ThCurrentLimiter.14565+0x1a8>)
 8006376:	f8c9 b000 	str.w	fp, [r9]
 800637a:	2301      	movs	r3, #1
 800637c:	7003      	strb	r3, [r0, #0]
 800637e:	e794      	b.n	80062aa <ThCurrentLimiter.14565+0x6a>
            CanWriteDATA(currentLimitDeviceID, currentLimitUserRef,floatToIEEE745(originCurrent));

            }
            break;
        case 2 :{
            CanWriteDATA(currentLimitDeviceID, currentLimitUserRef,floatToIEEE745(originCurrent*0.8));
 8006380:	4b17      	ldr	r3, [pc, #92]	; (80063e0 <ThCurrentLimiter.14565+0x1a0>)
 8006382:	6818      	ldr	r0, [r3, #0]
 8006384:	f7fa f8e6 	bl	8000554 <__aeabi_i2d>
 8006388:	a30f      	add	r3, pc, #60	; (adr r3, 80063c8 <ThCurrentLimiter.14565+0x188>)
 800638a:	e9d3 2300 	ldrd	r2, r3, [r3]
        case 3:{
            CanWriteDATA(currentLimitDeviceID, currentLimitUserRef,floatToIEEE745(originCurrent*0.6));
            }
            break;
        case 4:{
            CanWriteDATA(currentLimitDeviceID, currentLimitUserRef,floatToIEEE745(originCurrent*0.5));
 800638e:	f7fa f947 	bl	8000620 <__aeabi_dmul>
 8006392:	f7fa fb7d 	bl	8000a90 <__aeabi_d2f>
 8006396:	f240 4153 	movw	r1, #1107	; 0x453
 800639a:	4602      	mov	r2, r0
 800639c:	2065      	movs	r0, #101	; 0x65
 800639e:	f7fd ffaf 	bl	8004300 <CanWriteDATA>
        i = 0;
      }
       else{
           if(alert >> 1 ){
           sendAlert(alert);
           fn = 1;
 80063a2:	2201      	movs	r2, #1
 80063a4:	9201      	str	r2, [sp, #4]
 80063a6:	e780      	b.n	80062aa <ThCurrentLimiter.14565+0x6a>
        case 3:{
            CanWriteDATA(currentLimitDeviceID, currentLimitUserRef,floatToIEEE745(originCurrent*0.6));
            }
            break;
        case 4:{
            CanWriteDATA(currentLimitDeviceID, currentLimitUserRef,floatToIEEE745(originCurrent*0.5));
 80063a8:	4b0d      	ldr	r3, [pc, #52]	; (80063e0 <ThCurrentLimiter.14565+0x1a0>)
 80063aa:	6818      	ldr	r0, [r3, #0]
 80063ac:	f7fa f8d2 	bl	8000554 <__aeabi_i2d>
 80063b0:	2200      	movs	r2, #0
 80063b2:	4b10      	ldr	r3, [pc, #64]	; (80063f4 <ThCurrentLimiter.14565+0x1b4>)
 80063b4:	e7eb      	b.n	800638e <ThCurrentLimiter.14565+0x14e>
        case 2 :{
            CanWriteDATA(currentLimitDeviceID, currentLimitUserRef,floatToIEEE745(originCurrent*0.8));
            }
            break;
        case 3:{
            CanWriteDATA(currentLimitDeviceID, currentLimitUserRef,floatToIEEE745(originCurrent*0.6));
 80063b6:	4b0a      	ldr	r3, [pc, #40]	; (80063e0 <ThCurrentLimiter.14565+0x1a0>)
 80063b8:	6818      	ldr	r0, [r3, #0]
 80063ba:	f7fa f8cb 	bl	8000554 <__aeabi_i2d>
 80063be:	a304      	add	r3, pc, #16	; (adr r3, 80063d0 <ThCurrentLimiter.14565+0x190>)
 80063c0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80063c4:	e7e3      	b.n	800638e <ThCurrentLimiter.14565+0x14e>
 80063c6:	bf00      	nop
 80063c8:	9999999a 	.word	0x9999999a
 80063cc:	3fe99999 	.word	0x3fe99999
 80063d0:	33333333 	.word	0x33333333
 80063d4:	3fe33333 	.word	0x3fe33333
 80063d8:	200016a8 	.word	0x200016a8
 80063dc:	08007660 	.word	0x08007660
 80063e0:	2000084c 	.word	0x2000084c
 80063e4:	2000268c 	.word	0x2000268c
 80063e8:	20002671 	.word	0x20002671
 80063ec:	2000168c 	.word	0x2000168c
 80063f0:	20002688 	.word	0x20002688
 80063f4:	3fe00000 	.word	0x3fe00000
 80063f8:	20002670 	.word	0x20002670
 80063fc:	00000000 	.word	0x00000000

08006400 <onotify.8139.4381>:
/**
 * @brief   Notification of data inserted into the output queue.
 *
 * @param[in] qp        the queue pointer.
 */
static void onotify(io_queue_t *qp) {
 8006400:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size_t n;
  SerialUSBDriver *sdup = qGetLink(qp);
 8006402:	6a04      	ldr	r4, [r0, #32]

  /* If the USB driver is not in the appropriate state then transactions
     must not be started.*/
  if ((usbGetDriverStateI(sdup->config->usbp) != USB_ACTIVE) ||
 8006404:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 8006408:	6813      	ldr	r3, [r2, #0]
 800640a:	7819      	ldrb	r1, [r3, #0]
 800640c:	2904      	cmp	r1, #4
 800640e:	d000      	beq.n	8006412 <onotify.8139.4381+0x12>
 8006410:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8006412:	7a21      	ldrb	r1, [r4, #8]
 8006414:	2902      	cmp	r1, #2
 8006416:	d1fb      	bne.n	8006410 <onotify.8139.4381+0x10>
    return;
  }

  /* If there is not an ongoing transaction and the output queue contains
     data then a new transaction is started.*/
  if (!usbGetTransmitStatusI(sdup->config->usbp, sdup->config->bulk_in)) {
 8006418:	7912      	ldrb	r2, [r2, #4]
 800641a:	891b      	ldrh	r3, [r3, #8]
 800641c:	2501      	movs	r5, #1
 800641e:	fa05 f202 	lsl.w	r2, r5, r2
 8006422:	4013      	ands	r3, r2
 8006424:	d1f4      	bne.n	8006410 <onotify.8139.4381+0x10>
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 8006426:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8006428:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800642a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800642c:	1a80      	subs	r0, r0, r2
    if ((n = oqGetFullI(&sdup->oqueue)) > 0U) {
 800642e:	1a46      	subs	r6, r0, r1
 8006430:	d0ee      	beq.n	8006410 <onotify.8139.4381+0x10>
 8006432:	f383 8811 	msr	BASEPRI, r3
      osalSysUnlock();

      usbPrepareQueuedTransmit(sdup->config->usbp,
 8006436:	f8d4 2254 	ldr.w	r2, [r4, #596]	; 0x254
 800643a:	6810      	ldr	r0, [r2, #0]
 800643c:	7911      	ldrb	r1, [r2, #4]
 *
 * @special
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800643e:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 8006442:	f104 0730 	add.w	r7, r4, #48	; 0x30
 8006446:	68d2      	ldr	r2, [r2, #12]
 8006448:	6952      	ldr	r2, [r2, #20]

  isp->txqueued           = true;
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
  isp->txcnt              = 0;
 800644a:	6093      	str	r3, [r2, #8]
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = true;
 800644c:	7015      	strb	r5, [r2, #0]
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
 800644e:	6056      	str	r6, [r2, #4]
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = true;
  isp->mode.queue.txqueue = oqp;
 8006450:	60d7      	str	r7, [r2, #12]
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 8006452:	f7ff fa5d 	bl	8005910 <usb_lld_prepare_transmit>
 8006456:	2320      	movs	r3, #32
 8006458:	f383 8811 	msr	BASEPRI, r3
                               sdup->config->bulk_in,
                               &sdup->oqueue, n);

      osalSysLock();
      (void) usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in);
 800645c:	f8d4 3254 	ldr.w	r3, [r4, #596]	; 0x254
 8006460:	6818      	ldr	r0, [r3, #0]
 8006462:	7919      	ldrb	r1, [r3, #4]
    }
  }
}
 8006464:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      usbPrepareQueuedTransmit(sdup->config->usbp,
                               sdup->config->bulk_in,
                               &sdup->oqueue, n);

      osalSysLock();
      (void) usbStartTransmitI(sdup->config->usbp, sdup->config->bulk_in);
 8006468:	f7ff ba12 	b.w	8005890 <usbStartTransmitI>
 800646c:	0000      	movs	r0, r0
	...

08006470 <Threadusbterm.16062>:
 *
 * @init
 */
void sduObjectInit(SerialUSBDriver *sdup) {

  sdup->vmt = &vmt;
 8006470:	4dbc      	ldr	r5, [pc, #752]	; (8006764 <Threadusbterm.16062+0x2f4>)
 8006472:	4ebd      	ldr	r6, [pc, #756]	; (8006768 <Threadusbterm.16062+0x2f8>)
 8006474:	4abd      	ldr	r2, [pc, #756]	; (800676c <Threadusbterm.16062+0x2fc>)
 8006476:	49be      	ldr	r1, [pc, #760]	; (8006770 <Threadusbterm.16062+0x300>)
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8006478:	f8df 931c 	ldr.w	r9, [pc, #796]	; 8006798 <Threadusbterm.16062+0x328>
 800647c:	4628      	mov	r0, r5
};



__attribute__((noreturn))
static THD_FUNCTION(Threadusbterm, arg) {
 800647e:	e92d 4888 	stmdb	sp!, {r3, r7, fp, lr}
 8006482:	69b3      	ldr	r3, [r6, #24]
 8006484:	f840 2b04 	str.w	r2, [r0], #4
 8006488:	6199      	str	r1, [r3, #24]
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 800648a:	f505 72aa 	add.w	r2, r5, #340	; 0x154
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 800648e:	f105 0154 	add.w	r1, r5, #84	; 0x54
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8006492:	f105 070c 	add.w	r7, r5, #12
 8006496:	f105 0430 	add.w	r4, r5, #48	; 0x30
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 800649a:	f8df e300 	ldr.w	lr, [pc, #768]	; 800679c <Threadusbterm.16062+0x32c>
 800649e:	6068      	str	r0, [r5, #4]
  osalEventObjectInit(&sdup->event);
  sdup->state = SDU_STOP;
 80064a0:	f04f 0a01 	mov.w	sl, #1
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80064a4:	2300      	movs	r3, #0
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80064a6:	f44f 7c80 	mov.w	ip, #256	; 0x100
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 80064aa:	f505 7815 	add.w	r8, r5, #596	; 0x254
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 80064ae:	616b      	str	r3, [r5, #20]
 80064b0:	f885 a008 	strb.w	sl, [r5, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 80064b4:	62ed      	str	r5, [r5, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 80064b6:	652d      	str	r5, [r5, #80]	; 0x50
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 80064b8:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 80064bc:	f8c5 8040 	str.w	r8, [r5, #64]	; 0x40
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 80064c0:	f8c5 c038 	str.w	ip, [r5, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 80064c4:	f8c5 e04c 	str.w	lr, [r5, #76]	; 0x4c
 80064c8:	60ef      	str	r7, [r5, #12]
  tqp->p_prev = (thread_t *)tqp;
 80064ca:	612f      	str	r7, [r5, #16]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 80064cc:	61a9      	str	r1, [r5, #24]
  iqp->q_rdptr   = bp;
 80064ce:	6269      	str	r1, [r5, #36]	; 0x24
  iqp->q_wrptr   = bp;
 80064d0:	6229      	str	r1, [r5, #32]
  iqp->q_top     = bp + size;
 80064d2:	61ea      	str	r2, [r5, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 80064d4:	63ea      	str	r2, [r5, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 80064d6:	64aa      	str	r2, [r5, #72]	; 0x48
  oqp->q_wrptr   = bp;
 80064d8:	646a      	str	r2, [r5, #68]	; 0x44
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80064da:	632c      	str	r4, [r5, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 80064dc:	636c      	str	r4, [r5, #52]	; 0x34
 80064de:	2020      	movs	r0, #32
 80064e0:	f380 8811 	msr	BASEPRI, r0
  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 80064e4:	4ca3      	ldr	r4, [pc, #652]	; (8006774 <Threadusbterm.16062+0x304>)
  usbp->out_params[config->bulk_out - 1U] = sdup;
  if (config->int_in > 0U) {
    usbp->in_params[config->int_in - 1U]  = sdup;
  }
  sdup->config = config;
 80064e6:	4aa4      	ldr	r2, [pc, #656]	; (8006778 <Threadusbterm.16062+0x308>)
 80064e8:	f8c5 2254 	str.w	r2, [r5, #596]	; 0x254
  sdup->state = SDU_READY;
 80064ec:	2202      	movs	r2, #2
 80064ee:	722a      	strb	r2, [r5, #8]
  osalDbgCheck(sdup != NULL);

  osalSysLock();
  osalDbgAssert((sdup->state == SDU_STOP) || (sdup->state == SDU_READY),
                "invalid state");
  usbp->in_params[config->bulk_in - 1U]   = sdup;
 80064f0:	61e5      	str	r5, [r4, #28]
  usbp->out_params[config->bulk_out - 1U] = sdup;
 80064f2:	62a5      	str	r5, [r4, #40]	; 0x28
  if (config->int_in > 0U) {
    usbp->in_params[config->int_in - 1U]  = sdup;
 80064f4:	6225      	str	r5, [r4, #32]
 80064f6:	f383 8811 	msr	BASEPRI, r3
   * Activates the USB driver and then the USB bus pull-up on D+.
   * Note, a delay is inserted in order to not have to disconnect the cable
   * after a reset.
   */

    usbDisconnectBus(serusbcfg.usbp);
 80064fa:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80064fc:	6b91      	ldr	r1, [r2, #56]	; 0x38
 80064fe:	f421 2100 	bic.w	r1, r1, #524288	; 0x80000
 8006502:	6391      	str	r1, [r2, #56]	; 0x38
 8006504:	f380 8811 	msr	BASEPRI, r0
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;

  if (usbp->state == USB_STOP) {
 8006508:	f894 9000 	ldrb.w	r9, [r4]
  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 800650c:	4a9b      	ldr	r2, [pc, #620]	; (800677c <Threadusbterm.16062+0x30c>)
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
 800650e:	60e3      	str	r3, [r4, #12]
 8006510:	45d1      	cmp	r9, sl
 8006512:	6123      	str	r3, [r4, #16]
 8006514:	6163      	str	r3, [r4, #20]
 8006516:	61a3      	str	r3, [r4, #24]
  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 8006518:	6062      	str	r2, [r4, #4]
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
 800651a:	f8d4 8050 	ldr.w	r8, [r4, #80]	; 0x50

  if (usbp->state == USB_STOP) {
 800651e:	f000 80a7 	beq.w	8006670 <Threadusbterm.16062+0x200>
 8006522:	4f97      	ldr	r7, [pc, #604]	; (8006780 <Threadusbterm.16062+0x310>)
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
  usbp->state = USB_READY;
 8006524:	2302      	movs	r3, #2
 8006526:	7023      	strb	r3, [r4, #0]
 8006528:	2200      	movs	r2, #0
 800652a:	f382 8811 	msr	BASEPRI, r2
    usbStart(serusbcfg.usbp, &usbcfg);
    usbConnectBus(serusbcfg.usbp);
 800652e:	6d23      	ldr	r3, [r4, #80]	; 0x50
 8006530:	f8df 8258 	ldr.w	r8, [pc, #600]	; 800678c <Threadusbterm.16062+0x31c>
 8006534:	6b99      	ldr	r1, [r3, #56]	; 0x38
 8006536:	f8df a268 	ldr.w	sl, [pc, #616]	; 80067a0 <Threadusbterm.16062+0x330>
 800653a:	f8df 9268 	ldr.w	r9, [pc, #616]	; 80067a4 <Threadusbterm.16062+0x334>
 800653e:	f441 2100 	orr.w	r1, r1, #524288	; 0x80000
__attribute__((noreturn))
static THD_FUNCTION(Threadusbterm, arg) {
    (void) arg;
    chRegSetThreadName("usbterm");

    thread_t *shelltp = NULL;
 8006542:	4614      	mov	r4, r2
   * after a reset.
   */

    usbDisconnectBus(serusbcfg.usbp);
    usbStart(serusbcfg.usbp, &usbcfg);
    usbConnectBus(serusbcfg.usbp);
 8006544:	6399      	str	r1, [r3, #56]	; 0x38

    /** a shell respawn upon its termination. */
    while(TRUE) {

        //sdWrite(&SD3, (uint8_t *) data, strlen(data));
    if (!shelltp) {
 8006546:	b144      	cbz	r4, 800655a <Threadusbterm.16062+0xea>
        shelltp = shellCreate(&shell_cfg1, SHELL_WA_SIZE, NORMALPRIO);
      }
    }
    else {
      /* If the previous shell exited.*/
     if (chThdTerminatedX(shelltp)) {
 8006548:	7f23      	ldrb	r3, [r4, #28]
 800654a:	2b0f      	cmp	r3, #15
 800654c:	d06f      	beq.n	800662e <Threadusbterm.16062+0x1be>
        /* Recovers memory of the previous shell.*/
        chThdRelease(shelltp);
        shelltp = NULL;
      }
    }
     chThdSleepMilliseconds(1000);//500);
 800654e:	f242 7010 	movw	r0, #10000	; 0x2710
 8006552:	f7fd fc6d 	bl	8003e30 <chThdSleep>

    /** a shell respawn upon its termination. */
    while(TRUE) {

        //sdWrite(&SD3, (uint8_t *) data, strlen(data));
    if (!shelltp) {
 8006556:	2c00      	cmp	r4, #0
 8006558:	d1f6      	bne.n	8006548 <Threadusbterm.16062+0xd8>
    //shelltp = shellCreate(&shell_cfg2, SHELL_WA_SIZE, NORMALPRIO);
      if (SDU1.config->usbp->state == USB_ACTIVE) {
 800655a:	f8d5 3254 	ldr.w	r3, [r5, #596]	; 0x254
 800655e:	681b      	ldr	r3, [r3, #0]
 8006560:	781b      	ldrb	r3, [r3, #0]
 8006562:	2b04      	cmp	r3, #4
 8006564:	d1f3      	bne.n	800654e <Threadusbterm.16062+0xde>
 8006566:	2320      	movs	r3, #32
 8006568:	f383 8811 	msr	BASEPRI, r3
 800656c:	4885      	ldr	r0, [pc, #532]	; (8006784 <Threadusbterm.16062+0x314>)
 800656e:	f7fb f9d7 	bl	8001920 <chMtxLockS>
 8006572:	f384 8811 	msr	BASEPRI, r4
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;
 8006576:	4a84      	ldr	r2, [pc, #528]	; (8006788 <Threadusbterm.16062+0x318>)

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 8006578:	f640 00c7 	movw	r0, #2247	; 0x8c7
 800657c:	e003      	b.n	8006586 <Threadusbterm.16062+0x116>
 800657e:	6859      	ldr	r1, [r3, #4]
 8006580:	4281      	cmp	r1, r0
 8006582:	d859      	bhi.n	8006638 <Threadusbterm.16062+0x1c8>
 8006584:	461a      	mov	r2, r3

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 8006586:	6813      	ldr	r3, [r2, #0]
 8006588:	2b00      	cmp	r3, #0
 800658a:	d1f8      	bne.n	800657e <Threadusbterm.16062+0x10e>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 800658c:	487d      	ldr	r0, [pc, #500]	; (8006784 <Threadusbterm.16062+0x314>)
 800658e:	f7fb f98f 	bl	80018b0 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 8006592:	f8d8 3000 	ldr.w	r3, [r8]
 8006596:	2b00      	cmp	r3, #0
 8006598:	d0d9      	beq.n	800654e <Threadusbterm.16062+0xde>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 800659a:	f44f 600d 	mov.w	r0, #2256	; 0x8d0
 800659e:	4798      	blx	r3
    if (hp != NULL) {
 80065a0:	2800      	cmp	r0, #0
 80065a2:	d0d4      	beq.n	800654e <Threadusbterm.16062+0xde>
      hp->h.u.heap = heapp;
 80065a4:	4a79      	ldr	r2, [pc, #484]	; (800678c <Threadusbterm.16062+0x31c>)
      hp->h.size = size;
 80065a6:	f640 03c8 	movw	r3, #2248	; 0x8c8
 80065aa:	e880 000c 	stmia.w	r0, {r2, r3}
      hp++;

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)hp;
 80065ae:	f100 0408 	add.w	r4, r0, #8
  if (wsp == NULL) {
    return NULL;
  }
  
#if CH_DBG_FILL_THREADS == TRUE
  _thread_memfill((uint8_t *)wsp,
 80065b2:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80065b6:	4622      	mov	r2, r4
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
    *startp++ = v;
 80065b8:	21ff      	movs	r1, #255	; 0xff
 80065ba:	f802 1b01 	strb.w	r1, [r2], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80065be:	4293      	cmp	r3, r2
 80065c0:	d1fb      	bne.n	80065ba <Threadusbterm.16062+0x14a>
                  (uint8_t *)wsp + sizeof(thread_t),
                  CH_DBG_THREAD_FILL_VALUE);
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
 80065c2:	f604 01c8 	addw	r1, r4, #2248	; 0x8c8
    *startp++ = v;
 80065c6:	2255      	movs	r2, #85	; 0x55
 80065c8:	f803 2b01 	strb.w	r2, [r3], #1
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {

  while (startp < endp) {
 80065cc:	4299      	cmp	r1, r3
 80065ce:	d1fb      	bne.n	80065c8 <Threadusbterm.16062+0x158>
 80065d0:	2320      	movs	r3, #32
 80065d2:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80065d6:	2202      	movs	r2, #2
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80065d8:	6970      	ldr	r0, [r6, #20]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 80065da:	7722      	strb	r2, [r4, #28]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80065dc:	f604 01a4 	addw	r1, r4, #2212	; 0x8a4
 80065e0:	60e1      	str	r1, [r4, #12]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80065e2:	2340      	movs	r3, #64	; 0x40
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80065e4:	f04f 0b00 	mov.w	fp, #0
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80065e8:	2101      	movs	r1, #1
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 80065ea:	f104 0228 	add.w	r2, r4, #40	; 0x28
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80065ee:	f104 0e24 	add.w	lr, r4, #36	; 0x24
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80065f2:	6160      	str	r0, [r4, #20]
 80065f4:	6126      	str	r6, [r4, #16]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80065f6:	60a3      	str	r3, [r4, #8]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80065f8:	f8c4 a8a4 	str.w	sl, [r4, #2212]	; 0x8a4
 80065fc:	f8c4 98a8 	str.w	r9, [r4, #2216]	; 0x8a8
 8006600:	f8c4 78c4 	str.w	r7, [r4, #2244]	; 0x8c4
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8006604:	63e3      	str	r3, [r4, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8006606:	f8c4 b038 	str.w	fp, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800660a:	f8c4 b034 	str.w	fp, [r4, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 800660e:	f8c4 b018 	str.w	fp, [r4, #24]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8006612:	77a1      	strb	r1, [r4, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8006614:	6104      	str	r4, [r0, #16]
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 8006616:	4620      	mov	r0, r4
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8006618:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
                  CH_DBG_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_HEAP;
 800661c:	7761      	strb	r1, [r4, #29]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800661e:	62a2      	str	r2, [r4, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8006620:	62e2      	str	r2, [r4, #44]	; 0x2c
 8006622:	6174      	str	r4, [r6, #20]
  chSchWakeupS(tp, MSG_OK);
 8006624:	f7fe feb4 	bl	8005390 <chSchWakeupS.constprop.49>
 8006628:	f38b 8811 	msr	BASEPRI, fp
 800662c:	e78f      	b.n	800654e <Threadusbterm.16062+0xde>
    }
    else {
      /* If the previous shell exited.*/
     if (chThdTerminatedX(shelltp)) {
        /* Recovers memory of the previous shell.*/
        chThdRelease(shelltp);
 800662e:	4620      	mov	r0, r4
 8006630:	f7fb f9de 	bl	80019f0 <chThdRelease>
        shelltp = NULL;
 8006634:	2400      	movs	r4, #0
 8006636:	e78a      	b.n	800654e <Threadusbterm.16062+0xde>

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
      if (hp->h.size < (size + sizeof(union heap_header))) {
 8006638:	f5b1 6f0d 	cmp.w	r1, #2256	; 0x8d0
 800663c:	d20a      	bcs.n	8006654 <Threadusbterm.16062+0x1e4>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 800663e:	6819      	ldr	r1, [r3, #0]
 8006640:	6011      	str	r1, [r2, #0]
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8006642:	461c      	mov	r4, r3
      H_UNLOCK(heapp);
 8006644:	484f      	ldr	r0, [pc, #316]	; (8006784 <Threadusbterm.16062+0x314>)
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
      }
      hp->h.u.heap = heapp;
 8006646:	f844 8b08 	str.w	r8, [r4], #8
      H_UNLOCK(heapp);
 800664a:	f7fb f931 	bl	80018b0 <chMtxUnlock>
                              tprio_t prio, tfunc_t pf, void *arg) {
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
  if (wsp == NULL) {
 800664e:	2c00      	cmp	r4, #0
 8006650:	d1af      	bne.n	80065b2 <Threadusbterm.16062+0x142>
 8006652:	e77c      	b.n	800654e <Threadusbterm.16062+0xde>
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 8006654:	681c      	ldr	r4, [r3, #0]
 8006656:	f8c3 48d0 	str.w	r4, [r3, #2256]	; 0x8d0
 800665a:	f503 600d 	add.w	r0, r3, #2256	; 0x8d0
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 800665e:	f5a1 610d 	sub.w	r1, r1, #2256	; 0x8d0
        qp->h.u.next = fp;
        hp->h.size = size;
 8006662:	f640 04c8 	movw	r4, #2248	; 0x8c8
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 8006666:	f8c3 18d4 	str.w	r1, [r3, #2260]	; 0x8d4
        qp->h.u.next = fp;
 800666a:	6010      	str	r0, [r2, #0]
        hp->h.size = size;
 800666c:	605c      	str	r4, [r3, #4]
 800666e:	e7e8      	b.n	8006642 <Threadusbterm.16062+0x1d2>
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(FALSE);
 8006670:	4a47      	ldr	r2, [pc, #284]	; (8006790 <Threadusbterm.16062+0x320>)
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8006672:	6d27      	ldr	r7, [r4, #80]	; 0x50
  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(FALSE);
 8006674:	f8d2 a034 	ldr.w	sl, [r2, #52]	; 0x34
      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG2_NUMBER, STM32_USB_OTG2_IRQ_PRIORITY);
    }
#endif

    usbp->txpending = 0;
 8006678:	65e3      	str	r3, [r4, #92]	; 0x5c
  if (usbp->state == USB_STOP) {
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(FALSE);
 800667a:	f04a 0a80 	orr.w	sl, sl, #128	; 0x80
 800667e:	f8c2 a034 	str.w	sl, [r2, #52]	; 0x34
      rccResetOTG_FS();
 8006682:	f8d2 b014 	ldr.w	fp, [r2, #20]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006686:	4943      	ldr	r1, [pc, #268]	; (8006794 <Threadusbterm.16062+0x324>)
    usbp->txpending = 0;

    /* - Forced device mode.
       - USB turn-around time = TRDT_VALUE.
       - Full Speed 1.1 PHY.*/
    otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE) | GUSBCFG_PHYSEL;
 8006688:	f8df c11c 	ldr.w	ip, [pc, #284]	; 80067a8 <Threadusbterm.16062+0x338>

    /* 48MHz 1.1 PHY.*/
    otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 800668c:	f8df e11c 	ldr.w	lr, [pc, #284]	; 80067ac <Threadusbterm.16062+0x33c>
    /* Clock activation.*/
#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(FALSE);
      rccResetOTG_FS();
 8006690:	f04b 0b80 	orr.w	fp, fp, #128	; 0x80
 8006694:	f8c2 b014 	str.w	fp, [r2, #20]
 8006698:	f04f 0ae0 	mov.w	sl, #224	; 0xe0
 800669c:	6153      	str	r3, [r2, #20]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800669e:	f04f 0b08 	mov.w	fp, #8
    /* Internal FS PHY activation.*/
#if defined(BOARD_OTG_NOVBUSSENS)
    otgp->GCCFG = GCCFG_NOVBUSSENS | GCCFG_VBUSASEN | GCCFG_VBUSBSEN |
                  GCCFG_PWRDWN;
#else
    otgp->GCCFG = GCCFG_VBUSASEN | GCCFG_VBUSBSEN | GCCFG_PWRDWN;
 80066a2:	f44f 2250 	mov.w	r2, #851968	; 0xd0000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80066a6:	f881 a343 	strb.w	sl, [r1, #835]	; 0x343
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80066aa:	f8c1 b188 	str.w	fp, [r1, #392]	; 0x188
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80066ae:	f8c1 b008 	str.w	fp, [r1, #8]
    usbp->txpending = 0;

    /* - Forced device mode.
       - USB turn-around time = TRDT_VALUE.
       - Full Speed 1.1 PHY.*/
    otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE) | GUSBCFG_PHYSEL;
 80066b2:	f8c8 c00c 	str.w	ip, [r8, #12]

    /* 48MHz 1.1 PHY.*/
    otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 80066b6:	f8c8 e800 	str.w	lr, [r8, #2048]	; 0x800

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 80066ba:	f8c8 3e00 	str.w	r3, [r8, #3584]	; 0xe00
    /* Internal FS PHY activation.*/
#if defined(BOARD_OTG_NOVBUSSENS)
    otgp->GCCFG = GCCFG_NOVBUSSENS | GCCFG_VBUSASEN | GCCFG_VBUSBSEN |
                  GCCFG_PWRDWN;
#else
    otgp->GCCFG = GCCFG_VBUSASEN | GCCFG_VBUSBSEN | GCCFG_PWRDWN;
 80066be:	f8c8 2038 	str.w	r2, [r8, #56]	; 0x38
 80066c2:	f7fb fcc5 	bl	8002050 <chSysPolledDelayX>
  stm32_otg_t *otgp = usbp->otg;

  osalSysPolledDelayX(32);

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 80066c6:	f8c7 9010 	str.w	r9, [r7, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 80066ca:	693b      	ldr	r3, [r7, #16]
 80066cc:	07db      	lsls	r3, r3, #31
 80066ce:	d4fc      	bmi.n	80066ca <Threadusbterm.16062+0x25a>
 80066d0:	200c      	movs	r0, #12
 80066d2:	f7fb fcbd 	bl	8002050 <chSysPolledDelayX>
    ;

  osalSysPolledDelayX(12);

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 80066d6:	693b      	ldr	r3, [r7, #16]
 80066d8:	2b00      	cmp	r3, #0
 80066da:	dafc      	bge.n	80066d6 <Threadusbterm.16062+0x266>
 80066dc:	6d63      	ldr	r3, [r4, #84]	; 0x54
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 80066de:	6d27      	ldr	r7, [r4, #80]	; 0x50
 80066e0:	f8d3 c008 	ldr.w	ip, [r3, #8]

    /* Soft core reset.*/
    otg_core_reset(usbp);

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 80066e4:	2300      	movs	r3, #0

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80066e6:	461a      	mov	r2, r3

    /* Soft core reset.*/
    otg_core_reset(usbp);

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 80066e8:	f8c8 3008 	str.w	r3, [r8, #8]
static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
    otgp->ie[i].DIEPCTL = 0;
 80066ec:	4619      	mov	r1, r3
    otgp->ie[i].DIEPTSIZ = 0;
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80066ee:	f04f 3eff 	mov.w	lr, #4294967295
 80066f2:	eb07 1342 	add.w	r3, r7, r2, lsl #5

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80066f6:	3201      	adds	r2, #1
 80066f8:	4562      	cmp	r2, ip
    otgp->ie[i].DIEPCTL = 0;
 80066fa:	f8c3 1900 	str.w	r1, [r3, #2304]	; 0x900
 80066fe:	f04f 0000 	mov.w	r0, #0
    otgp->ie[i].DIEPTSIZ = 0;
 8006702:	f8c3 1910 	str.w	r1, [r3, #2320]	; 0x910
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 8006706:	f8c3 e908 	str.w	lr, [r3, #2312]	; 0x908

    otgp->oe[i].DOEPCTL = 0;
 800670a:	f8c3 1b00 	str.w	r1, [r3, #2816]	; 0xb00
    otgp->oe[i].DOEPTSIZ = 0;
 800670e:	f8c3 1b10 	str.w	r1, [r3, #2832]	; 0xb10
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 8006712:	f8c3 eb08 	str.w	lr, [r3, #2824]	; 0xb08

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8006716:	d9ec      	bls.n	80066f2 <Threadusbterm.16062+0x282>
    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
 8006718:	6863      	ldr	r3, [r4, #4]
 800671a:	68db      	ldr	r3, [r3, #12]

    otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800671c:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8006720:	f8c7 281c 	str.w	r2, [r7, #2076]	; 0x81c
    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8006724:	f8c8 0810 	str.w	r0, [r8, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 8006728:	f8c8 0814 	str.w	r0, [r8, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 800672c:	f8c8 081c 	str.w	r0, [r8, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8006730:	b193      	cbz	r3, 8006758 <Threadusbterm.16062+0x2e8>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM  |*/;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
 8006732:	f243 0308 	movw	r3, #12296	; 0x3008
 8006736:	f8c8 3018 	str.w	r3, [r8, #24]
                       GINTMSK_ESUSPM */ | GINTMSK_SOFM;
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 800673a:	6e62      	ldr	r2, [r4, #100]	; 0x64
 800673c:	4b0d      	ldr	r3, [pc, #52]	; (8006774 <Threadusbterm.16062+0x304>)
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM  |*/;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
                       GINTMSK_ESUSPM */ | GINTMSK_SOFM;
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */
 800673e:	f04f 31ff 	mov.w	r1, #4294967295
 8006742:	f8c8 1014 	str.w	r1, [r8, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 8006746:	b39a      	cbz	r2, 80067b0 <Threadusbterm.16062+0x340>
 8006748:	4f0d      	ldr	r7, [pc, #52]	; (8006780 <Threadusbterm.16062+0x310>)
      chSchRescheduleS();
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 800674a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800674e:	f043 0301 	orr.w	r3, r3, #1
 8006752:	f8c8 3008 	str.w	r3, [r8, #8]
 8006756:	e6e5      	b.n	8006524 <Threadusbterm.16062+0xb4>
       is required initially.*/
    otgp->DIEPMSK  = 0;
    otgp->DOEPMSK  = 0;
    otgp->DAINTMSK = 0;
    if (usbp->config->sof_cb == NULL)
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM /*| GINTMSK_USBSUSPM |
 8006758:	f44f 5340 	mov.w	r3, #12288	; 0x3000
 800675c:	f8c8 3018 	str.w	r3, [r8, #24]
 8006760:	e7eb      	b.n	800673a <Threadusbterm.16062+0x2ca>
 8006762:	bf00      	nop
 8006764:	20002418 	.word	0x20002418
 8006768:	200016a8 	.word	0x200016a8
 800676c:	08007630 	.word	0x08007630
 8006770:	08007674 	.word	0x08007674
 8006774:	200011b8 	.word	0x200011b8
 8006778:	08006dd0 	.word	0x08006dd0
 800677c:	08007650 	.word	0x08007650
 8006780:	08000291 	.word	0x08000291
 8006784:	20001d90 	.word	0x20001d90
 8006788:	20001d88 	.word	0x20001d88
 800678c:	20001d80 	.word	0x20001d80
 8006790:	40023800 	.word	0x40023800
 8006794:	e000e100 	.word	0xe000e100
 8006798:	080059b1 	.word	0x080059b1
 800679c:	08006401 	.word	0x08006401
 80067a0:	08002ca1 	.word	0x08002ca1
 80067a4:	08007620 	.word	0x08007620
 80067a8:	40001440 	.word	0x40001440
 80067ac:	02200003 	.word	0x02200003
 80067b0:	f8d6 e014 	ldr.w	lr, [r6, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80067b4:	f8df 9070 	ldr.w	r9, [pc, #112]	; 8006828 <Threadusbterm.16062+0x3b8>
 80067b8:	4f1a      	ldr	r7, [pc, #104]	; (8006824 <Threadusbterm.16062+0x3b4>)
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80067ba:	f883 2085 	strb.w	r2, [r3, #133]	; 0x85
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80067be:	f103 0168 	add.w	r1, r3, #104	; 0x68
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80067c2:	2002      	movs	r0, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80067c4:	f503 7ac6 	add.w	sl, r3, #396	; 0x18c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80067c8:	f04f 0c01 	mov.w	ip, #1
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80067cc:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 80067d0:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80067d4:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
  REG_INSERT(tp);
 80067d8:	f8c3 e07c 	str.w	lr, [r3, #124]	; 0x7c
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80067dc:	6718      	str	r0, [r3, #112]	; 0x70
  tp->p_state = CH_STATE_WTSTART;
 80067de:	f883 0084 	strb.w	r0, [r3, #132]	; 0x84
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80067e2:	f8c3 00a4 	str.w	r0, [r3, #164]	; 0xa4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80067e6:	f103 0290 	add.w	r2, r3, #144	; 0x90

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80067ea:	f8c3 3190 	str.w	r3, [r3, #400]	; 0x190
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80067ee:	679e      	str	r6, [r3, #120]	; 0x78

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80067f0:	f8c3 a074 	str.w	sl, [r3, #116]	; 0x74
 80067f4:	f8c3 918c 	str.w	r9, [r3, #396]	; 0x18c
 80067f8:	f8c3 71ac 	str.w	r7, [r3, #428]	; 0x1ac
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80067fc:	f883 c086 	strb.w	ip, [r3, #134]	; 0x86
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8006800:	f8ce 1010 	str.w	r1, [lr, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8006804:	f103 0e8c 	add.w	lr, r3, #140	; 0x8c
 */
static inline thread_t *chThdStartI(thread_t *tp) {

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 8006808:	4608      	mov	r0, r1
 800680a:	f8c3 e08c 	str.w	lr, [r3, #140]	; 0x8c
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800680e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  tqp->p_prev = (thread_t *)tqp;
 8006812:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
 8006816:	6171      	str	r1, [r6, #20]
    otgp->GINTSTS  = 0xFFFFFFFF;         /* Clears all pending IRQs, if any. */

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 8006818:	6659      	str	r1, [r3, #100]	; 0x64
 800681a:	f7fa ffc1 	bl	80017a0 <chSchReadyI>
                              STM32_USB_OTG_THREAD_PRIO,
                              usb_lld_pump, usbp);
      chThdStartI(usbp->tr);
      chSchRescheduleS();
 800681e:	f7fa ff97 	bl	8001750 <chSchRescheduleS>
 8006822:	e792      	b.n	800674a <Threadusbterm.16062+0x2da>
 8006824:	08000291 	.word	0x08000291
 8006828:	08001b31 	.word	0x08001b31
 800682c:	00000000 	.word	0x00000000

08006830 <sduDataTransmitted>:
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8006830:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8006832:	eb00 0381 	add.w	r3, r0, r1, lsl #2
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 8006836:	4606      	mov	r6, r0
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];
 8006838:	699c      	ldr	r4, [r3, #24]
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataTransmitted(USBDriver *usbp, usbep_t ep) {
 800683a:	460d      	mov	r5, r1
  size_t n;
  SerialUSBDriver *sdup = usbp->in_params[ep - 1U];

  if (sdup == NULL) {
 800683c:	b1ac      	cbz	r4, 800686a <sduDataTransmitted+0x3a>
 800683e:	2720      	movs	r7, #32
 8006840:	f387 8811 	msr	BASEPRI, r7
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8006844:	2108      	movs	r1, #8
 8006846:	1d20      	adds	r0, r4, #4
 8006848:	f7fa ffc2 	bl	80017d0 <chEvtBroadcastFlagsI>
 800684c:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800684e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8006850:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8006852:	1a8a      	subs	r2, r1, r2

  osalSysLockFromISR();
  chnAddFlagsI(sdup, CHN_OUTPUT_EMPTY);

  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if ((n = oqGetFullI(&sdup->oqueue)) > 0U) {
 8006854:	1ad3      	subs	r3, r2, r3
 8006856:	d118      	bne.n	800688a <sduDataTransmitted+0x5a>
 8006858:	eb06 0185 	add.w	r1, r6, r5, lsl #2
    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, n);

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 800685c:	68ca      	ldr	r2, [r1, #12]
 800685e:	6953      	ldr	r3, [r2, #20]
 8006860:	685b      	ldr	r3, [r3, #4]
 8006862:	b91b      	cbnz	r3, 800686c <sduDataTransmitted+0x3c>
 8006864:	2300      	movs	r3, #0
 8006866:	f383 8811 	msr	BASEPRI, r3
 800686a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
           ((usbp->epc[ep]->in_state->txsize &
            ((size_t)usbp->epc[ep]->in_maxsize - 1U)) == 0U)) {
 800686c:	8a12      	ldrh	r2, [r2, #16]
 800686e:	3a01      	subs	r2, #1
    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, n);

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
  }
  else if ((usbp->epc[ep]->in_state->txsize > 0U) &&
 8006870:	4013      	ands	r3, r2
 8006872:	d1f7      	bne.n	8006864 <sduDataTransmitted+0x34>
 8006874:	f383 8811 	msr	BASEPRI, r3
 *
 * @special
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8006878:	68ca      	ldr	r2, [r1, #12]
 800687a:	6952      	ldr	r2, [r2, #20]
       size. Otherwise the recipient may expect more data coming soon and
       not return buffered data to app. See section 5.8.3 Bulk Transfer
       Packet Size Constraints of the USB Specification document.*/
    osalSysUnlockFromISR();

    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, 0);
 800687c:	3430      	adds	r4, #48	; 0x30

  isp->txqueued           = true;
 800687e:	2101      	movs	r1, #1
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
 8006880:	6053      	str	r3, [r2, #4]
  isp->txcnt              = 0;
 8006882:	6093      	str	r3, [r2, #8]
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = true;
  isp->mode.queue.txqueue = oqp;
 8006884:	60d4      	str	r4, [r2, #12]
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = true;
 8006886:	7011      	strb	r1, [r2, #0]
 8006888:	e00c      	b.n	80068a4 <sduDataTransmitted+0x74>
 800688a:	2200      	movs	r2, #0
 800688c:	f382 8811 	msr	BASEPRI, r2
 *
 * @special
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 8006890:	eb06 0185 	add.w	r1, r6, r5, lsl #2
  if ((n = oqGetFullI(&sdup->oqueue)) > 0U) {
    /* The endpoint cannot be busy, we are in the context of the callback,
       so it is safe to transmit without a check.*/
    osalSysUnlockFromISR();

    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, n);
 8006894:	3430      	adds	r4, #48	; 0x30
 8006896:	68c9      	ldr	r1, [r1, #12]
 8006898:	6949      	ldr	r1, [r1, #20]

  isp->txqueued           = true;
 800689a:	2001      	movs	r0, #1
  isp->mode.queue.txqueue = oqp;
 800689c:	60cc      	str	r4, [r1, #12]
  isp->txsize             = n;
 800689e:	604b      	str	r3, [r1, #4]
  isp->txcnt              = 0;
 80068a0:	608a      	str	r2, [r1, #8]
 */
void usbPrepareQueuedTransmit(USBDriver *usbp, usbep_t ep,
                              output_queue_t *oqp, size_t n) {
  USBInEndpointState *isp = usbp->epc[ep]->in_state;

  isp->txqueued           = true;
 80068a2:	7008      	strb	r0, [r1, #0]
  isp->mode.queue.txqueue = oqp;
  isp->txsize             = n;
  isp->txcnt              = 0;

  usb_lld_prepare_transmit(usbp, ep);
 80068a4:	4630      	mov	r0, r6
 80068a6:	4629      	mov	r1, r5
 80068a8:	f7ff f832 	bl	8005910 <usb_lld_prepare_transmit>
 80068ac:	f387 8811 	msr	BASEPRI, r7
    osalSysUnlockFromISR();

    usbPrepareQueuedTransmit(usbp, ep, &sdup->oqueue, 0);

    osalSysLockFromISR();
    (void) usbStartTransmitI(usbp, ep);
 80068b0:	4630      	mov	r0, r6
 80068b2:	4629      	mov	r1, r5
 80068b4:	f7fe ffec 	bl	8005890 <usbStartTransmitI>
 80068b8:	e7d4      	b.n	8006864 <sduDataTransmitted+0x34>
 80068ba:	bf00      	nop
 80068bc:	0000      	movs	r0, r0
	...

080068c0 <sduDataReceived>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
  size_t n, maxsize;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 80068c0:	f101 0309 	add.w	r3, r1, #9
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 80068c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  size_t n, maxsize;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];
 80068c8:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 *          data endpoint.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 */
void sduDataReceived(USBDriver *usbp, usbep_t ep) {
 80068cc:	460d      	mov	r5, r1
 80068ce:	4606      	mov	r6, r0
  size_t n, maxsize;
  SerialUSBDriver *sdup = usbp->out_params[ep - 1U];

  if (sdup == NULL) {
 80068d0:	b1bc      	cbz	r4, 8006902 <sduDataReceived+0x42>
 80068d2:	2720      	movs	r7, #32
 80068d4:	f387 8811 	msr	BASEPRI, r7
 80068d8:	2104      	movs	r1, #4
 80068da:	1860      	adds	r0, r4, r1
 80068dc:	f7fa ff78 	bl	80017d0 <chEvtBroadcastFlagsI>
 80068e0:	eb06 0185 	add.w	r1, r6, r5, lsl #2
 */
static inline size_t chIQGetEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (size_t)(chQSizeX(iqp) - chQSpaceI(iqp));
 80068e4:	69a2      	ldr	r2, [r4, #24]
  osalSysLockFromISR();
  chnAddFlagsI(sdup, CHN_INPUT_AVAILABLE);

  /* Writes to the input queue can only happen when there is enough space
     to hold at least one packet.*/
  maxsize = usbp->epc[ep]->out_maxsize;
 80068e6:	68c8      	ldr	r0, [r1, #12]
 80068e8:	f8d4 8014 	ldr.w	r8, [r4, #20]
 80068ec:	8a43      	ldrh	r3, [r0, #18]
 80068ee:	69e0      	ldr	r0, [r4, #28]
 80068f0:	ebc2 0c00 	rsb	ip, r2, r0
 80068f4:	ebc8 020c 	rsb	r2, r8, ip
  if ((n = iqGetEmptyI(&sdup->iqueue)) >= maxsize) {
 80068f8:	4293      	cmp	r3, r2
 80068fa:	d904      	bls.n	8006906 <sduDataReceived+0x46>
 80068fc:	2300      	movs	r3, #0
 80068fe:	f383 8811 	msr	BASEPRI, r3
 8006902:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8006906:	2000      	movs	r0, #0
 8006908:	f380 8811 	msr	BASEPRI, r0
 *
 * @special
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 800690c:	68c9      	ldr	r1, [r1, #12]
    /* The endpoint cannot be busy, we are in the context of the callback,
       so a packet is in the buffer for sure.*/
    osalSysUnlockFromISR();

    n = (n / maxsize) * maxsize;
 800690e:	fbb2 f2f3 	udiv	r2, r2, r3
 8006912:	6989      	ldr	r1, [r1, #24]
 8006914:	fb03 f302 	mul.w	r3, r3, r2

  osp->rxqueued           = true;
 8006918:	f04f 0e01 	mov.w	lr, #1
    usbPrepareQueuedReceive(usbp, ep, &sdup->iqueue, n);
 800691c:	340c      	adds	r4, #12
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;
 800691e:	6088      	str	r0, [r1, #8]
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
 8006920:	604b      	str	r3, [r1, #4]
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
  osp->mode.queue.rxqueue = iqp;
 8006922:	60cc      	str	r4, [r1, #12]
 */
void usbPrepareQueuedReceive(USBDriver *usbp, usbep_t ep,
                             input_queue_t *iqp, size_t n) {
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;

  osp->rxqueued           = true;
 8006924:	f881 e000 	strb.w	lr, [r1]
  osp->mode.queue.rxqueue = iqp;
  osp->rxsize             = n;
  osp->rxcnt              = 0;

  usb_lld_prepare_receive(usbp, ep);
 8006928:	4630      	mov	r0, r6
 800692a:	4629      	mov	r1, r5
 800692c:	f7ff f818 	bl	8005960 <usb_lld_prepare_receive>
 8006930:	f387 8811 	msr	BASEPRI, r7

    osalSysLockFromISR();
    (void) usbStartReceiveI(usbp, ep);
 8006934:	4630      	mov	r0, r6
 8006936:	4629      	mov	r1, r5
 8006938:	f7fe ffca 	bl	80058d0 <usbStartReceiveI>
 800693c:	e7de      	b.n	80068fc <sduDataReceived+0x3c>
 800693e:	bf00      	nop

08006940 <memset>:
 8006940:	b470      	push	{r4, r5, r6}
 8006942:	0784      	lsls	r4, r0, #30
 8006944:	d046      	beq.n	80069d4 <memset+0x94>
 8006946:	1e54      	subs	r4, r2, #1
 8006948:	2a00      	cmp	r2, #0
 800694a:	d041      	beq.n	80069d0 <memset+0x90>
 800694c:	b2cd      	uxtb	r5, r1
 800694e:	4603      	mov	r3, r0
 8006950:	e002      	b.n	8006958 <memset+0x18>
 8006952:	1e62      	subs	r2, r4, #1
 8006954:	b3e4      	cbz	r4, 80069d0 <memset+0x90>
 8006956:	4614      	mov	r4, r2
 8006958:	f803 5b01 	strb.w	r5, [r3], #1
 800695c:	079a      	lsls	r2, r3, #30
 800695e:	d1f8      	bne.n	8006952 <memset+0x12>
 8006960:	2c03      	cmp	r4, #3
 8006962:	d92e      	bls.n	80069c2 <memset+0x82>
 8006964:	b2cd      	uxtb	r5, r1
 8006966:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 800696a:	2c0f      	cmp	r4, #15
 800696c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8006970:	d919      	bls.n	80069a6 <memset+0x66>
 8006972:	f103 0210 	add.w	r2, r3, #16
 8006976:	4626      	mov	r6, r4
 8006978:	3e10      	subs	r6, #16
 800697a:	2e0f      	cmp	r6, #15
 800697c:	f842 5c10 	str.w	r5, [r2, #-16]
 8006980:	f842 5c0c 	str.w	r5, [r2, #-12]
 8006984:	f842 5c08 	str.w	r5, [r2, #-8]
 8006988:	f842 5c04 	str.w	r5, [r2, #-4]
 800698c:	f102 0210 	add.w	r2, r2, #16
 8006990:	d8f2      	bhi.n	8006978 <memset+0x38>
 8006992:	f1a4 0210 	sub.w	r2, r4, #16
 8006996:	f022 020f 	bic.w	r2, r2, #15
 800699a:	f004 040f 	and.w	r4, r4, #15
 800699e:	3210      	adds	r2, #16
 80069a0:	2c03      	cmp	r4, #3
 80069a2:	4413      	add	r3, r2
 80069a4:	d90d      	bls.n	80069c2 <memset+0x82>
 80069a6:	461e      	mov	r6, r3
 80069a8:	4622      	mov	r2, r4
 80069aa:	3a04      	subs	r2, #4
 80069ac:	2a03      	cmp	r2, #3
 80069ae:	f846 5b04 	str.w	r5, [r6], #4
 80069b2:	d8fa      	bhi.n	80069aa <memset+0x6a>
 80069b4:	1f22      	subs	r2, r4, #4
 80069b6:	f022 0203 	bic.w	r2, r2, #3
 80069ba:	3204      	adds	r2, #4
 80069bc:	4413      	add	r3, r2
 80069be:	f004 0403 	and.w	r4, r4, #3
 80069c2:	b12c      	cbz	r4, 80069d0 <memset+0x90>
 80069c4:	b2c9      	uxtb	r1, r1
 80069c6:	441c      	add	r4, r3
 80069c8:	f803 1b01 	strb.w	r1, [r3], #1
 80069cc:	42a3      	cmp	r3, r4
 80069ce:	d1fb      	bne.n	80069c8 <memset+0x88>
 80069d0:	bc70      	pop	{r4, r5, r6}
 80069d2:	4770      	bx	lr
 80069d4:	4614      	mov	r4, r2
 80069d6:	4603      	mov	r3, r0
 80069d8:	e7c2      	b.n	8006960 <memset+0x20>
 80069da:	bf00      	nop
 80069dc:	0000      	movs	r0, r0
	...

080069e0 <strcasecmp>:
 80069e0:	4b0f      	ldr	r3, [pc, #60]	; (8006a20 <strcasecmp+0x40>)
 80069e2:	b430      	push	{r4, r5}
 80069e4:	681d      	ldr	r5, [r3, #0]
 80069e6:	e002      	b.n	80069ee <strcasecmp+0xe>
 80069e8:	1ad2      	subs	r2, r2, r3
 80069ea:	d116      	bne.n	8006a1a <strcasecmp+0x3a>
 80069ec:	b1ab      	cbz	r3, 8006a1a <strcasecmp+0x3a>
 80069ee:	f810 4b01 	ldrb.w	r4, [r0], #1
 80069f2:	192b      	adds	r3, r5, r4
 80069f4:	4622      	mov	r2, r4
 80069f6:	785b      	ldrb	r3, [r3, #1]
 80069f8:	f003 0303 	and.w	r3, r3, #3
 80069fc:	2b01      	cmp	r3, #1
 80069fe:	f811 3b01 	ldrb.w	r3, [r1], #1
 8006a02:	bf08      	it	eq
 8006a04:	f104 0220 	addeq.w	r2, r4, #32
 8006a08:	18ec      	adds	r4, r5, r3
 8006a0a:	7864      	ldrb	r4, [r4, #1]
 8006a0c:	f004 0403 	and.w	r4, r4, #3
 8006a10:	2c01      	cmp	r4, #1
 8006a12:	d1e9      	bne.n	80069e8 <strcasecmp+0x8>
 8006a14:	3320      	adds	r3, #32
 8006a16:	1ad2      	subs	r2, r2, r3
 8006a18:	d0e9      	beq.n	80069ee <strcasecmp+0xe>
 8006a1a:	4610      	mov	r0, r2
 8006a1c:	bc30      	pop	{r4, r5}
 8006a1e:	4770      	bx	lr
 8006a20:	200008c8 	.word	0x200008c8
	...

08006a30 <strlen>:
 8006a30:	f020 0103 	bic.w	r1, r0, #3
 8006a34:	f010 0003 	ands.w	r0, r0, #3
 8006a38:	f1c0 0000 	rsb	r0, r0, #0
 8006a3c:	f851 3b04 	ldr.w	r3, [r1], #4
 8006a40:	f100 0c04 	add.w	ip, r0, #4
 8006a44:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8006a48:	f06f 0200 	mvn.w	r2, #0
 8006a4c:	bf1c      	itt	ne
 8006a4e:	fa22 f20c 	lsrne.w	r2, r2, ip
 8006a52:	4313      	orrne	r3, r2
 8006a54:	f04f 0c01 	mov.w	ip, #1
 8006a58:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 8006a5c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8006a60:	eba3 020c 	sub.w	r2, r3, ip
 8006a64:	ea22 0203 	bic.w	r2, r2, r3
 8006a68:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 8006a6c:	bf04      	itt	eq
 8006a6e:	f851 3b04 	ldreq.w	r3, [r1], #4
 8006a72:	3004      	addeq	r0, #4
 8006a74:	d0f4      	beq.n	8006a60 <strlen+0x30>
 8006a76:	f1c2 0100 	rsb	r1, r2, #0
 8006a7a:	ea02 0201 	and.w	r2, r2, r1
 8006a7e:	fab2 f282 	clz	r2, r2
 8006a82:	f1c2 021f 	rsb	r2, r2, #31
 8006a86:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 8006a8a:	4770      	bx	lr
 8006a8c:	0000      	movs	r0, r0
	...

08006a90 <strpbrk>:
 8006a90:	b430      	push	{r4, r5}
 8006a92:	7804      	ldrb	r4, [r0, #0]
 8006a94:	b1ec      	cbz	r4, 8006ad2 <strpbrk+0x42>
 8006a96:	780d      	ldrb	r5, [r1, #0]
 8006a98:	b1ad      	cbz	r5, 8006ac6 <strpbrk+0x36>
 8006a9a:	42ac      	cmp	r4, r5
 8006a9c:	d00e      	beq.n	8006abc <strpbrk+0x2c>
 8006a9e:	460a      	mov	r2, r1
 8006aa0:	e001      	b.n	8006aa6 <strpbrk+0x16>
 8006aa2:	429c      	cmp	r4, r3
 8006aa4:	d009      	beq.n	8006aba <strpbrk+0x2a>
 8006aa6:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8006aaa:	2b00      	cmp	r3, #0
 8006aac:	d1f9      	bne.n	8006aa2 <strpbrk+0x12>
 8006aae:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8006ab2:	2c00      	cmp	r4, #0
 8006ab4:	d1f0      	bne.n	8006a98 <strpbrk+0x8>
 8006ab6:	7815      	ldrb	r5, [r2, #0]
 8006ab8:	e000      	b.n	8006abc <strpbrk+0x2c>
 8006aba:	4625      	mov	r5, r4
 8006abc:	2d00      	cmp	r5, #0
 8006abe:	bf08      	it	eq
 8006ac0:	2000      	moveq	r0, #0
 8006ac2:	bc30      	pop	{r4, r5}
 8006ac4:	4770      	bx	lr
 8006ac6:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8006aca:	460a      	mov	r2, r1
 8006acc:	2c00      	cmp	r4, #0
 8006ace:	d1e3      	bne.n	8006a98 <strpbrk+0x8>
 8006ad0:	e7f1      	b.n	8006ab6 <strpbrk+0x26>
 8006ad2:	4620      	mov	r0, r4
 8006ad4:	bc30      	pop	{r4, r5}
 8006ad6:	4770      	bx	lr
	...

08006ae0 <strspn>:
 8006ae0:	b470      	push	{r4, r5, r6}
 8006ae2:	7804      	ldrb	r4, [r0, #0]
 8006ae4:	b1a4      	cbz	r4, 8006b10 <strspn+0x30>
 8006ae6:	780e      	ldrb	r6, [r1, #0]
 8006ae8:	4605      	mov	r5, r0
 8006aea:	b14e      	cbz	r6, 8006b00 <strspn+0x20>
 8006aec:	42b4      	cmp	r4, r6
 8006aee:	d00a      	beq.n	8006b06 <strspn+0x26>
 8006af0:	460a      	mov	r2, r1
 8006af2:	e001      	b.n	8006af8 <strspn+0x18>
 8006af4:	429c      	cmp	r4, r3
 8006af6:	d006      	beq.n	8006b06 <strspn+0x26>
 8006af8:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8006afc:	2b00      	cmp	r3, #0
 8006afe:	d1f9      	bne.n	8006af4 <strspn+0x14>
 8006b00:	1a28      	subs	r0, r5, r0
 8006b02:	bc70      	pop	{r4, r5, r6}
 8006b04:	4770      	bx	lr
 8006b06:	f815 4f01 	ldrb.w	r4, [r5, #1]!
 8006b0a:	2c00      	cmp	r4, #0
 8006b0c:	d1ed      	bne.n	8006aea <strspn+0xa>
 8006b0e:	e7f7      	b.n	8006b00 <strspn+0x20>
 8006b10:	4620      	mov	r0, r4
 8006b12:	e7f6      	b.n	8006b02 <strspn+0x22>
	...

08006b20 <atoi>:
 8006b20:	2100      	movs	r1, #0
 8006b22:	220a      	movs	r2, #10
 8006b24:	f000 b894 	b.w	8006c50 <strtol>
	...

08006b30 <_strtol_r>:
 8006b30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006b34:	4c44      	ldr	r4, [pc, #272]	; (8006c48 <_strtol_r+0x118>)
 8006b36:	4683      	mov	fp, r0
 8006b38:	460e      	mov	r6, r1
 8006b3a:	f8d4 e000 	ldr.w	lr, [r4]
 8006b3e:	e000      	b.n	8006b42 <_strtol_r+0x12>
 8006b40:	4626      	mov	r6, r4
 8006b42:	4634      	mov	r4, r6
 8006b44:	f814 5b01 	ldrb.w	r5, [r4], #1
 8006b48:	eb0e 0005 	add.w	r0, lr, r5
 8006b4c:	7840      	ldrb	r0, [r0, #1]
 8006b4e:	f000 0008 	and.w	r0, r0, #8
 8006b52:	f000 08ff 	and.w	r8, r0, #255	; 0xff
 8006b56:	2800      	cmp	r0, #0
 8006b58:	d1f2      	bne.n	8006b40 <_strtol_r+0x10>
 8006b5a:	2d2d      	cmp	r5, #45	; 0x2d
 8006b5c:	d04b      	beq.n	8006bf6 <_strtol_r+0xc6>
 8006b5e:	2d2b      	cmp	r5, #43	; 0x2b
 8006b60:	bf04      	itt	eq
 8006b62:	7875      	ldrbeq	r5, [r6, #1]
 8006b64:	1cb4      	addeq	r4, r6, #2
 8006b66:	b11b      	cbz	r3, 8006b70 <_strtol_r+0x40>
 8006b68:	2b10      	cmp	r3, #16
 8006b6a:	d060      	beq.n	8006c2e <_strtol_r+0xfe>
 8006b6c:	469a      	mov	sl, r3
 8006b6e:	e003      	b.n	8006b78 <_strtol_r+0x48>
 8006b70:	2d30      	cmp	r5, #48	; 0x30
 8006b72:	d054      	beq.n	8006c1e <_strtol_r+0xee>
 8006b74:	230a      	movs	r3, #10
 8006b76:	469a      	mov	sl, r3
 8006b78:	f1b8 0f00 	cmp.w	r8, #0
 8006b7c:	bf14      	ite	ne
 8006b7e:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 8006b82:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8006b86:	2700      	movs	r7, #0
 8006b88:	fbb0 f9fa 	udiv	r9, r0, sl
 8006b8c:	46bc      	mov	ip, r7
 8006b8e:	fb0a 0019 	mls	r0, sl, r9, r0
 8006b92:	e00c      	b.n	8006bae <_strtol_r+0x7e>
 8006b94:	3d30      	subs	r5, #48	; 0x30
 8006b96:	42ab      	cmp	r3, r5
 8006b98:	dd19      	ble.n	8006bce <_strtol_r+0x9e>
 8006b9a:	1c7e      	adds	r6, r7, #1
 8006b9c:	d005      	beq.n	8006baa <_strtol_r+0x7a>
 8006b9e:	45cc      	cmp	ip, r9
 8006ba0:	d824      	bhi.n	8006bec <_strtol_r+0xbc>
 8006ba2:	d021      	beq.n	8006be8 <_strtol_r+0xb8>
 8006ba4:	fb0a 5c0c 	mla	ip, sl, ip, r5
 8006ba8:	2701      	movs	r7, #1
 8006baa:	f814 5b01 	ldrb.w	r5, [r4], #1
 8006bae:	eb0e 0605 	add.w	r6, lr, r5
 8006bb2:	7876      	ldrb	r6, [r6, #1]
 8006bb4:	f016 0f04 	tst.w	r6, #4
 8006bb8:	d1ec      	bne.n	8006b94 <_strtol_r+0x64>
 8006bba:	f016 0603 	ands.w	r6, r6, #3
 8006bbe:	d006      	beq.n	8006bce <_strtol_r+0x9e>
 8006bc0:	2e01      	cmp	r6, #1
 8006bc2:	bf0c      	ite	eq
 8006bc4:	2637      	moveq	r6, #55	; 0x37
 8006bc6:	2657      	movne	r6, #87	; 0x57
 8006bc8:	1bad      	subs	r5, r5, r6
 8006bca:	42ab      	cmp	r3, r5
 8006bcc:	dce5      	bgt.n	8006b9a <_strtol_r+0x6a>
 8006bce:	1c7b      	adds	r3, r7, #1
 8006bd0:	d016      	beq.n	8006c00 <_strtol_r+0xd0>
 8006bd2:	f1c8 0000 	rsb	r0, r8, #0
 8006bd6:	ea8c 0000 	eor.w	r0, ip, r0
 8006bda:	4440      	add	r0, r8
 8006bdc:	b14a      	cbz	r2, 8006bf2 <_strtol_r+0xc2>
 8006bde:	b107      	cbz	r7, 8006be2 <_strtol_r+0xb2>
 8006be0:	1e61      	subs	r1, r4, #1
 8006be2:	6011      	str	r1, [r2, #0]
 8006be4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006be8:	4285      	cmp	r5, r0
 8006bea:	dddb      	ble.n	8006ba4 <_strtol_r+0x74>
 8006bec:	f04f 37ff 	mov.w	r7, #4294967295
 8006bf0:	e7db      	b.n	8006baa <_strtol_r+0x7a>
 8006bf2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006bf6:	1cb4      	adds	r4, r6, #2
 8006bf8:	7875      	ldrb	r5, [r6, #1]
 8006bfa:	f04f 0801 	mov.w	r8, #1
 8006bfe:	e7b2      	b.n	8006b66 <_strtol_r+0x36>
 8006c00:	f1b8 0f00 	cmp.w	r8, #0
 8006c04:	f04f 0322 	mov.w	r3, #34	; 0x22
 8006c08:	bf14      	ite	ne
 8006c0a:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 8006c0e:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8006c12:	f8cb 3000 	str.w	r3, [fp]
 8006c16:	2a00      	cmp	r2, #0
 8006c18:	d1e2      	bne.n	8006be0 <_strtol_r+0xb0>
 8006c1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006c1e:	7823      	ldrb	r3, [r4, #0]
 8006c20:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 8006c24:	2b58      	cmp	r3, #88	; 0x58
 8006c26:	d009      	beq.n	8006c3c <_strtol_r+0x10c>
 8006c28:	2308      	movs	r3, #8
 8006c2a:	469a      	mov	sl, r3
 8006c2c:	e7a4      	b.n	8006b78 <_strtol_r+0x48>
 8006c2e:	2d30      	cmp	r5, #48	; 0x30
 8006c30:	d19c      	bne.n	8006b6c <_strtol_r+0x3c>
 8006c32:	7820      	ldrb	r0, [r4, #0]
 8006c34:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 8006c38:	2858      	cmp	r0, #88	; 0x58
 8006c3a:	d197      	bne.n	8006b6c <_strtol_r+0x3c>
 8006c3c:	f04f 0a10 	mov.w	sl, #16
 8006c40:	7865      	ldrb	r5, [r4, #1]
 8006c42:	4653      	mov	r3, sl
 8006c44:	3402      	adds	r4, #2
 8006c46:	e797      	b.n	8006b78 <_strtol_r+0x48>
 8006c48:	200008c8 	.word	0x200008c8
 8006c4c:	00000000 	.word	0x00000000

08006c50 <strtol>:
 8006c50:	b430      	push	{r4, r5}
 8006c52:	4c04      	ldr	r4, [pc, #16]	; (8006c64 <strtol+0x14>)
 8006c54:	460d      	mov	r5, r1
 8006c56:	4613      	mov	r3, r2
 8006c58:	4601      	mov	r1, r0
 8006c5a:	462a      	mov	r2, r5
 8006c5c:	6820      	ldr	r0, [r4, #0]
 8006c5e:	bc30      	pop	{r4, r5}
 8006c60:	f7ff bf66 	b.w	8006b30 <_strtol_r>
 8006c64:	20000cf8 	.word	0x20000cf8
	...
 8006c70:	5f627375 	.word	0x5f627375
 8006c74:	5f646c6c 	.word	0x5f646c6c
 8006c78:	706d7570 	.word	0x706d7570
 8006c7c:	00000000 	.word	0x00000000
 8006c80:	65636572 	.word	0x65636572
 8006c84:	72657669 	.word	0x72657669
 8006c88:	00000000 	.word	0x00000000
 8006c8c:	00004e4f 	.word	0x00004e4f
 8006c90:	0a0d6469 	.word	0x0a0d6469
 8006c94:	00000000 	.word	0x00000000
 8006c98:	61656c50 	.word	0x61656c50
 8006c9c:	44492073 	.word	0x44492073
 8006ca0:	000a0d3a 	.word	0x000a0d3a
 8006ca4:	695f4449 	.word	0x695f4449
 8006ca8:	2d3a746e 	.word	0x2d3a746e
 8006cac:	2d64252d 	.word	0x2d64252d
 8006cb0:	000a0d2d 	.word	0x000a0d2d
 8006cb4:	0d0a6469 	.word	0x0d0a6469
 8006cb8:	00000000 	.word	0x00000000
 8006cbc:	61656c50 	.word	0x61656c50
 8006cc0:	41442073 	.word	0x41442073
 8006cc4:	0a3a4154 	.word	0x0a3a4154
 8006cc8:	0000000d 	.word	0x0000000d
 8006ccc:	756c6176 	.word	0x756c6176
 8006cd0:	25203a65 	.word	0x25203a65
 8006cd4:	000a0d78 	.word	0x000a0d78
 8006cd8:	706d6574 	.word	0x706d6574
 8006cdc:	00000a0d 	.word	0x00000a0d
 8006ce0:	534e4553 	.word	0x534e4553
 8006ce4:	315f524f 	.word	0x315f524f
 8006ce8:	6425203a 	.word	0x6425203a
 8006cec:	00000a0d 	.word	0x00000a0d
 8006cf0:	534e4553 	.word	0x534e4553
 8006cf4:	325f524f 	.word	0x325f524f
 8006cf8:	6425203a 	.word	0x6425203a
 8006cfc:	00000a0d 	.word	0x00000a0d
 8006d00:	534e4553 	.word	0x534e4553
 8006d04:	335f524f 	.word	0x335f524f
 8006d08:	6425203a 	.word	0x6425203a
 8006d0c:	00000a0d 	.word	0x00000a0d
 8006d10:	72616c61 	.word	0x72616c61
 8006d14:	25203a6d 	.word	0x25203a6d
 8006d18:	000a0d64 	.word	0x000a0d64
 8006d1c:	68676968 	.word	0x68676968
 8006d20:	706d6574 	.word	0x706d6574
 8006d24:	6425203a 	.word	0x6425203a
 8006d28:	000a0a0d 	.word	0x000a0a0d
 8006d2c:	0a0d6425 	.word	0x0a0d6425
 8006d30:	0000000a 	.word	0x0000000a
 8006d34:	6e617274 	.word	0x6e617274
 8006d38:	74696d73 	.word	0x74696d73
 8006d3c:	00726574 	.word	0x00726574
 8006d40:	7a7a7566 	.word	0x7a7a7566
 8006d44:	00000079 	.word	0x00000079
 8006d48:	6f636572 	.word	0x6f636572
 8006d4c:	6769666e 	.word	0x6769666e
 8006d50:	0a2e2e2e 	.word	0x0a2e2e2e
 8006d54:	0000000d 	.word	0x0000000d
 8006d58:	656e6f64 	.word	0x656e6f64
 8006d5c:	000d0a3a 	.word	0x000d0a3a
 8006d60:	3a544e49 	.word	0x3a544e49
 8006d64:	0a642520 	.word	0x0a642520
 8006d68:	00000d0a 	.word	0x00000d0a
 8006d6c:	435f5852 	.word	0x435f5852
 8006d70:	203a4e41 	.word	0x203a4e41
 8006d74:	25205825 	.word	0x25205825
 8006d78:	58252058 	.word	0x58252058
 8006d7c:	000d0a0a 	.word	0x000d0a0a

08006d80 <pwmcfg.15718.5033>:
 8006d80:	0013d620 00000100 00000000 00000001      ...............
 8006d90:	00000000 00000001 00000000 00000001     ................
 8006da0:	00000000 00000001 00000000 00000000     ................
	...

08006dc0 <fsparams.10178.5078>:
 8006dc0:	00000080 00000140 00000003 00000000     ....@...........

08006dd0 <serusbcfg>:
 8006dd0:	200011b8 00020101 00000000 00000000     ... ............

08006de0 <ch_debug.5036>:
 8006de0:	6e69616d 18031600 08440404 1814100c     main......D.....
 8006df0:	1e1d1c00 00000000 00000000 00000000     ................
 8006e00:	6c656873 0000006c 68430a0d 4f696269     shell.....ChibiO
 8006e10:	54522f53 65685320 0a0d6c6c 00000000     S/RT Shell......
 8006e20:	203e6863 00000000 0000445e 206f6f74     ch> ....^D..too 
 8006e30:	796e616d 67726120 6e656d75 0a0d7374     many arguments..
 8006e40:	00000000 74697865 00000000 67617355     ....exit....Usag
 8006e50:	25203a65 000a0d73 706c6568 00000000     e: %s...help....
 8006e60:	6d6d6f43 73646e61 6568203a 6520706c     Commands: help e
 8006e70:	20746978 00000000 00207325 00007325     xit ....%s .%s..
 8006e80:	0a0d3f20 00000000 6f6c0a0d 74756f67      ?........logout
 8006e90:	00000000 656c6469 00000000 6f666e69     ....idle....info
 8006ea0:	00000000 74737973 00656d69 00000000     ....systime.....

08006eb0 <cancfg2.15033.5029>:
 8006eb0:	00000064 40180006 00000000 00000000     d......@........

08006ec0 <vmt.8002.5079>:
 8006ec0:	080042f1 08003fc1 08004061 08003f01     .B...?..a@...?..
 8006ed0:	08004051 08003ef1 080042e1 08003fb1     Q@...>...B...?..

08006ee0 <cancfg.15034.5027>:
 8006ee0:	00000064 00180006 00000000 00000000     d...............

08006ef0 <pwmcfg2.15716.5035>:
 8006ef0:	0013d620 00000100 00000000 00000001      ...............
 8006f00:	00000000 00000001 00000000 00000001     ................
 8006f10:	00000000 00000001 00000000 00000000     ................
	...

08006f30 <extcfg.15536>:
 8006f30:	00000026 080020f1 00000026 08002101     &.... ..&....!..
 8006f40:	00000026 08002111 00000026 08002121     &....!..&...!!..
	...
 8006ff0:	69666977 7250203a 7365636f 676e6973     wifi: Processing
 8007000:	0a2e2e2e 0000000d 00000000 00000000     ................

08007010 <active_status.8884.4780>:
	...

08007020 <ep0config.10179.4766>:
 8007020:	00000000 08004b81 08004a21 08004411     .....K..!J...D..
 8007030:	00400040 200023f4 200023f4 00000001     @.@..#. .#. ....
 8007040:	20002408 00000000 00000000 00000000     .$. ............
 8007050:	67617355 6d203a65 0a0d6d65 00000000     Usage: mem......
 8007060:	65726f63 65726620 656d2065 79726f6d     core free memory
 8007070:	25203a20 79622075 0d736574 0000000a      : %u bytes.....
 8007080:	70616568 61726620 6e656d67 20207374     heap fragments  
 8007090:	25203a20 000a0d75 70616568 65726620      : %u...heap fre
 80070a0:	6f742065 206c6174 25203a20 79622075     e total  : %u by
 80070b0:	0d736574 0000000a 736f6c63 0a206465     tes.....closed .
 80070c0:	0000000d 00006325 00000000 00000000     ....%c..........

080070d0 <halted_status.8883.4779>:
 80070d0:	00000001 00000000 00000000 00000000     ................

080070e0 <ep2config.14046.4775>:
 80070e0:	00000003 00000000 08001131 00000000     ........1.......
 80070f0:	00000010 200023e0 00000000 00000001     .....#. ........
	...

08007110 <zero_status.8882.4778>:
	...

08007120 <vcom_string2.14052.4665>:
 8007120:	00430338 00690068 00690062 0053004f     8.C.h.i.b.i.O.S.
 8007130:	0052002f 00200054 00690056 00740072     /.R.T. .V.i.r.t.
 8007140:	00610075 0020006c 004f0043 0020004d     u.a.l. .C.O.M. .
 8007150:	006f0050 00740072 00000000 00000000     P.o.r.t.........

08007160 <vcom_strings.14049.4662>:
 8007160:	00000004 080074f0 00000026 08007180     .....t..&....q..
 8007170:	00000038 08007120 00000008 08007500     8... q.......u..

08007180 <vcom_string1.14051.4664>:
 8007180:	00530326 004d0054 00630069 006f0072     &.S.T.M.i.c.r.o.
 8007190:	006c0065 00630065 00720074 006e006f     e.l.e.c.t.r.o.n.
 80071a0:	00630069 00000073 00000000 00000000     i.c.s...........

080071b0 <states.8439.16257.4658>:
 80071b0:	08007460 08007468 08007470 08007478     `t..ht..pt..xt..
 80071c0:	08007484 0800748c 08007494 0800749c     .t...t...t...t..
 80071d0:	080074a4 080074b0 080074b8 080074c0     .t...t...t...t..
 80071e0:	080074cc 080074d4 080074dc 080074e4     .t...t...t...t..
 80071f0:	6c756e28 0000296c 00000920 67617355     (null).. ...Usag
 8007200:	74203a65 61657268 0a0d7364 00000000     e: threads......
 8007210:	20202020 72646461 20202020 63617473         addr    stac
 8007220:	7270206b 72206f69 20736665 20202020     k prio refs     
 8007230:	74617473 000a0d65 6c383025 30252078     state...%08lx %0
 8007240:	20786c38 756c3425 6c342520 39252075     8lx %4lu %4lu %9
 8007250:	000a0d73 61656c50 45442073 45434956     s...Pleas DEVICE
 8007260:	3a44495f 00000a0d 5f564544 695f4449     _ID:....DEV_ID_i
 8007270:	203a746e 64252d2d 0a0d2d2d 00000000     nt: --%d--......
 8007280:	67617355 74203a65 0d747365 0000000a     Usage: test.....
 8007290:	2074756f 6d20666f 726f6d65 000a0d79     out of memory...
 80072a0:	6e72654b 203a6c65 20202020 73252020     Kernel:       %s
 80072b0:	00000a0d 2e302e33 00000033 706d6f43     ....3.0.3...Comp
 80072c0:	72656c69 2020203a 73252020 00000a0d     iler:     %s....
 80072d0:	20434347 2e382e34 30322034 32313431     GCC 4.8.4 201412
 80072e0:	28203931 656c6572 29657361 00000000     19 (release)....
 80072f0:	68637241 63657469 65727574 7325203a     Architecture: %s
 8007300:	00000a0d 764d5241 454d2d37 00000000     ....ARMv7-ME....
 8007310:	65726f43 72615620 746e6169 7325203a     Core Variant: %s
 8007320:	00000a0d 74726f43 4d2d7865 00000034     ....Cortex-M4...
 8007330:	74726f50 666e4920 20203a6f 73252020     Port Info:    %s
 8007340:	00000a0d 61766441 6465636e 72656b20     ....Advanced ker
 8007350:	206c656e 65646f6d 00000000 74616c50     nel mode....Plat
 8007360:	6d726f66 2020203a 73252020 00000a0d     form:     %s....
 8007370:	334d5453 30344632 69482037 50206867     STM32F407 High P
 8007380:	6f667265 6e616d72 77206563 20687469     erformance with 
 8007390:	20505344 20646e61 00555046 72616f42     DSP and FPU.Boar
 80073a0:	20203a64 20202020 73252020 00000a0d     d:        %s....
 80073b0:	694d5453 656f7263 7463656c 696e6f72     STMicroelectroni
 80073c0:	53207363 32334d54 442d3446 6f637369     cs STM32F4-Disco
 80073d0:	79726576 00000000 6c697542 69742064     very....Build ti
 80073e0:	203a656d 73252020 73257325 00000a0d     me:   %s%s%s....
 80073f0:	2072614d 32203220 00363130 00202d20     Mar  2 2016. - .
 8007400:	323a3631 39323a33 00000000 0d756c25     16:23:29....%lu.
 8007410:	0000000a 0a0d6469 0000000d 414c4552     ....id......RELA
 8007420:	54532059 53455441 56203020 0a3a3120     Y STATES 0 V 1:.
 8007430:	0000000d 54415453 2d203a45 2d73252d     ....STATE: --%s-
 8007440:	0d0a0a2d 00000000 414c4552 4e4f2059     -.......RELAY ON
 8007450:	00000d0a 414c4552 464f2059 000d0a46     ....RELAY OFF...
 8007460:	44414552 00000059 52525543 00544e45     READY...CURRENT.
 8007470:	54535457 00545241 50535553 45444e45     WTSTART.SUSPENDE
 8007480:	00000044 55455551 00004445 45535457     D...QUEUED..WTSE
 8007490:	0000004d 544d5457 00000058 4f435457     M...WTMTX...WTCO
 80074a0:	0000444e 45454c53 474e4950 00000000     ND..SLEEPING....
 80074b0:	58455457 00005449 524f5457 00545645     WTEXIT..WTOREVT.
 80074c0:	4e415457 54564544 00000000 4d444e53     WTANDEVT....SNDM
 80074d0:	00514753 4d444e53 00004753 534d5457     SGQ.SNDMSG..WTMS
 80074e0:	00000047 414e4946 0000004c 00000000     G...FINAL.......

080074f0 <vcom_string0.14050.4663>:
 80074f0:	04090304 00000000 00000000 00000000     ................

08007500 <vcom_string3.14053.4666>:
 8007500:	00330308 00330030 00000000 00000000     ..3.0.3.........

08007510 <vcom_configuration_descriptor_data.14057.4670>:
 8007510:	00430209 c0000102 00040932 02020100     ..C.....2.......
 8007520:	24050001 05011000 01000124 02022404     ...$....$....$..
 8007530:	00062405 82050701 ff000803 00010409     .$..............
 8007540:	00000a02 01050700 00004002 02810507     .........@......
 8007550:	00000040 00000000 00000000 00000000     @...............

08007560 <vcom_configuration_descriptor.14056.4669>:
 8007560:	00000043 08007510 00000000 00000000     C....u..........

08007570 <vcom_device_descriptor.14054.4667>:
 8007570:	00000012 08007580 00000000 00000000     .....u..........

08007580 <vcom_device_descriptor_data.14055.4668>:
 8007580:	01100112 40000002 57400483 02010200     .......@..@W....
 8007590:	00000103 00000000 00000000 00000000     ................
 80075a0:	655f4e4f 00007478 00000000 00000000     ON_ext..........

080075b0 <commands.16211.4669>:
 80075b0:	0800767c 08004af1 08007680 08005461     |v...J...v..aT..
 80075c0:	08007688 08005561 08007690 08002491     .v..aU...v...$..
 80075d0:	08007694 080023b1 08007698 08002411     .v...#...v...$..
 80075e0:	0800769c 08005501 080076a0 080056b1     .v...U...v...V..
 80075f0:	080076a8 08002bb1 080076ac 08004101     .v...+...v...A..
 8007600:	080076b0 08002991 080076b4 08004f11     .v...)...v...O..
	...

08007620 <shell_cfg1.16209.4667>:
 8007620:	20002418 080075b0 00000000 00000000     .$. .u..........

08007630 <vmt.8449.4714>:
 8007630:	080042d1 08003fa1 08004041 08003ee1     .B...?..A@...>..
 8007640:	08004031 08003ed1 080042c1 08003f91     1@...>...B...?..

08007650 <usbcfg.4670>:
 8007650:	08004981 08005241 08001141 00000000     .I..AR..A.......
 8007660:	706d6554 72727543 4c726e65 74696d69     TempCurrenrLimit
 8007670:	00007265 74627375 006d7265 006d656d     er..usbterm.mem.
 8007680:	65726874 00736461 74736574 00000000     threads.test....
 8007690:	00000074 00646970 00616470 00766564     t...pid.pda.dev.
 80076a0:	616c6572 00000079 00000072 00000077     relay...r...w...
 80076b0:	0000006e 00000078 00000000 00000000     n...x...........

080076c0 <ep1config.14043>:
 80076c0:	00000002 00000000 08006831 080068c1     ........1h...h..
 80076d0:	00400040 20002674 20002698 00000002     @.@.t&. .&. ....
	...

080076f0 <_ctype_>:
 80076f0:	20202000 20202020 28282020 20282828     .         ((((( 
 8007700:	20202020 20202020 20202020 20202020                     
 8007710:	10108820 10101010 10101010 10101010      ...............
 8007720:	04040410 04040404 10040404 10101010     ................
 8007730:	41411010 41414141 01010101 01010101     ..AAAAAA........
 8007740:	01010101 01010101 01010101 10101010     ................
 8007750:	42421010 42424242 02020202 02020202     ..BBBBBB........
 8007760:	02020202 02020202 02020202 10101010     ................
 8007770:	00000020 00000000 00000000 00000000      ...............
	...
 8007800:	00000043                                         C.
